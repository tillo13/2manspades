Number of files: 15
Number of directories: 5

Directory structure:
.
static
templates
utilities
utilities/__pycache__

List of file paths by type:

HTML Files (2):
  ./templates/index.html
  ./templates/instructions.html

JS Files (1):
  ./static/game.js

JSON Files (1):
  ./static/manifest.json

PY Files (11):
  ./app.py
  ./gather_pythons.py
  ./gcloud_deploy.py
  ./test_postg.py
  ./utilities/app_helpers.py
  ./utilities/claude_utils.py
  ./utilities/computer_logic.py
  ./utilities/custom_rules.py
  ./utilities/gameplay_logic.py
  ./utilities/logging_utils.py
  ./utilities/postgres_utils.py

================================================================================
FILE CONTENTS
================================================================================

FILE: ./gcloud_deploy.py
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Deployment script for Two Man Spades
This script manages deployment to Google App Engine for twomanspades project.
"""

import subprocess
import json
import time
import os
import sys
import random
import string

# Configuration - TWO MAN SPADES PROJECT SPECIFIC
EXPECTED_PROJECT_ID = "twomanspades"  # Critical: This must match your project
SERVICE_NAME = "default"
VERSION_MAX = 15  # Keep 15 versions to minimize storage costs

def print_separator():
    """Print a visual separator in console output."""
    print("\n" + "="*70 + "\n")

def check_gcloud_project():
    """Verify we're using the correct GCP project - CRITICAL SAFEGUARD."""
    print_separator()
    print("ðŸ”’ VERIFYING GOOGLE CLOUD PROJECT CONFIGURATION...")
    print(f"Expected project: {EXPECTED_PROJECT_ID}")
    
    try:
        current_project = subprocess.run(
            ["gcloud", "config", "get-value", "project"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True
        ).stdout.decode().strip()
        
        print(f"Current project:  {current_project}")
        
        if current_project != EXPECTED_PROJECT_ID:
            print(f"âŒ ERROR: Current gcloud project is '{current_project}' but expected '{EXPECTED_PROJECT_ID}'")
            print(f"ðŸ”„ Attempting to switch to the correct project...")
            
            # Try to use an existing configuration first
            try:
                configs_result = subprocess.run(
                    ["gcloud", "config", "configurations", "list", "--format=value(name)"],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True
                )
                configs = configs_result.stdout.decode().strip().split('\n')
                
                if "twomanspades-config" in configs:
                    print("ðŸ“‹ Using existing twomanspades-config configuration")
                    subprocess.run(
                        ["gcloud", "config", "configurations", "activate", "twomanspades-config"],
                        check=True
                    )
                else:
                    print("âš™ï¸  Setting project directly")
                    subprocess.run(
                        ["gcloud", "config", "set", "project", EXPECTED_PROJECT_ID],
                        check=True
                    )
            except subprocess.CalledProcessError:
                print("âš™ï¸  Setting project directly")
                subprocess.run(
                    ["gcloud", "config", "set", "project", EXPECTED_PROJECT_ID],
                    check=True
                )
            
            # CRITICAL: Verify the switch was successful
            current_project = subprocess.run(
                ["gcloud", "config", "get-value", "project"],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True
            ).stdout.decode().strip()
            
            if current_project != EXPECTED_PROJECT_ID:
                print(f"âŒ CRITICAL ERROR: Failed to switch to project {EXPECTED_PROJECT_ID}")
                print("ðŸ›‘ DEPLOYMENT ABORTED to prevent deploying to wrong project!")
                print("")
                print("Please manually set the project with one of these commands:")
                print(f"  gcloud config configurations activate twomanspades-config")
                print(f"  gcloud config set project {EXPECTED_PROJECT_ID}")
                print("")
                print("Then re-run this script.")
                sys.exit(1)
            else:
                print(f"âœ… Successfully switched to project {EXPECTED_PROJECT_ID}")
        else:
            print(f"âœ… Project verification passed - correctly configured for {EXPECTED_PROJECT_ID}")
    
    except subprocess.CalledProcessError as e:
        print(f"âŒ Error checking Google Cloud project: {e}")
        print("ðŸ›‘ DEPLOYMENT ABORTED")
        sys.exit(1)

# Function to get versions of a service
def get_versions(service_name):
    """Fetch the current versions of the App Engine service."""
    print(f"ðŸ“‹ Checking existing versions for service: {service_name}...")
    try:
        result = subprocess.run(
            ["gcloud", "app", "versions", "list", 
             "--service", service_name, 
             "--format", "json", 
             "--project", EXPECTED_PROJECT_ID],  # Always specify project
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        versions = json.loads(result.stdout)
        versions.sort(key=lambda x: x["version"]["createTime"], reverse=True)
        return versions
    except subprocess.CalledProcessError as e:
        if "Service not found" in e.stderr.decode() or f"Service [{service_name}] not found" in e.stderr.decode():
            print(f"ðŸ“ Service {service_name} not found. It will be created during deployment.")
            return []
        else:
            print(f"âŒ Error getting versions: {e.stderr.decode()}")
            raise e

# Function to delete versions
def delete_old_versions(service_name, versions_to_delete):
    """Delete older versions to maintain version limit."""
    if not versions_to_delete:
        return
    
    print(f"ðŸ§¹ Cleaning up old versions. Deleting {len(versions_to_delete)} older versions...")
    
    for v in versions_to_delete:
        version_id = v["id"]
        print(f"  - Deleting version {service_name}-{version_id}")
        subprocess.run(
            ["gcloud", "app", "versions", "delete", version_id, 
             "--service", service_name, 
             "--quiet", 
             "--project", EXPECTED_PROJECT_ID],  # Always specify project
            check=True)
    
    print("âœ… Cleanup complete.")

# Function to get changed files using git diff
def get_changed_files(directory):
    """Get list of new or modified files using git diff"""
    try:
        result = subprocess.run(
            ["git", "-C", directory, "diff", "--name-only", "HEAD^", "HEAD"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        files = result.stdout.decode().strip().split("\n")
        return [os.path.join(directory, f) for f in files if f]
    except subprocess.CalledProcessError:
        print("â„¹ï¸  Error determining changed files (this is normal for first deployment).")
        return []

def list_files_to_upload():
    """List files that will be uploaded to Google Cloud Storage."""
    print("ðŸ“ Files to be uploaded:")
    
    # Fallback: manually parse .gcloudignore and list files
    ignored_patterns = set()
    if os.path.exists('.gcloudignore'):
        with open('.gcloudignore', 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    ignored_patterns.add(line.rstrip('/'))
    
    # Default ignore patterns if no .gcloudignore exists
    if not ignored_patterns:
        ignored_patterns = {
            '.git',  'logging', '__pycache__', '*.pyc', '.env', 'venv*', 
            '.vscode', '.idea', '*.md', 'gather_pythons.py', 
            '*_project_structure.txt'
        }
    
    # Walk directory and respect .gcloudignore patterns
    files_to_upload = []
    for root, dirs, files in os.walk('.'):
        # Remove ignored directories from dirs to prevent walking into them
        dirs[:] = [d for d in dirs if not any(
            d == pattern or f"{root}/{d}".startswith(f"./{pattern}")
            for pattern in ignored_patterns
        )]
        
        for file in files:
            rel_path = os.path.relpath(os.path.join(root, file), '.')
            # Skip if file matches any ignore pattern
            if not any(
                rel_path.startswith(pattern) or file.endswith(pattern.lstrip('*'))
                for pattern in ignored_patterns
            ):
                files_to_upload.append(rel_path)
    
    # Print the files
    for file in sorted(files_to_upload):
        print(f"  - {file}")
    
    print(f"\nðŸ“Š Total files to upload: {len(files_to_upload)}")

# Function to generate a valid version name
def generate_version_name():
    random_string = ''.join(random.choices(string.ascii_lowercase + string.digits, k=10))
    return f"version-{random_string}"

# Function to deploy the services
def deploy_service(service_name, yaml_path):
    """Deploy the application to Google App Engine."""
    start_time = time.time()
    current_directory = os.path.dirname(os.path.abspath(yaml_path))
    
    print_separator()
    print(f"ðŸš€ DEPLOYING TWO MAN SPADES TO GOOGLE APP ENGINE")
    print(f"ðŸ“¦ Project: {EXPECTED_PROJECT_ID}")
    print(f"âš™ï¸  Service: {service_name}")
    print(f"ðŸ“‚ Deploy from: {current_directory}")
    print(f"ðŸ“„ Using config: {yaml_path}")
    print_separator()
    
    # List changed files
    print("ðŸ“ Listing new or modified files to be uploaded:")
    changed_files = get_changed_files(current_directory)
    if changed_files:
        for file_path in changed_files:
            print(f"  ðŸ“„ Changed file: {file_path}")
    else:
        print("  â„¹ï¸  No new or modified files detected (normal for first deployment).")
    
    # Check the current versions
    try:
        versions = get_versions(service_name)
        print(f"âœ… {len(versions)} versions retrieved successfully.")
    except subprocess.CalledProcessError as e:
        versions = []
        print(f"âš ï¸  Failed to get versions. Error: {e}")
        print(f"ðŸ“ First deployment for service {service_name}. Proceeding with deployment.")
    
    print(f"ðŸ“Š You currently have {len(versions)} versions for {service_name}.")
    if versions:
        print(f"ðŸ“‹ The latest version is {versions[0]['id']} for {service_name}.")
    
    if len(versions) > VERSION_MAX:
        print(f"ðŸ§¹ More than {VERSION_MAX} versions exist for {service_name}.")
    
    # Show files that will be uploaded
    print_separator()
    list_files_to_upload()
    
    # Deploy new version
    print_separator()
    version_name = generate_version_name()
    print(f"ðŸš€ Deploying new version: {version_name}")
    try:
        result = subprocess.run([
            "gcloud", "app", "deploy", yaml_path, 
            "--quiet", 
            "--project", EXPECTED_PROJECT_ID,  # Always specify project
            "--version", version_name
        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        print("âœ… Deployment successful!")
    except subprocess.CalledProcessError as e:
        print(f"âŒ Failed to deploy new version. Error: {e.stderr.decode()}")
        return  # Early exit if deployment fails
    
    # Delete old versions if needed
    if len(versions) > VERSION_MAX:
        print_separator()
        try:
            # Get fresh list of versions after deployment
            updated_versions = get_versions(service_name)
            versions_to_delete = updated_versions[VERSION_MAX:]
            delete_old_versions(service_name, versions_to_delete)
        except subprocess.CalledProcessError as e:
            print(f"âš ï¸  Failed to delete old versions. Error: {e.stderr.decode()}")

    # Calculate and display execution time
    end_time = time.time()
    execution_time = end_time - start_time
    
    # Display the target URL
    print_separator()
    print(f"â±ï¸  Deployment completed in {execution_time:.2f} seconds.")
    print(f"ðŸŒ Your Two Man Spades game is now live at:")
    print(f"  - https://{EXPECTED_PROJECT_ID}.appspot.com")
    print_separator()

# Main deployment function
def main_deploy():
    # CRITICAL: Verify project before doing ANYTHING
    check_gcloud_project()
    
    # Deploy the service
    deploy_service(SERVICE_NAME, 'app.yaml')
    
    # Automatically tail logs
    print(f"\nðŸ“‹ Tailing logs... (Press Ctrl+C to stop)")
    try:
        subprocess.run([
            "gcloud", "app", "logs", "tail",
            "--service", SERVICE_NAME,
            "--project", EXPECTED_PROJECT_ID  # Always specify project
        ])
    except KeyboardInterrupt:
        print("\n\nâ¹ï¸  Stopped tailing logs.")
        print(f"ðŸ“‹ You can view logs anytime with: gcloud app logs tail -s {SERVICE_NAME} --project {EXPECTED_PROJECT_ID}")

if __name__ == "__main__":
    print(f"ðŸ”’ You have chosen to keep {VERSION_MAX} versions of your app.")
    main_deploy()

================================================================================

FILE: ./test_postg.py
--------------------------------------------------------------------------------
# test_game_logging.py
from utilities.postgres_utils import insert_game, log_game_event_to_db
import time

# Test game data
test_game = {
    'game_id': f'test_{int(time.time())}',
    'game_started_at': time.time(),
    'player_parity': 'even',
    'computer_parity': 'odd',
    'first_leader': 'player',
    'client_info': {'ip_address': '127.0.0.1', 'user_agent': 'test'}
}

# Test inserting game
if insert_game(test_game):
    print("Game inserted successfully!")
    
    # Test logging an event
    if log_game_event_to_db(
        test_game['game_id'],
        'test_event',
        {'action': 'card_play', 'card': 'Aâ™ '},
        hand_number=1,
        session_sequence=1,
        player='player',
        action_type='card_play'
    ):
        print("Event logged successfully!")
    else:
        print("Event logging failed")
else:
    print("Game insertion failed")

================================================================================

FILE: ./app.py
--------------------------------------------------------------------------------
from flask import Flask, render_template, request, session, jsonify
import sys
import os
import time

# Add utilities directory to path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# Import all helper functions
from utilities.app_helpers import (
    check_content_filter, track_request_session, 
    initialize_new_game_session, process_new_game_request,
    build_safe_game_state, process_bidding_phase, process_blind_bid_phase,
    process_discard_phase, resolve_trick_with_delay,
    computer_follow_with_logging, computer_lead_with_logging,
    process_hand_completion, process_auto_resolution,
    start_development_server
)
from utilities.gameplay_logic import is_valid_play, init_new_hand
from utilities.logging_utils import log_action, log_game_event, get_client_ip, start_async_db_logging, IS_PRODUCTION

app = Flask(__name__)
app.secret_key = 'a-super-secret-key-change-this-or-dont-whatever-its-spades-man'


# Initialize async logging for production immediately when module loads
if IS_PRODUCTION:
    start_async_db_logging()
    print("[STARTUP] Async database logging initialized")

DEBUG_MODE = False
session_tracker = {}


@app.route('/debug_async_logging')
def debug_async_logging():
    """Debug endpoint to check async logging status"""
    from utilities.logging_utils import get_async_db_stats, IS_PRODUCTION
    
    stats = get_async_db_stats()
    
    return jsonify({
        'is_production': IS_PRODUCTION,
        'async_logging_enabled': IS_PRODUCTION,
        'worker_running': stats['worker_running'],
        'queue_size': stats['queue_size'],
        'operations_completed': stats['operations_completed'],
        'operations_failed': stats['operations_failed'],
        'queue_max_size': 1000
    })

@app.route('/')
def index():
    force_new = request.args.get('new', '').lower() == 'true'
    
    if force_new or 'game' not in session:
        session.clear()
        session['game'] = initialize_new_game_session(request)
    
    return render_template('index.html')

@app.route('/new_game', methods=['POST'])
def new_game():
    session['game'] = process_new_game_request(session, request)
    return jsonify({'success': True})

@app.route('/chat_response', methods=['POST'])
def chat_response():
    print("[CHAT] Received chat request")
    
    try:
        data = request.get_json()
        player_message = data.get('message', '')
        print(f"[CHAT] Player message: '{player_message}'")
        
        # Content filter check with working tinyurl filtering
        is_allowed, filter_message = check_content_filter(player_message)
        if not is_allowed:
            print(f"[CHAT] Message blocked by content filter")
            return jsonify({'response': filter_message})
        
        if 'game' in session:
            game_state = session['game']
            print(f"[CHAT] Game state found: Hand {game_state.get('hand_number', 1)}, Phase {game_state.get('phase', 'unknown')}")
            
            from utilities.claude_utils import get_smart_marta_response
            
            print("[CHAT] Calling Claude...")
            response = get_smart_marta_response(player_message, game_state)
            print(f"[CHAT] Final response: '{response}'")
            
            return jsonify({'response': response})
        else:
            print("[CHAT] No game session found")
            return jsonify({'response': 'Hi there! Start a game and let\'s chat!'})
            
    except Exception as e:
        print(f"[CHAT] Error: {e}")
        fallback_responses = [
            "That's interesting!",
            "I see what you mean...",
            "Good point!",
            "Let's focus on the game!",
            "Hmm, tell me more..."
        ]
        import random
        fallback = random.choice(fallback_responses)
        print(f"[CHAT] Using fallback: '{fallback}'")
        return jsonify({'response': fallback})

@app.route('/state')
def get_state():
    global session_tracker
    client_ip = get_client_ip(request)
    game_phase = session.get('game', {}).get('phase', 'no-game')
    
    session_tracker[client_ip] = {'last_seen': time.time(), 'phase': game_phase}
    
    cutoff = time.time() - 300
    active = {ip: data for ip, data in session_tracker.items() if data['last_seen'] > cutoff}
    session_tracker = active
    
    total_ips = len(active)
    print(f"ACTIVE: {total_ips} users | Current: {client_ip} ({game_phase})")
    if total_ips > 1:
        for ip, data in active.items():
            print(f"  {ip}: {data['phase']}")
    
    if 'game' not in session:
        session['game'] = initialize_new_game_session(request)
    
    game = session['game']
    safe_state = build_safe_game_state(game, DEBUG_MODE)
    
    return jsonify(safe_state)

@app.route('/toggle_computer_hand', methods=['POST'])
def toggle_computer_hand():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    if not DEBUG_MODE:
        return jsonify({'error': 'Debug mode disabled'}), 400
    
    game = session['game']
    game['show_computer_hand'] = not game.get('show_computer_hand', False)
    session.modified = True
    
    return jsonify({'success': True, 'showing': game['show_computer_hand']})

@app.route('/choose_blind_bidding', methods=['POST'])
def choose_blind_bidding():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    client_info = track_request_session(session, request)
    game = session['game']
    
    if game['phase'] != 'blind_decision':
        return jsonify({'error': 'Not in blind decision phase'}), 400
    
    log_action(
        action_type='blind_decision',
        player='player',
        action_data={'chose_blind': True, 'chose_normal': False},
        session=session,
        request=request
    )
    
    game['phase'] = 'blind_bidding'
    game['message'] = 'Choose your blind bid amount (5-10 tricks). Double points if you make it, double penalty if you fail!'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/choose_normal_bidding', methods=['POST'])
def choose_normal_bidding():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    client_info = track_request_session(session, request)
    game = session['game']
    
    if game['phase'] != 'blind_decision':
        return jsonify({'error': 'Not in blind decision phase'}), 400
    
    log_action(
        action_type='blind_decision',
        player='player',
        action_data={'chose_blind': False, 'chose_normal': True},
        session=session,
        request=request
    )
    
    game['phase'] = 'discard'
    game['message'] = 'You chose normal bidding. Select a card to discard.'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/blind_bid', methods=['POST'])
def make_blind_bid():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    client_info = track_request_session(session, request)
    game = session['game']
    data = request.get_json()
    bid = data.get('bid')
    
    if game['phase'] != 'blind_bidding':
        return jsonify({'error': 'Can only make blind bid during blind bidding phase'}), 400
    
    if bid < 5 or bid > 10:
        return jsonify({'error': 'Blind bid must be between 5 and 10'}), 400
    
    process_blind_bid_phase(game, session, bid, request)
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/choose_blind_nil', methods=['POST'])
def choose_blind_nil():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    game = session['game']
    if game['phase'] != 'blind_decision':
        return jsonify({'error': 'Not in blind decision phase'}), 400
    
    game['blind_bid'] = 0
    game['player_bid'] = 0
    game['blind_nil'] = True
    
    from utilities.computer_logic import computer_bidding_brain
    computer_bid, computer_is_blind = computer_bidding_brain(
        game['computer_hand'], 0, game
    )
    game['computer_bid'] = computer_bid
    if computer_is_blind:
        game['computer_blind_bid'] = computer_bid
    
    game['phase'] = 'discard'
    computer_text = f" Marta bid {computer_bid}{'(BLIND)' if computer_is_blind else ''}."
    game['message'] = f'BLIND NIL chosen! Win instantly with 0 tricks or lose the game!{computer_text} Select a card to discard.'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/bid', methods=['POST'])
def make_bid():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    client_info = track_request_session(session, request)
    game = session['game']
    data = request.get_json()
    bid = data.get('bid')
    
    if game['phase'] != 'bidding':
        return jsonify({'error': 'Not in bidding phase'}), 400
    
    if bid < 0 or bid > 10:
        return jsonify({'error': 'Bid must be between 0 and 10'}), 400
    
    process_bidding_phase(game, session, bid, request)
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/discard', methods=['POST'])
def discard_card():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    client_info = track_request_session(session, request)
    game = session['game']
    data = request.get_json()
    card_index = data.get('index')
    
    if game['phase'] != 'discard':
        return jsonify({'error': 'Not in discard phase'}), 400
    
    if card_index < 0 or card_index >= len(game['player_hand']):
        return jsonify({'error': 'Invalid card index'}), 400
    
    process_discard_phase(game, session, card_index, request)
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/play', methods=['POST'])
def play_card():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    client_info = track_request_session(session, request)
    game = session['game']
    data = request.get_json()
    card_index = data.get('index')
    
    if game['phase'] != 'playing':
        return jsonify({'error': 'Not in playing phase'}), 400
    
    if game['turn'] != 'player':
        return jsonify({'error': 'Not your turn'}), 400
    
    if card_index < 0 or card_index >= len(game['player_hand']):
        return jsonify({'error': 'Invalid card index'}), 400
    
    card = game['player_hand'][card_index]
    
    if not is_valid_play(card, game['player_hand'], game['current_trick'], game['spades_broken']):
        return jsonify({'error': 'Invalid play - must follow suit if possible'}), 400
    
    log_action(
        action_type='card_play',
        player='player', 
        action_data={
            'card_played': f"{card['rank']}{card['suit']}",
            'card_index': card_index,
            'trick_position': len(game['current_trick']) + 1,
            'leading': len(game['current_trick']) == 0
        },
        session=session,
        additional_context={
            'hand_size_before': len(game['player_hand']),
            'spades_broken_before': game['spades_broken']
        },
        request=request
    )
    
    game['player_hand'].pop(card_index)
    game['current_trick'].append({'player': 'player', 'card': card})
    
    if card['suit'] == 'â™ ':
        game['spades_broken'] = True
        log_game_event('spades_broken', {'broken_by': 'player', 'card': f"{card['rank']}{card['suit']}"}, session)
    
    if len(game['current_trick']) == 1:
        game['trick_leader'] = 'player'
        game['turn'] = 'computer'
        computer_follow_with_logging(game, session)
        resolve_trick_with_delay(game, session)
    elif len(game['current_trick']) == 2:
        resolve_trick_with_delay(game, session)
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/clear_trick', methods=['POST'])
def clear_trick():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    game = session['game']
    
    if not game.get('trick_completed'):
        return jsonify({'success': True, 'message': 'No trick to clear'}), 200
    
    winner = game.get('trick_winner')
    
    game['current_trick'] = []
    game['trick_completed'] = False
    game['trick_winner'] = None
    
    if len(game['player_hand']) == 0:
        game['hand_over'] = True
        process_hand_completion(game, session)
    elif len(game['player_hand']) > 0 and len(game['computer_hand']) > 0:
        auto_resolved = process_auto_resolution(game, session)
        
        if not auto_resolved:
            if winner == 'computer':
                computer_lead_with_logging(game, session)
                game['turn'] = 'player'
                game['message'] = 'Marta led. Your turn to follow.'
            else:
                game['turn'] = 'player'
                game['message'] = 'You won the trick! Your turn to lead.'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/next_hand', methods=['POST'])
def next_hand():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    client_info = track_request_session(session, request)
    game = session['game']
    
    if not game.get('hand_over', False) or game.get('game_over', False):
        return jsonify({'error': 'Cannot start next hand'}), 400
    
    log_game_event(
        event_type='new_hand_started',
        event_data={
            'previous_hand': game['hand_number'],
            'new_hand': game['hand_number'] + 1
        },
        session=session
    )
    
    game['hand_number'] += 1
    init_new_hand(game)
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/instructions')
def instructions():
    return render_template('instructions.html')

@app.route('/debug_game_creation')
def debug_game_creation():
    """Debug game creation issues"""
    if 'game' not in session:
        return jsonify({'error': 'No game in session'})
    
    game = session['game']
    game_id = game.get('game_id')
    
    # Try to create the game synchronously to see the error
    try:
        from utilities.postgres_utils import create_game_with_player, get_db_connection
        
        # First test database connection
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT 1")
        cur.close()
        conn.close()
        db_connection_ok = True
    except Exception as e:
        db_connection_ok = False
        db_error = str(e)
    
    # Try creating the game
    try:
        from utilities.postgres_utils import create_game_with_player
        creation_result = create_game_with_player(game, game.get('client_info'))
    except Exception as e:
        creation_result = f"Exception: {e}"
    
    return jsonify({
        'game_id': game_id,
        'game_started_at': game.get('game_started_at'),
        'client_info': game.get('client_info'),
        'db_connection_ok': db_connection_ok,
        'db_error': db_error if not db_connection_ok else None,
        'creation_result': creation_result,
        'is_production': IS_PRODUCTION
    })

if __name__ == '__main__':
    start_development_server(app)

================================================================================

FILE: ./gather_pythons.py
--------------------------------------------------------------------------------
import os
from datetime import datetime

# Configuration
# Set file types to include
FILE_EXTENSIONS = [
    '.py',    # Python files (always included)
    '.html',  # HTML files
    '.js',    # JavaScript files
    #'.css',   # CSS files
    '.json',  # JSON configuration files
]

# Flag to control directory depth
ONLY_ROOT_DIRECTORY = False  # Set to True to only search in root directory

# Filename patterns to exclude (new)
EXCLUDED_FILENAME_PATTERNS = [
    'copy',   # Any file with 'copy' in the name
    'backup', # Any file with 'backup' in the name
    'temp',   # Any file with 'temp' in the name
        'archives',   # Any file with 'temp' in the name
                '_full',   # Any file with '_full' in the name
]

# Directories to completely exclude from both scanning and output
EXCLUDED_DIRECTORIES = [
    "assets",
    "tests",
    "previous_versions",
    "projects",
    "tools",
    "revisions_app",
    "venv_de",
    ".git",
    "archives"

]

def gather_files(root_dir, excluded_directories, file_extensions, excluded_patterns, only_root=False):
    """
    Gathers files with specified extensions within the root directory and its subdirectories,
    excluding specified directories and filename patterns.

    Parameters:
        root_dir (str): The root directory to search for files.
        excluded_directories (list): List of directory names to exclude.
        file_extensions (list): List of file extensions to include.
        excluded_patterns (list): List of filename patterns to exclude.
        only_root (bool): If True, only search in the root directory (no subdirectories).

    Returns:
        tuple: (files_data, included_directories)
    """
    files_data = []
    included_directories = set()

    if only_root:
        # Only process files in the root directory
        relative_path = "."
        included_directories.add(relative_path)
        
        try:
            filenames = os.listdir(root_dir)
            for filename in filenames:
                file_path = os.path.join(root_dir, filename)
                
                # Skip directories
                if os.path.isdir(file_path):
                    continue
                
                # Skip files with excluded patterns in the filename
                if any(pattern.lower() in filename.lower() for pattern in excluded_patterns):
                    continue
                    
                # Only include files with the specified extensions
                if any(filename.endswith(ext) for ext in file_extensions):
                    try:
                        with open(file_path, 'r', encoding='utf-8') as file:
                            file_contents = file.read()
                        files_data.append((file_path, file_contents))
                    except UnicodeDecodeError:
                        print(f"Could not read file {file_path} due to encoding error. Skipping.")
                    except Exception as e:
                        print(f"Error with file {file_path}: {e}")
        except Exception as e:
            print(f"Error accessing root directory: {e}")
    else:
        # Original recursive behavior
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Get the relative path
            relative_path = os.path.relpath(dirpath, root_dir)
            
            # Skip excluded directories - check if any part of the path matches exclusion patterns
            should_exclude = False
            for excluded_dir in excluded_directories:
                # Check both exact match and path-based matches
                if excluded_dir == relative_path or excluded_dir in relative_path.replace('\\', '/'):
                    should_exclude = True
                    break
                    
            if should_exclude:
                continue

            # Add directory to our structure
            included_directories.add(relative_path)
            
            # Process files
            for filename in filenames:
                file_path = os.path.join(dirpath, filename)
                
                # Skip files with excluded patterns in the filename
                if any(pattern.lower() in filename.lower() for pattern in excluded_patterns):
                    continue
                    
                # Only include files with the specified extensions
                if any(filename.endswith(ext) for ext in file_extensions):
                    try:
                        with open(file_path, 'r', encoding='utf-8') as file:
                            file_contents = file.read()
                        files_data.append((file_path, file_contents))
                    except UnicodeDecodeError:
                        print(f"Could not read file {file_path} due to encoding error. Skipping.")
                    except Exception as e:
                        print(f"Error with file {file_path}: {e}")

    return files_data, sorted(included_directories)

def write_to_file(output_filepath, files_data, included_directories):
    """
    Writes the gathered data to a file with project information and file contents.
    """
    with open(output_filepath, 'w', encoding='utf-8') as file:
        # Write statistics
        file.write(f"Number of files: {len(files_data)}\n")
        file.write(f"Number of directories: {len(included_directories)}\n\n")
        
        # Write directory structure
        file.write("Directory structure:\n")
        for directory in included_directories:
            file.write(f"{directory}\n")
        file.write("\n")
        
        # Group and list files by extension
        extension_groups = {}
        for filepath, _ in files_data:
            ext = os.path.splitext(filepath)[1].lower()
            if ext not in extension_groups:
                extension_groups[ext] = []
            extension_groups[ext].append(filepath)
        
        file.write("List of file paths by type:\n")
        for ext, filepaths in sorted(extension_groups.items()):
            file.write(f"\n{ext.upper()[1:]} Files ({len(filepaths)}):\n")
            for filepath in sorted(filepaths):
                file.write(f"  {filepath}\n")
        file.write("\n")
        
        # Write file contents
        file.write("="*80 + "\n")
        file.write("FILE CONTENTS\n")
        file.write("="*80 + "\n\n")
        
        for filepath, file_contents in files_data:
            file.write(f"FILE: {filepath}\n")
            file.write("-"*80 + "\n")
            file.write(f"{file_contents}\n\n")
            file.write("="*80 + "\n\n")

def scan_project_structure():
    """
    Main function to scan the project structure and write the results to a file.
    """
    root_dir = "."  # Current directory
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_filepath = f"{timestamp}_project_structure.txt"
    
    print(f"Starting to scan project structure at {root_dir}...")
    print(f"Including file types: {', '.join(FILE_EXTENSIONS)}")
    print(f"Excluding file patterns: {', '.join(EXCLUDED_FILENAME_PATTERNS)}")
    
    if ONLY_ROOT_DIRECTORY:
        print("Scanning ONLY root directory (subdirectories will be skipped)")
    else:
        print(f"Excluding directories: {', '.join(EXCLUDED_DIRECTORIES)}")
    
    # Gather files and directory information
    files_data, included_directories = gather_files(
        root_dir, 
        EXCLUDED_DIRECTORIES, 
        FILE_EXTENSIONS,
        EXCLUDED_FILENAME_PATTERNS,
        only_root=ONLY_ROOT_DIRECTORY
    )
    
    print(f"Found {len(files_data)} files across {len(included_directories)} directories.")
    if not ONLY_ROOT_DIRECTORY:
        print(f"Excluded directories won't appear in the output file.")
    
    # Write the output file
    write_to_file(
        output_filepath, 
        files_data, 
        included_directories
    )
    
    print(f"Project structure has been written to {output_filepath}")
    print(f"File size: {os.path.getsize(output_filepath) / (1024*1024):.2f} MB")

if __name__ == "__main__":
    scan_project_structure()

================================================================================

FILE: ./utilities/postgres_utils.py
--------------------------------------------------------------------------------
"""
Two-Man Spades PostgreSQL Utilities - Updated for Hands Table
"""
import psycopg2
import psycopg2.extras
import json
import os
from datetime import datetime
from google.cloud import secretmanager
from typing import Dict, Any, Optional, List

def get_secret(secret_id: str, project_id: str = "kumori-404602") -> str:
    """Get secret from Google Secret Manager"""
    client = secretmanager.SecretManagerServiceClient()
    name = f"projects/{project_id}/secrets/{secret_id}/versions/latest"
    response = client.access_secret_version(request={"name": name})
    return response.payload.data.decode('UTF-8')

def get_db_connection():
    """Create database connection using TWOMANSPADES secrets"""
    is_gcp = os.environ.get('GAE_ENV', '').startswith('standard')
    
    if is_gcp:
        # Production - use secrets and Cloud SQL socket
        connection_name = get_secret('TWOMANSPADES_POSTGRES_CONNECTION_NAME')
        host = f"/cloudsql/{connection_name}"
        dbname = get_secret('TWOMANSPADES_POSTGRES_DB_NAME') 
        user = get_secret('TWOMANSPADES_POSTGRES_USERNAME')
        password = get_secret('TWOMANSPADES_POSTGRES_PASSWORD')
    else:
        # Local development - use environment variables or direct secrets
        try:
            # Try secrets first (in case you want to test with real DB locally)
            host = get_secret('TWOMANSPADES_POSTGRES_IP')
            dbname = get_secret('TWOMANSPADES_POSTGRES_DB_NAME')
            user = get_secret('TWOMANSPADES_POSTGRES_USERNAME')
            password = get_secret('TWOMANSPADES_POSTGRES_PASSWORD')
        except:
            # Fallback to env vars for local dev
            host = os.getenv('DB_HOST', 'localhost')
            dbname = os.getenv('DB_NAME', 'twomanspades_dev')
            user = os.getenv('DB_USER', 'postgres') 
            password = os.getenv('DB_PASSWORD', 'password')
    
    return psycopg2.connect(
        host=host,
        database=dbname,
        user=user,
        password=password,
        connect_timeout=10
    )

def test_connection():
    """Test database connection"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT version();")
        version = cur.fetchone()
        print(f"âœ… PostgreSQL connection successful: {version[0]}")
        cur.close()
        conn.close()
        return True
    except Exception as e:
        print(f"âŒ Database connection failed: {e}")
        return False

def insert_hand(hand_data: Dict[str, Any]) -> bool:
    """Insert new hand record"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        # Debug: print what we're trying to insert
        print(f"Attempting to insert hand: {hand_data.get('hand_id')}")
        
        cur.execute("""
            INSERT INTO twomanspades.hands 
            (hand_id, started_at, player_parity, computer_parity, first_leader, client_ip, user_agent)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, (
            hand_data['hand_id'],
            datetime.fromtimestamp(hand_data['game_started_at']),  # Still using game_started_at from session
            hand_data['player_parity'],
            hand_data['computer_parity'], 
            hand_data['first_leader'],
            hand_data.get('client_info', {}).get('ip_address'),
            hand_data.get('client_info', {}).get('user_agent')
        ))
        
        conn.commit()
        cur.close()
        conn.close()
        print(f"âœ… Hand {hand_data.get('hand_id')} successfully inserted")
        return True
    except Exception as e:
        print(f"âŒ Failed to insert hand {hand_data.get('hand_id')}: {e}")
        # Try to close connection if it exists
        try:
            if 'conn' in locals():
                conn.close()
        except:
            pass
        return False

def log_game_event_to_db(hand_id: str, event_type: str, event_data: Dict, **kwargs) -> bool:
    """Log game event to database (still uses hand_id now)"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        cur.execute("""
            INSERT INTO twomanspades.game_events 
            (game_id, event_type, event_data, hand_number, session_sequence, player, action_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, (
            hand_id,  # Now using hand_id
            event_type,
            json.dumps(event_data),
            kwargs.get('hand_number'),
            kwargs.get('session_sequence'),
            kwargs.get('player'),
            kwargs.get('action_type')
        ))
        
        conn.commit()
        cur.close()
        conn.close()
        return True
    except Exception as e:
        print(f"Failed to log event: {e}")
        return False

def finalize_hand(hand_id: str, final_data: Dict[str, Any]) -> bool:
    """Update hand record when hand completes"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        cur.execute("""
            UPDATE twomanspades.hands 
            SET completed_at = %s,
                hand_player_score = %s,
                hand_computer_score = %s,
                player_bags = %s,
                computer_bags = %s
            WHERE hand_id = %s
        """, (
            datetime.now(),
            final_data.get('player_score', 0),
            final_data.get('computer_score', 0),
            final_data.get('player_bags', 0),
            final_data.get('computer_bags', 0),
            hand_id
        ))
        
        conn.commit()
        cur.close()
        conn.close()
        return True
    except Exception as e:
        print(f"Failed to finalize hand: {e}")
        return False

def upsert_player(ip_address: str, user_agent: str = None) -> Optional[int]:
    """Create or update player record, return player_id"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        cur.execute("""
            INSERT INTO twomanspades.players (ip_address, user_agent_latest, total_games)
            VALUES (%s, %s, 0)
            ON CONFLICT (ip_address) DO UPDATE SET
                last_seen = NOW(),
                user_agent_latest = COALESCE(EXCLUDED.user_agent_latest, players.user_agent_latest)
            RETURNING player_id
        """, (ip_address, user_agent))
        
        player_id = cur.fetchone()[0]
        conn.commit()
        cur.close()
        conn.close()
        return player_id
    except Exception as e:
        print(f"Failed to upsert player: {e}")
        return None

def batch_log_events(hand_id: str, events: List[Dict]) -> bool:
    """Log multiple events in a single database transaction"""
    if not events:
        return True
    
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        events_data = []
        for event in events:
            events_data.append((
                hand_id,  # Now using hand_id
                event.get('event_type'),
                json.dumps(event.get('event_data', {})),
                event.get('hand_number'),
                event.get('session_sequence'),
                event.get('player'),
                event.get('action_type')
            ))
        
        cur.executemany("""
            INSERT INTO twomanspades.game_events 
            (game_id, event_type, event_data, hand_number, session_sequence, player, action_type)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, events_data)
        
        conn.commit()
        cur.close()
        conn.close()
        return True
    except Exception as e:
        print(f"Batch event logging failed: {e}")
        try:
            if 'conn' in locals():
                conn.rollback()
                conn.close()
        except:
            pass
        return False

def create_hand_with_player(hand_data: Dict[str, Any], client_info: Dict[str, Any] = None) -> bool:
    """Create hand and update player in single transaction"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        player_id = None
        if client_info:
            ip_address = client_info.get('ip_address')
            user_agent = client_info.get('user_agent')
            
            # Update player stats - increment total_hands instead of total_games
            cur.execute("""
                INSERT INTO twomanspades.players (ip_address, user_agent_latest, total_hands)
                VALUES (%s, %s, 1)
                ON CONFLICT (ip_address) DO UPDATE SET
                    last_seen = NOW(),
                    user_agent_latest = EXCLUDED.user_agent_latest,
                    total_hands = players.total_hands + 1
                RETURNING player_id
            """, (ip_address, user_agent))
            
            player_id = cur.fetchone()[0]
        
        # Insert hand record
        cur.execute("""
            INSERT INTO twomanspades.hands 
            (hand_id, started_at, player_parity, computer_parity, first_leader, 
             client_ip, user_agent, player_id)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            hand_data['game_id'],  # Using game_id as hand_id for now
            datetime.fromtimestamp(hand_data['game_started_at']),
            hand_data['player_parity'],
            hand_data['computer_parity'], 
            hand_data['first_leader'],
            client_info.get('ip_address') if client_info else None,
            client_info.get('user_agent') if client_info else None,
            player_id
        ))
        
        conn.commit()
        cur.close()
        conn.close()
        return True
    except Exception as e:
        print(f"Failed to create hand with player: {e}")
        try:
            if 'conn' in locals():
                conn.rollback()
                conn.close()
        except:
            pass
        return False

# Legacy function names for backward compatibility
def insert_game(game_data: Dict[str, Any]) -> bool:
    """Legacy wrapper - use insert_hand instead"""
    return insert_hand(game_data)

def finalize_game(game_id: str, final_data: Dict[str, Any]) -> bool:
    """Legacy wrapper - use finalize_hand instead"""
    return finalize_hand(game_id, final_data)

def create_game_with_player(game_data: Dict[str, Any], client_info: Dict[str, Any] = None) -> bool:
    """Legacy wrapper - use create_hand_with_player instead"""
    return create_hand_with_player(game_data, client_info)

================================================================================

FILE: ./utilities/gameplay_logic.py
--------------------------------------------------------------------------------
import random

def create_deck():
    """Create a standard 52-card deck"""
    suits = ['â™ ', 'â™¥', 'â™¦', 'â™£']
    ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
    deck = []
    for suit in suits:
        for rank in ranks:
            deck.append({'rank': rank, 'suit': suit, 'value': get_card_value(rank)})
    return deck

def get_card_value(rank):
    """Get numerical value of a card rank"""
    if rank == 'A':
        return 14
    elif rank == 'K':
        return 13
    elif rank == 'Q':
        return 12
    elif rank == 'J':
        return 11
    else:
        return int(rank)

def sort_hand(hand):
    """Sort hand by suit (clubs, diamonds, hearts, spades) then by value"""
    suit_order = {'â™£': 0, 'â™¦': 1, 'â™¥': 2, 'â™ ': 3}
    return sorted(hand, key=lambda x: (suit_order[x['suit']], x['value']))

def init_game(player_parity='even', computer_parity='odd', first_leader='player'):
    """Initialize a new game"""
    deck = create_deck()
    random.shuffle(deck)
    
    game = {
        'player_hand': sort_hand(deck[:11]),
        'computer_hand': sort_hand(deck[11:22]),
        'current_trick': [],
        'player_tricks': 0,
        'computer_tricks': 0,
        'spades_broken': False,
        'phase': 'discard',
        'turn': 'player',  # Both players can discard simultaneously
        'trick_leader': None,
        'hand_over': False,
        'game_over': False,
        'winner': None,
        'message': 'Select a card to discard',
        'player_discarded': None,
        'computer_discarded': None,
        'show_computer_hand': False,
        'trick_display_timer': None,
        'player_bid': None,
        'computer_bid': None,
        'total_tricks': 10,
        'player_score': 0,
        'computer_score': 0,
        'player_bags': 0,
        'computer_bags': 0,
        'player_trick_special_cards': 0,
        'computer_trick_special_cards': 0,
        'hand_number': 1,
        'target_score': 300,
        'player_parity': player_parity,
        'computer_parity': computer_parity,
        'first_leader': first_leader,  # Who leads the first trick of each hand
        'discard_bonus_explanation': None,
        'pending_discard_result': None,
        'pending_special_discard_result': None,
        'blind_bidding_available': False,
        'blind_bid': None,
        'computer_blind_bid': None,
        'blind_multiplier': 2,
        'trick_history': []  # Track all tricks played this hand
    }
    
    # Log initial hands dealt for first hand
    from .logging_utils import log_game_event
    
    # Log player's starting hand
    player_hand_cards = [f"{card['rank']}{card['suit']}" for card in game['player_hand']]
    log_game_event(
        event_type='hand_dealt',
        event_data={
            'hand_number': game['hand_number'],
            'player': 'player',
            'cards': player_hand_cards,
            'card_count': len(player_hand_cards)
        },
        session={'game': game}
    )
    
    # Log computer's starting hand
    computer_hand_cards = [f"{card['rank']}{card['suit']}" for card in game['computer_hand']]
    log_game_event(
        event_type='hand_dealt',
        event_data={
            'hand_number': game['hand_number'],
            'player': 'computer',
            'cards': computer_hand_cards,
            'card_count': len(computer_hand_cards)
        },
        session={'game': game}
    )
    
    return game

def init_new_hand(game):
    """Start a new hand while preserving scores, bags, and parity assignments"""
    deck = create_deck()
    random.shuffle(deck)
    
    # Alternate who leads the first trick each hand
    current_first_leader = game.get('first_leader', 'player')
    next_first_leader = 'computer' if current_first_leader == 'player' else 'player'
    
    # Check blind bidding eligibility using display scores (what players actually see)
    player_base_score = game.get('player_score', 0)
    computer_base_score = game.get('computer_score', 0)
    player_bags = game.get('player_bags', 0)
    computer_bags = game.get('computer_bags', 0)
    
    # Calculate display scores for eligibility check
    def calc_display_score(base_score, bags):
        if bags >= 0:
            if base_score < 0:
                tens_and_higher = (base_score // 10) * 10
                return tens_and_higher - bags
            else:
                tens_and_higher = (base_score // 10) * 10
                return tens_and_higher + bags
        else:
            return base_score
    
    player_display_score = calc_display_score(player_base_score, player_bags)
    computer_display_score = calc_display_score(computer_base_score, computer_bags)
    
    # Check eligibility based on display scores
    from .custom_rules import check_blind_bidding_eligibility
    blind_eligibility = check_blind_bidding_eligibility(player_display_score, computer_display_score)
    
    # Set initial phase and message based on blind eligibility
    if blind_eligibility['player_eligible']:
        initial_phase = 'blind_decision'
        deficit = computer_display_score - player_display_score
        initial_message = f'You are down by {deficit} points. Choose: Go BLIND for double points/penalties, or bid normally?'
    else:
        initial_phase = 'discard'
        initial_message = f'Hand #{game["hand_number"]} - Select a card to discard'
    
    game.update({
        'player_hand': sort_hand(deck[:11]),
        'computer_hand': sort_hand(deck[11:22]),
        'current_trick': [],
        'player_tricks': 0,
        'computer_tricks': 0,
        'spades_broken': False,
        'phase': initial_phase,
        'turn': 'player',
        'trick_leader': None,
        'hand_over': False,
        'message': initial_message,
        'player_discarded': None,
        'computer_discarded': None,
        'show_computer_hand': False,
        'trick_display_timer': None,
        'player_bid': None,
        'computer_bid': None,
        'total_tricks': 10,
        'discard_bonus_explanation': None,
        'player_trick_special_cards': 0,
        'computer_trick_special_cards': 0,
        'pending_discard_result': None,
        'pending_special_discard_result': None,
        'blind_bidding_available': blind_eligibility['player_eligible'],
        'blind_bid': None,
        'computer_blind_bid': None,
        'first_leader': next_first_leader,
        'trick_history': []
    })
    
    # NEW: Log starting hands for this new hand
    from .logging_utils import log_game_event
    
    # Log player's starting hand
    player_hand_cards = [f"{card['rank']}{card['suit']}" for card in game['player_hand']]
    log_game_event(
        event_type='hand_dealt',
        event_data={
            'hand_number': game['hand_number'],
            'player': 'player',
            'cards': player_hand_cards,
            'card_count': len(player_hand_cards)
        },
        session={'game': game}
    )
    
    # Log computer's starting hand
    computer_hand_cards = [f"{card['rank']}{card['suit']}" for card in game['computer_hand']]
    log_game_event(
        event_type='hand_dealt',
        event_data={
            'hand_number': game['hand_number'],
            'player': 'computer',
            'cards': computer_hand_cards,
            'card_count': len(computer_hand_cards)
        },
        session={'game': game}
    )

def computer_bidding_brain(computer_hand, player_bid, game_state=None):
    """
    Computer bidding function - now delegates to computer_logic module
    """
    if game_state is None:
        # Fallback for backward compatibility
        game_state = {'player_score': 0, 'computer_score': 0, 'computer_bags': 0}
    
    from .computer_logic import computer_bidding_brain as enhanced_brain
    return enhanced_brain(computer_hand, player_bid, game_state)

def computer_discard_strategy(computer_hand, game_state=None):
    """
    Computer discard strategy - now delegates to computer_logic module
    """
    if game_state is None:
        # Fallback to simple strategy for backward compatibility
        computer_discards = []
        for i, card in enumerate(computer_hand):
            if card['suit'] != 'â™ ':
                computer_discards.append((i, card['value']))
        
        if computer_discards:
            return min(computer_discards, key=lambda x: x[1])[0]
        else:
            return 0
    
    from .computer_logic import computer_discard_strategy as enhanced_discard
    return enhanced_discard(computer_hand, game_state)

def is_valid_play(card, hand, trick, spades_broken):
    """Check if a card play is valid according to Spades rules"""
    if len(trick) == 0:
        # Leading
        if card['suit'] == 'â™ ' and not spades_broken:
            # Can only lead spades if no other suits
            for c in hand:
                if c['suit'] != 'â™ ':
                    return False
        return True
    else:
        # Following
        lead_suit = trick[0]['card']['suit']
        # Must follow suit if possible
        has_suit = any(c['suit'] == lead_suit for c in hand)
        if has_suit:
            return card['suit'] == lead_suit
        return True

def determine_trick_winner(trick):
    """
    Determine who won a completed trick
    Returns the player who won ('player' or 'computer')
    """
    if len(trick) != 2:
        return None
    
    first = trick[0]
    second = trick[1]
    
    if first['card']['suit'] == second['card']['suit']:
        # Same suit, higher value wins
        if first['card']['value'] > second['card']['value']:
            return first['player']
        else:
            return second['player']
    elif first['card']['suit'] == 'â™ ':
        # First player trumped
        return first['player']
    elif second['card']['suit'] == 'â™ ':
        # Second player trumped  
        return second['player']
    else:
        # Different suits, no trump - first player (leader) wins
        return first['player']

def resolve_trick_with_delay(game):
    """Resolve trick and set it up to be displayed for 3 seconds"""
    if len(game['current_trick']) != 2:
        return
    
    winner = determine_trick_winner(game['current_trick'])
    
    # SAVE TRICK TO HISTORY BEFORE PROCESSING
    trick_number = len(game.get('trick_history', [])) + 1
    player_card = next((play['card'] for play in game['current_trick'] if play['player'] == 'player'), None)
    computer_card = next((play['card'] for play in game['current_trick'] if play['player'] == 'computer'), None)
    
    game.setdefault('trick_history', []).append({
        'number': trick_number,
        'player_card': player_card,
        'computer_card': computer_card,
        'winner': winner
    })
    
    # LOG EACH TRICK TO CONSOLE
    p_text = f"{player_card['rank']}{player_card['suit']}" if player_card else "?"
    c_text = f"{computer_card['rank']}{computer_card['suit']}" if computer_card else "?"
    winner_name = "You" if winner == 'player' else "Marta"
    print(f"TRICK {trick_number}: {p_text} vs {c_text} -> {winner_name} wins")
    
    
    # Check for special cards in the trick and apply bag reduction IMMEDIATELY
    from utilities.custom_rules import check_special_cards_in_trick, reduce_bags_safely
    special_result = check_special_cards_in_trick(game['current_trick'], winner)
    
    if special_result['bag_reduction'] > 0:
        if winner == 'player':
            current_bags = game.get('player_bags', 0)
            game['player_bags'] = reduce_bags_safely(current_bags, special_result['bag_reduction'])
            game['player_trick_special_cards'] = game.get('player_trick_special_cards', 0) + special_result['bag_reduction']
        else:
            current_bags = game.get('computer_bags', 0)
            game['computer_bags'] = reduce_bags_safely(current_bags, special_result['bag_reduction'])
            game['computer_trick_special_cards'] = game.get('computer_trick_special_cards', 0) + special_result['bag_reduction']
        
        game['special_card_message'] = special_result['explanation']
    
    # Award trick
    if winner == 'player':
        game['player_tricks'] += 1
        base_message = 'You won the trick!'
    else:
        game['computer_tricks'] += 1
        base_message = 'Marta won the trick!'
    
    # Add special card info to message if present
    if special_result['explanation']:
        game['message'] = f"{base_message} {special_result['explanation']} Cards will clear in 3 seconds..."
    else:
        game['message'] = f"{base_message} Cards will clear in 3 seconds..."
    
    # Mark trick as completed but don't clear yet
    game['trick_completed'] = True
    game['trick_winner'] = winner

def computer_follow(game):
    """Computer plays a card when following - now uses bag avoidance strategy"""
    hand = game['computer_hand']
    trick = game['current_trick']
    
    if not trick or not hand:
        return
    
    # Use enhanced following strategy from computer_logic
    from .computer_logic import computer_follow_strategy
    chosen_idx = computer_follow_strategy(hand, trick, game)
    
    if chosen_idx is None:
        # Fallback to original simple logic if strategy fails
        lead_card = trick[0]['card']
        lead_suit = lead_card['suit']
        lead_value = lead_card['value']
        
        # Find valid plays
        same_suit = [(i, c) for i, c in enumerate(hand) if c['suit'] == lead_suit]
        spades = [(i, c) for i, c in enumerate(hand) if c['suit'] == 'â™ ']
        
        if same_suit:
            # Must follow suit - try to win with lowest winning card
            winners = [(i, c) for i, c in same_suit if c['value'] > lead_value]
            if winners:
                chosen_idx = min(winners, key=lambda x: x[1]['value'])[0]
            else:
                # Can't win, play lowest
                chosen_idx = min(same_suit, key=lambda x: x[1]['value'])[0]
        elif lead_suit != 'â™ ' and spades:
            # Can't follow suit, can trump with spade
            chosen_idx = min(spades, key=lambda x: x[1]['value'])[0]
        else:
            # Can't follow or trump, discard lowest
            all_cards = [(i, c) for i, c in enumerate(hand)]
            chosen_idx = min(all_cards, key=lambda x: x[1]['value'])[0]
    
    # Play the chosen card
    card = hand.pop(chosen_idx)
    game['current_trick'].append({'player': 'computer', 'card': card})
    
    if card['suit'] == 'â™ ':
        game['spades_broken'] = True

def computer_lead(game):
    """Computer plays a card when leading - now uses enhanced strategy"""
    hand = game['computer_hand']
    
    if not hand:
        return
    
    # Use enhanced leading strategy from computer_logic
    from .computer_logic import computer_lead_strategy
    chosen_idx = computer_lead_strategy(hand, game['spades_broken'], game)

    
    if chosen_idx is None:
        # Fallback to original simple logic if strategy fails
        valid = []
        for i, card in enumerate(hand):
            if card['suit'] != 'â™ ' or game['spades_broken'] or all(c['suit'] == 'â™ ' for c in hand):
                valid.append((i, card))
        
        if valid:
            chosen = min(valid, key=lambda x: (x[1]['suit'] == 'â™ ', x[1]['value']))
            chosen_idx = chosen[0]
        else:
            return
    
    # Play the chosen card
    card = hand.pop(chosen_idx)
    game['current_trick'] = [{'player': 'computer', 'card': card}]
    game['trick_leader'] = 'computer'
    
    if card['suit'] == 'â™ ':
        game['spades_broken'] = True


def check_game_over(game):
    """
    Check if the game is over (someone reached target score OR down by 300+ points)
    Updates game state with winner information if game is over
    
    SIMPLE RULE: Higher display score ALWAYS wins!
    - 302 beats 300 (regardless of bags)
    - 301 beats 300 (regardless of bags)
    - Bags only matter as tie-breaker when display scores are EXACTLY tied
    - More bags (further from 0) is always worse, whether positive or negative
    """
    player_base_score = game['player_score']
    computer_base_score = game['computer_score']
    player_bags = game.get('player_bags', 0)
    computer_bags = game.get('computer_bags', 0)
    target_score = game['target_score']
    
    # Calculate display scores inline (no import needed)
    def calc_display_score(base_score, bags):
        if bags >= 0:
            if base_score < 0:
                tens_and_higher = (base_score // 10) * 10
                return tens_and_higher - bags
            else:
                tens_and_higher = (base_score // 10) * 10
                return tens_and_higher + bags
        else:
            return base_score
    
    player_display_score = calc_display_score(player_base_score, player_bags)
    computer_display_score = calc_display_score(computer_base_score, computer_bags)
    
    # Check for 300-point deficit rule (mercy rule) using display scores
    if player_display_score - computer_display_score >= 300:
        game['game_over'] = True
        game['winner'] = 'player'
        game['message'] = f"GAME OVER! You WIN by mercy rule {player_display_score} to {computer_display_score}! (300+ point lead)"
        return True
    elif computer_display_score - player_display_score >= 300:
        game['game_over'] = True
        game['winner'] = 'computer'
        game['message'] = f"GAME OVER! Marta WINS by mercy rule {computer_display_score} to {player_display_score}! (300+ point lead)"
        return True
    
    # Check for regular target score (300 points) using display scores
    if player_display_score >= target_score or computer_display_score >= target_score:
        game['game_over'] = True
        
        # SIMPLE: Higher display score wins. Period.
        if player_display_score > computer_display_score:
            game['winner'] = 'player'
            game['message'] = f"GAME OVER! You WIN {player_display_score} to {computer_display_score}!"
        elif computer_display_score > player_display_score:
            game['winner'] = 'computer'
            game['message'] = f"GAME OVER! Marta WINS {computer_display_score} to {player_display_score}!"
        else:
            # Display scores are EXACTLY tied (e.g., both 300)
            # Only NOW do we look at tie-breakers
            
            # First tie-breaker: Higher base score
            if player_base_score > computer_base_score:
                game['winner'] = 'player'
                game['message'] = f"GAME OVER! You WIN {player_display_score} to {computer_display_score} (higher base score tie-breaker)!"
            elif computer_base_score > player_base_score:
                game['winner'] = 'computer'
                game['message'] = f"GAME OVER! Marta WINS {computer_display_score} to {player_display_score} (higher base score tie-breaker)!"
            else:
                # Second tie-breaker: Fewer bags (closer to 0 is better)
                # Convert to absolute values to compare distance from 0
                player_bag_distance = abs(player_bags)
                computer_bag_distance = abs(computer_bags)
                
                if player_bag_distance < computer_bag_distance:
                    # Player has fewer bags (closer to 0)
                    game['winner'] = 'player'
                    game['message'] = f"GAME OVER! You WIN {player_display_score} to {computer_display_score} (fewer bags: {player_bags} vs {computer_bags})!"
                elif computer_bag_distance < player_bag_distance:
                    # Computer has fewer bags (closer to 0)
                    game['winner'] = 'computer'
                    game['message'] = f"GAME OVER! Marta WINS {computer_display_score} to {player_display_score} (fewer bags: {computer_bags} vs {player_bags})!"
                else:
                    # Absolute tie - same everything
                    game['winner'] = 'tie'
                    game['message'] = f"GAME OVER! ABSOLUTE TIE at {player_display_score} points each!"
        
        return True
    
    return False

================================================================================

FILE: ./utilities/app_helpers.py
--------------------------------------------------------------------------------
"""
App helper functions for Two-Man Spades
Contains all non-routing logic moved from app.py
"""
from flask import session
import time
from .logging_utils import log_action, log_game_event, track_session_client, get_client_ip
from .custom_rules import (
    check_special_cards_in_trick, reduce_bags_safely, assign_even_odd_at_game_start,
    calculate_discard_score_with_winner, calculate_hand_scores_with_bags, 
    get_player_names_with_parity, check_special_cards_in_discard,
    check_blind_bidding_eligibility
)
from .gameplay_logic import determine_trick_winner, init_game, init_new_hand, check_game_over
from .computer_logic import (
    computer_follow_strategy, computer_lead_strategy, computer_bidding_brain,
    computer_discard_strategy, autoplay_remaining_cards
)
from .logging_utils import initialize_game_logging_with_client, finalize_game_logging, flush_hand_events


# Flush batched events to database  
from .logging_utils import flush_hand_events


# =============================================================================
# CONTENT FILTERING
# =============================================================================

def get_blocked_words():
    """Get blocked words from tinyurl"""
    import requests
    
    try:
        url = "https://tinyurl.com/35wba3d6"
        response = requests.get(url, timeout=5)
        if response.status_code == 200:
            return [word.strip() for word in response.text.split('\n') if word.strip()]
    except:
        pass
    
    # Fallback minimal list if tinyurl fails
    return ['placeholder1', 'placeholder2']

def check_content_filter(message):
    """Check if message contains disallowed content"""
    try:
        blocked_phrases = get_blocked_words()
        
        message_lower = message.lower()
        for phrase in blocked_phrases:
            if phrase.lower() in message_lower:
                print(f"[FILTER] BLOCKED message containing '{phrase}': '{message[:50]}{'...' if len(message) > 50 else ''}'")
                return False, "Hey, watch the language! Let's keep it PG-13 here - I've got a reputation to maintain!"
        
        return True, None
    except Exception as e:
        print(f"[FILTER] Error checking content filter: {e}")
        return True, None

# =============================================================================
# DEVELOPMENT SERVER UTILITIES
# =============================================================================

def start_development_server(app):
    """Start development server with port management and browser opening (macOS optimized)"""
    import subprocess
    import webbrowser
    import time
    import socket
    import os
    from threading import Thread
    
    def kill_process_on_port(port):
        try:
            result = subprocess.run(['lsof', '-ti:' + str(port)], capture_output=True, text=True)
            if result.stdout.strip():
                pids = result.stdout.strip().split('\n')
                for pid in pids:
                    if pid.strip():
                        subprocess.run(['kill', '-9', pid.strip()], capture_output=True)
                        print(f"Killed process {pid.strip()} on port {port}")
                time.sleep(1)
                return True
        except Exception as e:
            print(f"Could not kill processes on port {port}: {e}")
        return False
    
    def is_port_available(port):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        result = sock.connect_ex(('localhost', port))
        sock.close()
        return result != 0
    
    def find_available_port(start_port=5000, max_attempts=10):
        for port in range(start_port, start_port + max_attempts):
            if is_port_available(port):
                print(f"Port {port} is available")
                return port
            else:
                print(f"Port {port} is in use, attempting to kill process...")
                if kill_process_on_port(port):
                    time.sleep(0.5)
                    if is_port_available(port):
                        print(f"Successfully freed port {port}")
                        return port
                    else:
                        print(f"Port {port} still in use after kill attempt")
                else:
                    print(f"Could not kill process on port {port}")
        
        raise RuntimeError(f"Could not find an available port in range {start_port}-{start_port + max_attempts - 1}")
    
    def open_browser(port):
        time.sleep(1.5)
        url = f'http://localhost:{port}'
        
        # macOS Chrome path
        chrome_path = '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'
        
        opened = False
        if os.path.exists(chrome_path):
            try:
                subprocess.Popen([chrome_path, url])
                print(f"Opened Chrome at {url}")
                opened = True
            except:
                pass
        
        if not opened:
            webbrowser.open(url)
            print(f"Opened default browser at {url}")
    
    # Find and secure a port
    try:
        port = find_available_port(5000, 10)
    except RuntimeError as e:
        print(f"Error: {e}")
        print("Please manually kill processes or restart your computer")
        exit(1)
    
    # Start browser opening in a separate thread
    browser_thread = Thread(target=lambda: open_browser(port))
    browser_thread.daemon = True
    browser_thread.start()
    
    print(f"Starting Flask app on port {port}...")
    print(f"The browser should open automatically in a moment...")
    print(f"If not, navigate to http://localhost:{port}")
    
    # Run Flask app
    app.run(debug=True, port=port, use_reloader=False)

# =============================================================================
# SCORE DISPLAY FUNCTIONS
# =============================================================================

def get_display_score(base_score, bags):
    """Convert base score and bags to display score (bags in ones column)"""
    if bags >= 0:
        if base_score < 0:
            tens_and_higher = (base_score // 10) * 10
            return tens_and_higher - bags
        else:
            tens_and_higher = (base_score // 10) * 10
            return tens_and_higher + bags
    else:
        return base_score

def get_base_score_from_display(display_score, bags):
    """Convert display score back to base score (removing bags from ones column)"""
    return display_score - bags

# =============================================================================
# SESSION TRACKING
# =============================================================================

def track_request_session(session, request):
    """Track client session for this request"""
    if 'game' in session:
        return track_session_client(session, request)
    return None

# =============================================================================
# GAME INITIALIZATION
# =============================================================================

def initialize_new_game_session(request):
    """Initialize a new game session with logging"""
    player_parity, computer_parity, first_player = assign_even_odd_at_game_start()
    game = init_game(player_parity, computer_parity, first_player)
    game = initialize_game_logging_with_client(game, request)
    return game

def process_new_game_request(session, request):
    """Process new game request with logging cleanup"""
    client_info = track_request_session(session, request)
    
    if 'game' in session:
        finalize_game_logging(session['game'])
    
    game = initialize_new_game_session(request)
    
    log_game_event(
        event_type='new_game_started',
        event_data={
            'player_parity': game.get('player_parity'),
            'computer_parity': game.get('computer_parity'),
            'first_leader': game.get('first_leader')
        },
        session={'game': game}
    )
    
    return game

# =============================================================================
# GAME STATE BUILDING
# =============================================================================

def build_safe_game_state(game, debug_mode=False):
    """Build safe game state for frontend"""
    player_name, computer_name = get_player_names_with_parity(
        game.get('player_parity', 'even'),
        game.get('computer_parity', 'odd')
    )
    
    show_discard_explanation = game.get('hand_over', False)
    discard_explanation = game.get('discard_bonus_explanation') if show_discard_explanation else None
    
    player_base_score = game.get('player_score', 0)
    computer_base_score = game.get('computer_score', 0)
    player_bags = game.get('player_bags', 0)
    computer_bags = game.get('computer_bags', 0)
    
    player_display_score = get_display_score(player_base_score, player_bags)
    computer_display_score = get_display_score(computer_base_score, computer_bags)
    
    safe_state = {
        'player_hand': game['player_hand'],
        'computer_hand_count': len(game['computer_hand']) if debug_mode else 0,
        'current_trick': game['current_trick'],
        'player_tricks': game['player_tricks'],
        'computer_tricks': game['computer_tricks'],
        'spades_broken': game['spades_broken'],
        'phase': game['phase'],
        'turn': game['turn'],
        'trick_leader': game.get('trick_leader'),
        'hand_over': game.get('hand_over', False),
        'game_over': game.get('game_over', False),
        'winner': game['winner'],
        'message': game['message'],
        'player_discarded': game.get('player_discarded'),
        'computer_discarded': game.get('computer_discarded'),
        'show_computer_hand': game.get('show_computer_hand', False) and debug_mode,
        'player_bid': game.get('player_bid'),
        'computer_bid': game.get('computer_bid'),
        'total_tricks': game.get('total_tricks', 10),
        'player_score': player_display_score,
        'computer_score': computer_display_score,
        'player_base_score': player_base_score,
        'computer_base_score': computer_base_score,
        'player_bags': player_bags,
        'computer_bags': computer_bags,
        'hand_number': game.get('hand_number', 1),
        'target_score': game.get('target_score', 300),
        'player_parity': game.get('player_parity', 'even'),
        'computer_parity': game.get('computer_parity', 'odd'),
        'player_name': player_name,
        'computer_name': computer_name,
        'discard_bonus_explanation': discard_explanation,
        'blind_bidding_available': game.get('blind_bidding_available', False),
        'blind_bid': game.get('blind_bid'),
        'computer_blind_bid': game.get('computer_blind_bid'),
        'debug_mode': debug_mode,
        'hand_results': game.get('hand_results')
    }
    
    if debug_mode and game.get('show_computer_hand', False):
        safe_state['computer_hand'] = game['computer_hand']
    
    return safe_state

# =============================================================================
# BIDDING LOGIC
# =============================================================================

def process_bidding_phase(game, session, bid, request):
    """Process player bidding with computer response and game state updates"""
    log_action(
        action_type='regular_bid',
        player='player',
        action_data={'bid_amount': bid, 'is_nil': bid == 0},
        session=session,
        request=request
    )
    
    game['player_bid'] = bid
    
    if game.get('computer_bid') is None:
        computer_bid, computer_is_blind = computer_bidding_brain(
            game['computer_hand'], 
            bid, 
            game
        )
        game['computer_bid'] = computer_bid
        
        if computer_is_blind:
            game['computer_blind_bid'] = computer_bid
            log_action(
                action_type='blind_bid',
                player='computer',
                action_data={'bid_amount': computer_bid, 'in_response_to_player': True},
                session=session
            )
        else:
            log_action(
                action_type='regular_bid',
                player='computer',
                action_data={'bid_amount': computer_bid, 'in_response_to_player': True},
                session=session
            )
            
        computer_blind_text = " (BLIND)" if computer_is_blind else ""
        player_blind_text = " (BLIND)" if game.get('blind_bid') == bid else ""
        
        message_base = f'You bid {bid}{player_blind_text}, Marta bid {computer_bid}{computer_blind_text}.'
    else:
        computer_blind_text = " (BLIND)" if game.get('computer_blind_bid') else ""
        player_blind_text = " (BLIND)" if game.get('blind_bid') == bid else ""
        
        message_base = f'You bid {bid}{player_blind_text}, Marta bid {game["computer_bid"]}{computer_blind_text}.'
    
    game['phase'] = 'playing'
    first_leader = game.get('first_leader', 'player')
    game['turn'] = first_leader
    game['trick_leader'] = first_leader
    
    log_game_event(
        event_type='bidding_complete',
        event_data={
            'player_bid': game['player_bid'],
            'computer_bid': game['computer_bid'],
            'first_leader': first_leader,
            'player_blind': game.get('blind_bid') is not None,
            'computer_blind': game.get('computer_blind_bid') is not None
        },
        session=session
    )
    
    if first_leader == 'player':
        game['message'] = f'{message_base} Your turn to lead the first trick.'
    else:
        game['message'] = f'{message_base} Marta leads the first trick.'
        computer_lead_with_logging(game, session)
        game['turn'] = 'player'
        game['message'] = f'{message_base} Marta led. Your turn to follow.'

def process_blind_bid_phase(game, session, bid, request):
    """Process blind bidding phase"""
    log_action(
        action_type='blind_bid',
        player='player',
        action_data={'bid_amount': bid},
        session=session,
        request=request
    )
    
    game['blind_bid'] = bid
    game['player_bid'] = bid
    
    computer_bid, computer_is_blind = computer_bidding_brain(
        game['computer_hand'], 
        bid, 
        game
    )
    game['computer_bid'] = computer_bid
    
    if computer_is_blind:
        game['computer_blind_bid'] = computer_bid
        log_action(
            action_type='blind_bid',
            player='computer',
            action_data={'bid_amount': computer_bid, 'in_response_to_player': True},
            session=session
        )
    else:
        log_action(
            action_type='regular_bid',
            player='computer',
            action_data={'bid_amount': computer_bid, 'in_response_to_blind': True},
            session=session
        )
    
    game['phase'] = 'discard'
    computer_blind_text = " (BLIND)" if computer_is_blind else ""
    game['message'] = f'You bid BLIND {bid}! Marta bid {computer_bid}{computer_blind_text}. Select a card to discard.'

# =============================================================================
# DISCARD LOGIC
# =============================================================================

def process_discard_phase(game, session, card_index, request):
    """Process discard phase with computer response and scoring"""
    player_card = game['player_hand'].pop(card_index)
    game['player_discarded'] = player_card
    
    log_action(
        action_type='discard',
        player='player',
        action_data={
            'card_discarded': f"{player_card['rank']}{player_card['suit']}",
            'card_index': card_index
        },
        session=session,
        additional_context={'hand_size_after': len(game['player_hand'])},
        request=request
    )
    
    idx = computer_discard_strategy(game['computer_hand'], game)
    computer_card = game['computer_hand'].pop(idx)
    game['computer_discarded'] = computer_card
    
    log_action(
        action_type='discard',
        player='computer',
        action_data={
            'card_discarded': f"{computer_card['rank']}{computer_card['suit']}",
            'card_index': idx
        },
        session=session,
        additional_context={'hand_size_after': len(game['computer_hand'])}
    )
    
    discard_result = calculate_discard_score_with_winner(
        game['player_discarded'],
        game['computer_discarded'],
        game.get('player_parity', 'even'),
        game.get('computer_parity', 'odd'),
        game
    )
    
    game['pending_discard_result'] = discard_result
    
    special_discard_result = check_special_cards_in_discard(
        game['player_discarded'],
        game['computer_discarded'],
        discard_result['winner']
    )
    
    game['pending_special_discard_result'] = special_discard_result
    
    log_game_event(
        event_type='discard_scoring',
        event_data={
            'player_card': f"{player_card['rank']}{player_card['suit']}",
            'computer_card': f"{computer_card['rank']}{computer_card['suit']}",
            'winner': discard_result['winner'],
            'bonus_points': discard_result['player_bonus'] + discard_result['computer_bonus'],
            'is_double': discard_result['is_double'],
            'explanation': discard_result['explanation']
        },
        session=session
    )
    
    # Handle post-discard phase transitions
    if game.get('player_bid') is not None:
        # Bids already set, go to playing
        transition_to_playing_phase(game, session)
    else:
        # Check blind eligibility or go to bidding
        transition_to_bidding_phase(game, session)

def transition_to_playing_phase(game, session):
    """Transition from discard to playing phase"""
    game['phase'] = 'playing'
    first_leader = game.get('first_leader', 'player')
    game['turn'] = first_leader
    game['trick_leader'] = first_leader
    
    player_blind_text = " (BLIND)" if game.get('blind_bid') else ""
    computer_blind_text = " (BLIND)" if game.get('computer_blind_bid') else ""
    
    if first_leader == 'player':
        game['message'] = f'Cards discarded. You bid {game["player_bid"]}{player_blind_text}, Marta bid {game["computer_bid"]}{computer_blind_text}. Your turn to lead the first trick.'
    else:
        game['message'] = f'Cards discarded. You bid {game["player_bid"]}{player_blind_text}, Marta bid {game["computer_bid"]}{computer_blind_text}. Marta leads the first trick.'
        computer_lead_with_logging(game, session)
        game['turn'] = 'player'
        game['message'] = f'Cards discarded. You bid {game["player_bid"]}{player_blind_text}, Marta bid {game["computer_bid"]}{computer_blind_text}. Marta led. Your turn to follow.'

def transition_to_bidding_phase(game, session):
    """Transition from discard to bidding phase (or blind decision)"""
    player_base_score = game.get('player_score', 0)
    computer_base_score = game.get('computer_score', 0)
    blind_eligibility = check_blind_bidding_eligibility(player_base_score, computer_base_score)
    
    print(f"DEBUG BLIND CHECK: Player={player_base_score}, Computer={computer_base_score}, Player Eligible={blind_eligibility['player_eligible']}, Computer Eligible={blind_eligibility['computer_eligible']}")
    
    if blind_eligibility['player_eligible']:
        game['phase'] = 'blind_decision'
        deficit = computer_base_score - player_base_score
        game['message'] = f'Cards discarded! You are down by {deficit} points. Choose: Go BLIND for double points/penalties, or bid normally?'
        
        print(f"DEBUG: Entering blind_decision phase with deficit of {deficit}")
    else:
        game['phase'] = 'bidding'
        first_leader = game.get('first_leader', 'player')
        
        if first_leader == 'computer':
            computer_bid, computer_is_blind = computer_bidding_brain(
                game['computer_hand'], 
                None,
                game
            )
            game['computer_bid'] = computer_bid
            
            if computer_is_blind:
                game['computer_blind_bid'] = computer_bid
                computer_blind_text = " (BLIND)"
                log_action(
                    action_type='blind_bid',
                    player='computer',
                    action_data={'bid_amount': computer_bid, 'bid_first': True},
                    session=session
                )
            else:
                computer_blind_text = ""
                log_action(
                    action_type='regular_bid',
                    player='computer',
                    action_data={'bid_amount': computer_bid, 'bid_first': True},
                    session=session
                )
            
            game['message'] = f'Cards discarded. Marta bid {computer_bid}{computer_blind_text}. Your turn to bid.'
        else:
            game['message'] = f'Cards discarded. Now make your bid: How many tricks will you take? (0-10)'

# =============================================================================
# GAME LOGIC HELPERS
# =============================================================================

def resolve_trick_with_delay(game, session_obj=None):
    """Resolve trick and set it up to be displayed for 3 seconds with logging"""
    if len(game['current_trick']) != 2:
        return
    
    winner = determine_trick_winner(game['current_trick'])
    
    # Save trick to history
    trick_number = len(game.get('trick_history', [])) + 1
    player_card = next((play['card'] for play in game['current_trick'] if play['player'] == 'player'), None)
    computer_card = next((play['card'] for play in game['current_trick'] if play['player'] == 'computer'), None)
    
    game.setdefault('trick_history', []).append({
        'number': trick_number,
        'player_card': player_card,
        'computer_card': computer_card,
        'winner': winner
    })
    
    # Console logging
    p_text = f"{player_card['rank']}{player_card['suit']}" if player_card else "?"
    c_text = f"{computer_card['rank']}{computer_card['suit']}" if computer_card else "?"
    winner_name = "You" if winner == 'player' else "Marta"
    print(f"TRICK {trick_number}: {p_text} vs {c_text} -> {winner_name} wins")
    
    # JSON logging
    if session_obj:
        log_game_event(
            event_type='trick_completed',
            event_data={
                'trick_number': trick_number,
                'player_card': p_text,
                'computer_card': c_text,
                'winner': winner,
                'winner_name': winner_name
            },
            session=session_obj
        )
    
    # Apply special card effects immediately
    special_result = check_special_cards_in_trick(game['current_trick'], winner)
    
    if special_result['bag_reduction'] > 0:
        if winner == 'player':
            current_bags = game.get('player_bags', 0)
            game['player_bags'] = reduce_bags_safely(current_bags, special_result['bag_reduction'])
            game['player_trick_special_cards'] = game.get('player_trick_special_cards', 0) + special_result['bag_reduction']
        else:
            current_bags = game.get('computer_bags', 0)
            game['computer_bags'] = reduce_bags_safely(current_bags, special_result['bag_reduction'])
            game['computer_trick_special_cards'] = game.get('computer_trick_special_cards', 0) + special_result['bag_reduction']
        
        game['special_card_message'] = special_result['explanation']
        
        if session_obj:
            log_game_event(
                event_type='special_card_effect',
                event_data={
                    'trick_number': trick_number,
                    'bag_reduction': special_result['bag_reduction'],
                    'beneficiary': winner_name,
                    'explanation': special_result['explanation']
                },
                session=session_obj
            )
    
    # Award trick and set message
    if winner == 'player':
        game['player_tricks'] += 1
        base_message = 'You won the trick!'
    else:
        game['computer_tricks'] += 1
        base_message = 'Marta won the trick!'
    
    if special_result['explanation']:
        game['message'] = f"{base_message} {special_result['explanation']}."
    else:
        game['message'] = f"{base_message}."
    
    game['trick_completed'] = True
    game['trick_winner'] = winner

def computer_follow_with_logging(game, session_obj=None):
    """Computer plays a card when following with logging"""
    hand = game['computer_hand']
    trick = game['current_trick']
    
    if not trick or not hand:
        return
    
    # Use enhanced strategy or fallback
    chosen_idx = computer_follow_strategy(hand, trick, game)
    
    if chosen_idx is None:
        # Fallback logic
        lead_card = trick[0]['card']
        lead_suit = lead_card['suit']
        lead_value = lead_card['value']
        
        same_suit = [(i, c) for i, c in enumerate(hand) if c['suit'] == lead_suit]
        spades = [(i, c) for i, c in enumerate(hand) if c['suit'] == 'â™ ']
        
        if same_suit:
            winners = [(i, c) for i, c in same_suit if c['value'] > lead_value]
            if winners:
                chosen_idx = min(winners, key=lambda x: x[1]['value'])[0]
            else:
                chosen_idx = min(same_suit, key=lambda x: x[1]['value'])[0]
        elif lead_suit != 'â™ ' and spades:
            chosen_idx = min(spades, key=lambda x: x[1]['value'])[0]
        else:
            all_cards = [(i, c) for i, c in enumerate(hand)]
            chosen_idx = min(all_cards, key=lambda x: x[1]['value'])[0]
    
    # Play the card
    card = hand.pop(chosen_idx)
    game['current_trick'].append({'player': 'computer', 'card': card})
    
    # Logging
    if session_obj:
        lead_card = game['current_trick'][0]['card'] if len(game['current_trick']) >= 1 else None
        log_action(
            action_type='card_play',
            player='computer',
            action_data={
                'card_played': f"{card['rank']}{card['suit']}",
                'trick_position': 2,
                'following_suit': card['suit'] == lead_card['suit'] if lead_card else False
            },
            session=session_obj,
            additional_context={
                'responding_to': f"{lead_card['rank']}{lead_card['suit']}" if lead_card else None,
                'hand_size_after': len(hand)
            }
        )
    
    if card['suit'] == 'â™ ':
        game['spades_broken'] = True
        if session_obj:
            log_game_event('spades_broken', {'broken_by': 'computer', 'card': f"{card['rank']}{card['suit']}"}, session_obj)

def computer_lead_with_logging(game, session_obj=None):
    """Computer plays a card when leading with logging"""
    hand = game['computer_hand']
    
    if not hand:
        return
    
    # Use enhanced strategy or fallback
    chosen_idx = computer_lead_strategy(hand, game['spades_broken'], game)
    
    if chosen_idx is None:
        # Fallback logic
        valid = []
        for i, card in enumerate(hand):
            if card['suit'] != 'â™ ' or game['spades_broken'] or all(c['suit'] == 'â™ ' for c in hand):
                valid.append((i, card))
        
        if valid:
            chosen = min(valid, key=lambda x: (x[1]['suit'] == 'â™ ', x[1]['value']))
            chosen_idx = chosen[0]
        else:
            return
    
    # Play the card
    card = hand.pop(chosen_idx)
    game['current_trick'] = [{'player': 'computer', 'card': card}]
    game['trick_leader'] = 'computer'
    
    # Logging
    if session_obj:
        log_action(
            action_type='card_play',
            player='computer',
            action_data={
                'card_played': f"{card['rank']}{card['suit']}",
                'trick_position': 1,
                'leading': True
            },
            session=session_obj,
            additional_context={
                'hand_size_after': len(hand)
            }
        )
    
    if card['suit'] == 'â™ ':
        game['spades_broken'] = True
        if session_obj:
            log_game_event('spades_broken', {'broken_by': 'computer', 'card': f"{card['rank']}{card['suit']}"}, session_obj)

# =============================================================================
# HAND COMPLETION LOGIC
# =============================================================================
def process_hand_completion(game, session):
    """Process hand completion with all scoring logic"""
    log_game_event(
        event_type='hand_completed',
        event_data={
            'hand_number': game['hand_number'],
            'player_tricks': game['player_tricks'],
            'computer_tricks': game['computer_tricks'],
            'player_bid': game.get('player_bid', 0),
            'computer_bid': game.get('computer_bid', 0)
        },
        session=session
    )
    
    # Apply stored discard results at the end of the hand
    if 'pending_discard_result' in game:
        discard_result = game['pending_discard_result']
        game['player_score'] += discard_result['player_bonus']
        game['computer_score'] += discard_result['computer_bonus']
        
        # Apply special card effects from discards
        if 'pending_special_discard_result' in game:
            special_discard_result = game['pending_special_discard_result']
            
            if special_discard_result['player_bag_reduction'] > 0:
                game['player_bags'] = reduce_bags_safely(
                    game.get('player_bags', 0), 
                    special_discard_result['player_bag_reduction']
                )
            
            if special_discard_result['computer_bag_reduction'] > 0:
                game['computer_bags'] = reduce_bags_safely(
                    game.get('computer_bags', 0), 
                    special_discard_result['computer_bag_reduction']
                )
            
            # Store explanation for the final message
            game['discard_bonus_explanation'] = discard_result['explanation']
            if special_discard_result['explanation']:
                game['discard_bonus_explanation'] += " | " + special_discard_result['explanation']
        else:
            game['discard_bonus_explanation'] = discard_result['explanation']
        
        # Clean up pending results
        del game['pending_discard_result']
        if 'pending_special_discard_result' in game:
            del game['pending_special_discard_result']
    
    # Calculate scoring with bags system
    scoring_result = calculate_hand_scores_with_bags(game)
    
    # Check if blind nil ended the game (but don't return early - show full results)
    blind_nil_ending = game.get('game_over', False)
    
    # Create structured hand results for cleaner display
    trick_history = game.get('trick_history', [])
    
    # Calculate display scores for hand results
    player_display_score = get_display_score(game['player_score'], game.get('player_bags', 0))
    computer_display_score = get_display_score(game['computer_score'], game.get('computer_bags', 0))
    
    hand_results = {
        'hand_number': game['hand_number'],
        'parity': {
            'player': game.get('player_parity', 'even').title(),
            'computer': game.get('computer_parity', 'odd').title()
        },
        'discard_info': game.get('discard_bonus_explanation', ''),
        'scoring': scoring_result['explanation'],
        'trick_history': [
            {
                'number': trick['number'],
                'player_card': f"{trick['player_card']['rank']}{trick['player_card']['suit']}" if trick['player_card'] else "?",
                'computer_card': f"{trick['computer_card']['rank']}{trick['computer_card']['suit']}" if trick['computer_card'] else "?",
                'winner': "You" if trick['winner'] == 'player' else "Marta"
            }
            for trick in trick_history
        ],
        'totals': {
            'player_score': player_display_score,
            'computer_score': computer_display_score
        }
    }
    
    # Store structured results for frontend
    game['hand_results'] = hand_results
    
    # Flush batched events to database
    from .logging_utils import flush_hand_events
    flush_hand_events(session)
    
    # Log final scoring
    log_game_event(
        event_type='hand_scoring',
        event_data={
            'scoring_explanation': scoring_result['explanation'],
            'final_scores': {
                'player_score': player_display_score,
                'computer_score': computer_display_score
            },
            'hand_results': hand_results
        },
        session=session
    )
    
    # Set appropriate message based on game state
    if blind_nil_ending:
        # Keep the blind nil message - it's already set in calculate_hand_scores_with_bags
        # Results will still be shown alongside the game over screen
        log_game_event(
            event_type='game_completed',
            event_data={
                'winner': game['winner'],
                'final_message': game['message'],
                'hands_played': game['hand_number'],
                'game_end_reason': 'blind_nil'
            },
            session=session
        )
    else:
        # Normal hand completion message
        game['message'] = f"Hand #{game['hand_number']} complete! Click 'Next Hand' to continue"
        
        # Check if game is over using base scores for comparison
        game_over = check_game_over(game)
        if game_over:
            log_game_event(
                event_type='game_completed',
                event_data={
                    'winner': game['winner'],
                    'final_message': game['message'],
                    'hands_played': game['hand_number']
                },
                session=session
            )

def process_auto_resolution(game, session):
    """Process auto-resolution of remaining cards"""
    auto_resolved, explanation = autoplay_remaining_cards(game, session)
    
    if auto_resolved:
        # Continue with normal hand completion logic
        if 'pending_discard_result' in game:
            discard_result = game['pending_discard_result']
            game['player_score'] += discard_result['player_bonus']
            game['computer_score'] += discard_result['computer_bonus']
            
            if 'pending_special_discard_result' in game:
                special_discard_result = game['pending_special_discard_result']
                
                if special_discard_result['player_bag_reduction'] > 0:
                    game['player_bags'] = reduce_bags_safely(
                        game.get('player_bags', 0), 
                        special_discard_result['player_bag_reduction']
                    )
                
                if special_discard_result['computer_bag_reduction'] > 0:
                    game['computer_bags'] = reduce_bags_safely(
                        game.get('computer_bags', 0), 
                        special_discard_result['computer_bag_reduction']
                    )
                
                game['discard_bonus_explanation'] = discard_result['explanation']
                if special_discard_result['explanation']:
                    game['discard_bonus_explanation'] += " | " + special_discard_result['explanation']
            else:
                game['discard_bonus_explanation'] = discard_result['explanation']
            
            del game['pending_discard_result']
            if 'pending_special_discard_result' in game:
                del game['pending_special_discard_result']
        
        # Calculate scoring
        scoring_result = calculate_hand_scores_with_bags(game)
        
        # Check if blind nil ended the game (auto-resolve case)
        blind_nil_ending = game.get('game_over', False)
        
        # Create hand results
        trick_history = game.get('trick_history', [])
        player_display_score = get_display_score(game['player_score'], game.get('player_bags', 0))
        computer_display_score = get_display_score(game['computer_score'], game.get('computer_bags', 0))
        
        hand_results = {
            'hand_number': game['hand_number'],
            'parity': {
                'player': game.get('player_parity', 'even').title(),
                'computer': game.get('computer_parity', 'odd').title()
            },
            'discard_info': game.get('discard_bonus_explanation', ''),
            'scoring': scoring_result['explanation'],
            'auto_resolution': explanation,
            'trick_history': [
                {
                    'number': trick['number'],
                    'player_card': f"{trick['player_card']['rank']}{trick['player_card']['suit']}" if trick['player_card'] else "?",
                    'computer_card': f"{trick['computer_card']['rank']}{trick['computer_card']['suit']}" if trick['computer_card'] else "?",
                    'winner': "You" if trick['winner'] == 'player' else "Marta"
                }
                for trick in trick_history
            ],
            'totals': {
                'player_score': player_display_score,
                'computer_score': computer_display_score
            }
        }
        
        game['hand_results'] = hand_results
        
        # Flush batched events to database
        from .logging_utils import flush_hand_events
        flush_hand_events(session)
        
        if blind_nil_ending:
            # Keep blind nil message and log completion
            log_game_event(
                event_type='game_completed',
                event_data={
                    'winner': game['winner'],
                    'final_message': game['message'],
                    'hands_played': game['hand_number'],
                    'game_end_reason': 'blind_nil_auto_resolve'
                },
                session=session
            )
        else:
            game['message'] = f"{explanation}. Hand #{game['hand_number']} complete! Click 'Next Hand' to continue"
            
            # Check if game is over
            game_over = check_game_over(game)
            if game_over:
                log_game_event(
                    event_type='game_completed',
                    event_data={
                        'winner': game['winner'],
                        'final_message': game['message'],
                        'hands_played': game['hand_number']
                    },
                    session=session
                )
        
        return True
    
    return False

================================================================================

FILE: ./utilities/custom_rules.py
--------------------------------------------------------------------------------
import random

def get_discard_value(card):
    """
    Get the numerical value of a card for discard scoring.
    J=11, Q=12, K=13, A=1, numbers are face value
    """
    rank = card['rank']
    if rank == 'A':
        return 1
    elif rank == 'J':
        return 11
    elif rank == 'Q':
        return 12
    elif rank == 'K':
        return 13
    else:
        return int(rank)

def assign_even_odd_at_game_start():
    """
    Randomly assign even/odd to players at the start of a new game.
    Also determines who leads the first trick - if player is odd, they lead first.
    Returns tuple: (player_parity, computer_parity, first_leader)
    """
    coin_flip = random.choice(['even', 'odd'])
    if coin_flip == 'even':
        player_parity = 'even'
        computer_parity = 'odd'
        first_leader = 'computer'  # Computer (odd) leads first trick
    else:
        player_parity = 'odd'
        computer_parity = 'even'
        first_leader = 'player'   # Player (odd) leads first trick
    
    return (player_parity, computer_parity, first_leader)

def is_special_card(card):
    """
    Check if a card is one of the special bag-reducing cards.
    Returns tuple: (is_special, bags_to_remove)
    """
    if card['rank'] == '7' and card['suit'] == 'â™¦':
        return True, 2  # 7 of diamonds removes 2 bags
    elif card['rank'] == '10' and card['suit'] == 'â™£':
        return True, 1  # 10 of clubs removes 1 bag
    else:
        return False, 0

def check_blind_bidding_eligibility(player_score, computer_score, target_score=300):
    """
    Check if a player is eligible for blind bidding (down by 100+ points).
    
    Returns:
        dict: {
            'player_eligible': bool,
            'computer_eligible': bool,
            'player_deficit': int,
            'computer_deficit': int
        }
    """
    player_deficit = computer_score - player_score
    computer_deficit = player_score - computer_score
    
    return {
        'player_eligible': player_deficit >= 100,
        'computer_eligible': computer_deficit >= 100,
        'player_deficit': max(0, player_deficit),
        'computer_deficit': max(0, computer_deficit)
    }

def apply_blind_scoring(base_points, blind_bid, actual_tricks):
    """
    Apply blind bidding scoring rules.
    
    Args:
        base_points: Normal points that would be awarded
        blind_bid: The blind bid amount (5-10)
        actual_tricks: Actual tricks taken
        
    Returns:
        int: Modified points (doubled if successful, doubled penalty if failed)
    """
    if actual_tricks >= blind_bid:
        # Successful blind bid: double the points
        return base_points * 2
    else:
        # Failed blind bid: double the penalty
        return base_points * 2  # base_points will already be negative for failed bids

def check_special_cards_in_discard(player_discard, computer_discard, discard_winner):
    """
    Check for special cards in the discard pile and apply bag reduction to the winner.
    """
    total_reduction = 0
    special_cards_found = []
    
    # Check both discarded cards for special cards
    for card, discarder in [(player_discard, 'You'), (computer_discard, 'Marta')]:
        if card:
            is_special, reduction = is_special_card(card)
            if is_special:
                total_reduction += reduction
                card_name = f"{card['rank']}{card['suit']}"
                special_cards_found.append(f"{card_name} (-{reduction} bags)")
    
    # Apply all reductions to the winner of the discard pile
    player_reduction = 0
    computer_reduction = 0
    
    if total_reduction > 0:
        if discard_winner == 'player':
            player_reduction = total_reduction
        else:
            computer_reduction = total_reduction
    
    # Create explanation
    explanation = ""
    if special_cards_found:
        winner_name = "You" if discard_winner == 'player' else "Marta"
        cards_text = ", ".join(special_cards_found)
        explanation = f"{winner_name} won discard pile with special cards: {cards_text}"
    
    return {
        'player_bag_reduction': player_reduction,
        'computer_bag_reduction': computer_reduction,
        'explanation': explanation
    }

def check_special_cards_in_trick(trick, winner):
    """
    Check for special cards in a completed trick and apply bag reduction to winner.
    """
    total_reduction = 0
    special_cards_found = []
    
    for play in trick:
        card = play['card']
        is_special, reduction = is_special_card(card)
        if is_special:
            total_reduction += reduction
            card_name = f"{card['rank']}{card['suit']}"
            special_cards_found.append(f"{card_name} (-{reduction} bags)")
    
    explanation = ""
    if special_cards_found:
        winner_name = "You" if winner == 'player' else "Marta"
        cards_text = ", ".join(special_cards_found)
        explanation = f"{winner_name} won trick with special cards: {cards_text}"
    
    return {
        'bag_reduction': total_reduction,
        'explanation': explanation
    }

def calculate_discard_score_with_winner(player_discard, computer_discard, player_parity, computer_parity, game_state=None):
    """
    Calculate the bonus points from discarded cards and determine winner.
    
    DENIAL RULE: If discard points would end the game, the losing player who wins
    the discard pile automatically SUBTRACTS those points from opponent instead.
    This keeps the game alive for another hand!
    """
    if not player_discard or not computer_discard:
        return {
            'player_bonus': 0,
            'computer_bonus': 0, 
            'total': 0,
            'is_double': False,
            'winner': None,
            'explanation': 'No discards to score',
            'denial_option_used': False
        }
    
    # Calculate total value
    player_value = get_discard_value(player_discard)
    computer_value = get_discard_value(computer_discard)
    total = player_value + computer_value
    
    # Check for doubles (same suit OR same rank)
    is_double = (player_discard['suit'] == computer_discard['suit'] or 
                 player_discard['rank'] == computer_discard['rank'])
    
    # Determine base points (10 for normal, 20 for doubles)
    base_points = 20 if is_double else 10
    
    # Determine who wins the discard pile based on parity
    is_total_even = (total % 2 == 0)
    winner = None
    
    if is_total_even and player_parity == 'even':
        winner = 'player'
    elif not is_total_even and player_parity == 'odd':
        winner = 'player'
    elif is_total_even and computer_parity == 'even':
        winner = 'computer'
    elif not is_total_even and computer_parity == 'odd':
        winner = 'computer'
    
    # Initialize default bonuses
    player_bonus = 0
    computer_bonus = 0
    denial_option_used = False
    
    # Check if we should apply the denial rule
    if game_state and winner:
        # Get current scores (before any discard bonus)
        player_score = game_state.get('player_score', 0)
        computer_score = game_state.get('computer_score', 0)
        player_bags = game_state.get('player_bags', 0)
        computer_bags = game_state.get('computer_bags', 0)
        target_score = game_state.get('target_score', 300)
        
        # Calculate display scores (what players see)
        def calc_display_score(base_score, bags):
            if bags >= 0:
                if base_score < 0:
                    tens_and_higher = (base_score // 10) * 10
                    return tens_and_higher - bags
                else:
                    tens_and_higher = (base_score // 10) * 10
                    return tens_and_higher + bags
            else:
                return base_score
        
        player_display = calc_display_score(player_score, player_bags)
        computer_display = calc_display_score(computer_score, computer_bags)
        
        # Determine if denial should be used (automatic for both players)
        if winner == 'player':
            # Player wins the discard pile
            new_player_display = calc_display_score(player_score + base_points, player_bags)
            
            # Check if either player would reach target score
            if new_player_display >= target_score or computer_display >= target_score:
                if player_display < computer_display:
                    # Player is losing - USE DENIAL to keep game alive!
                    computer_bonus = -base_points  # Subtract from Marta instead
                    denial_option_used = True
                else:
                    # Player is already winning - take the points normally
                    player_bonus = base_points
            else:
                # Game continues either way - normal points
                player_bonus = base_points
                
        else:  # winner == 'computer'
            # Computer wins the discard pile
            new_computer_display = calc_display_score(computer_score + base_points, computer_bags)
            
            # Check if either player would reach target score
            if new_computer_display >= target_score or player_display >= target_score:
                if computer_display < player_display:
                    # Marta is losing - USE DENIAL to keep game alive!
                    player_bonus = -base_points  # Subtract from player instead
                    denial_option_used = True
                else:
                    # Marta is already winning - take the points normally
                    computer_bonus = base_points
            else:
                # Game continues either way - normal points
                computer_bonus = base_points
    else:
        # No game state provided - use normal rules
        if winner == 'player':
            player_bonus = base_points
        elif winner == 'computer':
            computer_bonus = base_points
    
    # Create explanation text
    double_text = ""
    if is_double:
        if player_discard['suit'] == computer_discard['suit']:
            double_text = f" (DOUBLE: Both {player_discard['suit']} suit!)"
        else:
            double_text = f" (DOUBLE: Both {player_discard['rank']}s!)"
    
    parity_text = "even" if is_total_even else "odd"
    
    explanation = f"Discards: {player_discard['rank']}{player_discard['suit']} ({player_value}) + {computer_discard['rank']}{computer_discard['suit']} ({computer_value}) = {total} ({parity_text}){double_text}"
    
    # Add outcome to explanation
    if denial_option_used:
        if winner == 'player':
            explanation += f" â†’ You use DENIAL! Marta loses {base_points} pts (keeps game alive!)"
        else:
            explanation += f" â†’ Marta uses DENIAL! You lose {base_points} pts (keeps game alive!)"
    elif player_bonus > 0:
        explanation += f" â†’ You get {player_bonus} pts!"
    elif computer_bonus > 0:
        explanation += f" â†’ Marta gets {computer_bonus} pts!"
    else:
        explanation += " â†’ No bonus points this hand."
    
    return {
        'player_bonus': player_bonus,
        'computer_bonus': computer_bonus,
        'total': total,
        'is_double': is_double,
        'winner': winner,
        'explanation': explanation,
        'denial_option_used': denial_option_used
    }

def apply_bags_penalty(score, bags):
    """Apply bags penalty system."""
    penalty_applied = False
    bonus_applied = False
    
    while bags >= 7:
        score -= 100
        bags -= 7
        penalty_applied = True
    
    while bags <= -5:
        score += 100
        bags += 5
        bonus_applied = True
    
    return score, bags, penalty_applied, bonus_applied

def reduce_bags_safely(current_bags, reduction):
    """Reduce bags by the specified amount. Bags can go negative."""
    return current_bags - reduction


def calculate_hand_scores_with_bags(game):
    """
    Calculate hand scoring including bags system, nil bids, blind bidding, and blind nil for both players.
    """
    
    # Check for blind nil FIRST - it ends the game immediately
    if game.get('blind_nil') and game.get('player_bid') == 0:
        player_actual = game.get('player_tricks', 0)
        if player_actual == 0:
            # INSTANT WIN - Set score to 500 to show massive victory
            game['player_score'] = 500
            game['game_over'] = True
            game['winner'] = 'player'
            game['message'] = "BLIND NIL SUCCESS! You win the entire game instantly!"
            return {'explanation': "BLIND NIL SUCCESS - INSTANT GAME WIN!"}
        else:
            # INSTANT LOSS - Keep Marta's current score, player gets massive penalty
            game['player_score'] = -500  # Show crushing defeat
            game['game_over'] = True
            game['winner'] = 'computer'
            game['message'] = f"Blind Nil failed - you took {player_actual} tricks. Marta wins!"
            return {'explanation': f"BLIND NIL FAILURE - took {player_actual} tricks - GAME OVER"}

    
    # Normal scoring continues if no blind nil or blind nil not attempted
    player_bid = game.get('player_bid', 0)
    computer_bid = game.get('computer_bid', 0)
    player_actual = game.get('player_tricks', 0)
    computer_actual = game.get('computer_tricks', 0)
    
    # Check blind bids for both players
    is_player_blind = game.get('blind_bid') == player_bid and game.get('blind_bid') is not None
    is_computer_blind = game.get('computer_blind_bid') == computer_bid and game.get('computer_blind_bid') is not None
    
    # Get current bags
    current_player_bags = game.get('player_bags', 0)
    current_computer_bags = game.get('computer_bags', 0)
    
    # Calculate player points
    if player_bid == 0:
        if player_actual == 0:
            player_hand_points = 200  # NIL success
            player_bags_added = 0
        else:
            player_hand_points = -200  # NIL failure
            player_bags_added = player_actual
    elif player_actual >= player_bid:
        player_hand_points = (player_bid * 10)
        player_bags_added = player_actual - player_bid
        if is_player_blind:
            player_hand_points = apply_blind_scoring(player_hand_points, player_bid, player_actual)
    else:
        player_hand_points = -(player_bid * 10)
        player_bags_added = 0
        if is_player_blind:
            player_hand_points = apply_blind_scoring(player_hand_points, player_bid, player_actual)
    
    # Calculate computer points
    if computer_bid == 0:
        if computer_actual == 0:
            computer_hand_points = 200  # NIL success
            computer_bags_added = 0
        else:
            computer_hand_points = -200  # NIL failure
            computer_bags_added = computer_actual
    elif computer_actual >= computer_bid:
        computer_hand_points = (computer_bid * 10)
        computer_bags_added = computer_actual - computer_bid
        if is_computer_blind:
            computer_hand_points = apply_blind_scoring(computer_hand_points, computer_bid, computer_actual)
    else:
        computer_hand_points = -(computer_bid * 10)
        computer_bags_added = 0
        if is_computer_blind:
            computer_hand_points = apply_blind_scoring(computer_hand_points, computer_bid, computer_actual)
    
    # Update bag counts
    new_player_bags = current_player_bags + player_bags_added
    new_computer_bags = current_computer_bags + computer_bags_added
    
    # Apply bag penalties/bonuses
    player_score = game.get('player_score', 0) + player_hand_points
    computer_score = game.get('computer_score', 0) + computer_hand_points
    
    player_score, final_player_bags, player_penalty, player_bonus = apply_bags_penalty(player_score, new_player_bags)
    computer_score, final_computer_bags, computer_penalty, computer_bonus = apply_bags_penalty(computer_score, new_computer_bags)
    
    # Update game state
    game['player_bags'] = final_player_bags
    game['computer_bags'] = final_computer_bags
    game['player_score'] = player_score
    game['computer_score'] = computer_score
    
    # Get special card tracking for summary
    player_trick_special_cards = game.get('player_trick_special_cards', 0)
    computer_trick_special_cards = game.get('computer_trick_special_cards', 0)
    
    # Reset special card tracking for next hand
    game['player_trick_special_cards'] = 0
    game['computer_trick_special_cards'] = 0
    
    # Create explanation
    explanation_parts = []
    
    # Player explanation
    if player_bid == 0:
        if player_actual == 0:
            explanation_parts.append(f"You: NIL SUCCESS! 0 bid, 0 tricks (+200 pts)")
        else:
            explanation_parts.append(f"You: NIL FAILED! 0 bid, {player_actual} tricks (-200 pts, +{player_bags_added} bags)")
    elif is_player_blind:
        if player_actual >= player_bid:
            explanation_parts.append(f"You: BLIND {player_bid} SUCCESS! {player_actual} tricks (DOUBLE POINTS: +{player_hand_points} pts)")
        else:
            explanation_parts.append(f"You: BLIND {player_bid} FAILED! {player_actual} tricks (DOUBLE PENALTY: {player_hand_points} pts)")
        if player_bags_added > 0:
            explanation_parts[-1] += f", +{player_bags_added} bags"
    elif player_bags_added > 0:
        explanation_parts.append(f"You: {player_bid} bid, {player_actual} tricks (+{player_bags_added} bags)")
    else:
        explanation_parts.append(f"You: {player_bid} bid, {player_actual} tricks")
    
    # Computer explanation with blind support
    if computer_bid == 0:
        if computer_actual == 0:
            explanation_parts.append(f"Marta: NIL SUCCESS! 0 bid, 0 tricks (+200 pts)")
        else:
            explanation_parts.append(f"Marta: NIL FAILED! 0 bid, {computer_actual} tricks (-200 pts, +{computer_bags_added} bags)")
    elif is_computer_blind:
        if computer_actual >= computer_bid:
            explanation_parts.append(f"Marta: BLIND {computer_bid} SUCCESS! {computer_actual} tricks (DOUBLE POINTS: +{computer_hand_points} pts)")
        else:
            explanation_parts.append(f"Marta: BLIND {computer_bid} FAILED! {computer_actual} tricks (DOUBLE PENALTY: {computer_hand_points} pts)")
        if computer_bags_added > 0:
            explanation_parts[-1] += f", +{computer_bags_added} bags"
    elif computer_bags_added > 0:
        explanation_parts.append(f"Marta: {computer_bid} bid, {computer_actual} tricks (+{computer_bags_added} bags)")
    else:
        explanation_parts.append(f"Marta: {computer_bid} bid, {computer_actual} tricks")
    
    # Show special card effects from tricks
    if player_trick_special_cards > 0:
        explanation_parts.append(f"You won special cards: -{player_trick_special_cards} bags")
    if computer_trick_special_cards > 0:
        explanation_parts.append(f"Marta won special cards: -{computer_trick_special_cards} bags")
    
    # Show penalties and bonuses
    if player_penalty:
        penalty_count = (current_player_bags + player_bags_added) // 7
        explanation_parts.append(f"You: BAG PENALTY! -{penalty_count * 100} pts")
    
    if player_bonus:
        bonus_count = abs((current_player_bags + player_bags_added) // -5)
        explanation_parts.append(f"You: NEGATIVE BAG BONUS! +{bonus_count * 100} pts")
        
    if computer_penalty:
        penalty_count = (current_computer_bags + computer_bags_added) // 7
        explanation_parts.append(f"Marta: BAG PENALTY! -{penalty_count * 100} pts")
    
    if computer_bonus:
        bonus_count = abs((current_computer_bags + computer_bags_added) // -5)
        explanation_parts.append(f"Marta: NEGATIVE BAG BONUS! +{bonus_count * 100} pts")
    
    # Show current bag counts
    if final_player_bags != 0 or final_computer_bags != 0:
        explanation_parts.append(f"Bags: You {final_player_bags}/7, Marta {final_computer_bags}/7")
    
    return {
        'player_hand_points': player_hand_points,
        'computer_hand_points': computer_hand_points,
        'player_bags_added': player_bags_added,
        'computer_bags_added': computer_bags_added,
        'player_penalty': player_penalty,
        'computer_penalty': computer_penalty,
        'player_bonus': player_bonus,
        'computer_bonus': computer_bonus,
        'explanation': " | ".join(explanation_parts)
    }

def get_player_names_with_parity(player_parity, computer_parity):
    """
    Get display names that include the parity assignment.
    """
    player_name = f"You ({player_parity.title()})"
    computer_name = f"Marta ({computer_parity.title()})"
    
    return (player_name, computer_name)

================================================================================

FILE: ./utilities/computer_logic.py
--------------------------------------------------------------------------------
"""
Computer AI logic for Two-Man Spades
Handles all computer decision making including bidding, discarding, and play strategy
"""
import random
from .custom_rules import (
    get_discard_value, 
    is_special_card, 
    check_blind_bidding_eligibility,
    apply_blind_scoring
)

from .logging_utils import log_game_event

# =============================================================================
# GLOBAL AI DIFFICULTY SETTINGS
# =============================================================================

# Discard Strategy Settings
SINGLETON_SPECIAL_PRIORITY = 1000    # How much to prioritize discarding singleton 7â™¦/10â™£
VOID_CREATION_PRIORITY = 500         # How much to value creating voids
SPECIAL_CARD_PROTECTION = -100       # Penalty for discarding protected special cards
SPADE_DISCARD_PENALTY = 3           # Multiplier for avoiding spade discards
PARITY_CONSIDERATION = 1            # Small bonus for parity-favorable discards

# Bidding Strategy Settings  
BID_ACCURACY_BOOST = 0.3            # How much to boost base expectations (higher = more aggressive)
NIL_RISK_TOLERANCE = 0.8            # Threshold for nil bidding (lower = more nil attempts)
BLIND_DESPERATION_THRESHOLD = 120   # Points behind before considering blind bids
SCORE_BASED_ADJUSTMENT = 0.05       # How much score differential affects bidding
NIL_STRICTNESS = 0.8                # Lower = more likely to nil (minimum expectation for non-nil)
MAX_REASONABLE_BID = 6              # mnost she can bid


# Playing Strategy Settings
BAG_AVOIDANCE_STRENGTH = 0.92       # Multiplier when trying to avoid bags (lower = more avoidance)
LEAD_SAFETY_CONSIDERATION = True    # Whether to avoid leading into dangerous suits

# Meta-Strategy Settings
DEFAULT_BLIND_BID = 5

# =============================================================================
# HAND ANALYSIS FUNCTIONS
# =============================================================================

def analyze_hand_strength(hand):
    """
    Analyze hand strength and return expected trick count
    Returns tuple: (sure_tricks, probable_tricks, special_card_bonus)
    """
    sure_tricks = 0
    probable_tricks = 0
    special_card_bonus = 0
    
    # Count special cards for strategic value
    for card in hand:
        is_special, bag_reduction = is_special_card(card)
        if is_special:
            special_card_bonus += 0.2  # Special cards provide strategic value
    
    # Separate spades from other suits
    spades = [card for card in hand if card['suit'] == 'â™ ']
    other_suits = [card for card in hand if card['suit'] != 'â™ ']
    
    # Group other suits
    suits = {'â™¥': [], 'â™¦': [], 'â™£': []}
    for card in other_suits:
        suits[card['suit']].append(card)
    
    # ENHANCED SPADES ANALYSIS
    spade_values = sorted([card['value'] for card in spades], reverse=True)
    spade_count = len(spades)
    
    # Apply spade count expectations
    if spade_count >= 5:
        sure_tricks += 3.0  # Expect 3 tricks from 5+ spades
        probable_tricks += 2.0
    elif spade_count == 4:
        sure_tricks += 2.0  # Expect 2 tricks from 4 spades  
        probable_tricks += 1.0
    elif spade_count == 3:
        sure_tricks += 1.5  # Expect 1.5 tricks from 3 spades
        probable_tricks += 0.5
    elif spade_count == 2:
        sure_tricks += 0.8  # Modest expectation from 2 spades
        probable_tricks += 0.4
    elif spade_count == 1:
        sure_tricks += 0.3  # Low expectation from 1 spade
    
    # High spades get additional value
    ace_spades = sum(1 for v in spade_values if v == 14)
    king_spades = sum(1 for v in spade_values if v == 13)
    queen_spades = sum(1 for v in spade_values if v == 12)
    
    if ace_spades > 0:
        sure_tricks += 0.3 * ace_spades  # Ace of spades is nearly guaranteed
    if king_spades > 0:
        sure_tricks += 0.2 * king_spades  # King of spades very likely
    if queen_spades > 0:
        probable_tricks += 0.2 * queen_spades  # Queen adds some value
    
    # ENHANCED OTHER SUITS ANALYSIS
    aces_other_suits = 0
    kings_other_suits = 0
    
    for suit, cards in suits.items():
        if not cards:
            continue
            
        values = sorted([card['value'] for card in cards], reverse=True)
        
        # Count high cards for overall hand strength
        aces_in_suit = sum(1 for v in values if v == 14)
        kings_in_suit = sum(1 for v in values if v == 13)
        
        aces_other_suits += aces_in_suit
        kings_other_suits += kings_in_suit
        
        # Aces in other suits (can be trumped but still strong)
        if 14 in values:
            sure_tricks += 0.8 * aces_in_suit  # High but not guaranteed
        
        # Protected kings (with ace)
        if 13 in values and 14 in values:
            sure_tricks += 0.6 * kings_in_suit  # Protected kings are strong
        elif 13 in values:
            if len(cards) >= 3:  # King in long suit has protection
                probable_tricks += 0.5 * kings_in_suit
            else:  # Unprotected king
                probable_tricks += 0.3 * kings_in_suit
        
        # Long suits can generate tricks through length
        if len(cards) >= 4:
            probable_tricks += (len(cards) - 3) * 0.25
    
    # MULTIPLE HIGH CARDS BONUS
    total_high_cards = aces_other_suits + kings_other_suits + ace_spades + king_spades
    
    if total_high_cards >= 4:
        sure_tricks += 0.5  # Multiple high cards create synergy
        probable_tricks += 0.3
    elif total_high_cards >= 3:
        sure_tricks += 0.3
        probable_tricks += 0.2
    elif total_high_cards >= 2:
        probable_tricks += 0.2
    
    # VOID SUITS (can trump)
    void_suits = sum(1 for cards in suits.values() if len(cards) == 0)
    if void_suits > 0 and spade_count >= 2:
        probable_tricks += void_suits * 0.4  # Void + spades = trumping opportunities
    
    return sure_tricks, probable_tricks, special_card_bonus

def analyze_suit_distribution(hand):
    """Analyze suit distribution and identify singleton/void opportunities"""
    suits = {'â™¥': [], 'â™¦': [], 'â™£': [], 'â™ ': []}
    
    for card in hand:
        suits[card['suit']].append(card)
    
    distribution = {}
    for suit, cards in suits.items():
        distribution[suit] = {
            'count': len(cards),
            'cards': cards,
            'is_void': len(cards) == 0,
            'is_singleton': len(cards) == 1
        }
    
    return distribution

# =============================================================================
# DISCARD STRATEGY
# =============================================================================

def computer_discard_strategy(computer_hand, game_state):
    """
    Enhanced discard strategy prioritizing singleton special cards and void creation
    Returns index of card to discard
    """
    player_parity = game_state.get('player_parity', 'even')
    computer_parity = game_state.get('computer_parity', 'odd')
    
    # Analyze suit distribution
    suit_distribution = analyze_suit_distribution(computer_hand)
    
    discard_candidates = []
    
    for i, card in enumerate(computer_hand):
        score = 0
        suit_info = suit_distribution[card['suit']]
        
        # PRIORITY 1: Singleton special cards - MUST discard these
        if suit_info['is_singleton'] and card['suit'] != 'â™ ':
            is_special, _ = is_special_card(card)
            if is_special:
                score += SINGLETON_SPECIAL_PRIORITY
                discard_candidates.append((i, score))
                continue  # Don't apply other penalties to singleton specials
        
        # PRIORITY 2: Void creation (singleton non-specials in non-spade suits)
        elif suit_info['is_singleton'] and card['suit'] != 'â™ ':
            spade_count = suit_distribution['â™ ']['count']
            # More spades = void is more valuable
            void_value = (spade_count * VOID_CREATION_PRIORITY) // 10
            if spade_count >= 4:  # Strong spade holding
                void_value += (VOID_CREATION_PRIORITY // 4)
            void_value -= card['value']  # Prefer discarding low cards
            score += void_value
        
        # PRIORITY 3: Normal special card protection (protected specials)
        else:
            is_special, _ = is_special_card(card)
            if is_special:
                score += SPECIAL_CARD_PROTECTION  # Negative score
        
        # PRIORITY 4: Avoid discarding spades
        if card['suit'] == 'â™ ':
            score -= card['value'] * SPADE_DISCARD_PENALTY
        else:
            # Prefer discarding low cards from other suits
            score += (15 - card['value'])
        
        # PRIORITY 5: Light parity consideration
        discard_value = get_discard_value(card)
        if computer_parity == 'even' and discard_value % 2 == 1:
            score += PARITY_CONSIDERATION
        elif computer_parity == 'odd' and discard_value % 2 == 0:
            score += PARITY_CONSIDERATION
        
        discard_candidates.append((i, score))
    
    # Return index of card with highest discard score
    return max(discard_candidates, key=lambda x: x[1])[0]

# =============================================================================
# BIDDING STRATEGY
# =============================================================================

def should_bid_nil(hand, game_state):
    """
    Determine if computer should bid nil
    """
    player_score = game_state.get('player_score', 0)
    computer_score = game_state.get('computer_score', 0)
    player_bid = game_state.get('player_bid', 0)
    
    # Get hand strength
    sure_tricks, probable_tricks, special_bonus = analyze_hand_strength(hand)
    total_expectation = sure_tricks + probable_tricks + special_bonus
    
    # Use configurable nil threshold
    if total_expectation > NIL_STRICTNESS:
        return False
    
    # Must have very few spades and they must be low
    spades = [card for card in hand if card['suit'] == 'â™ ']
    if len(spades) > 3:  # At most 3 spades
        return False
    
    # No high spades allowed
    for spade in spades:
        if spade['value'] >= 11:  # No J, Q, K, A of spades
            return False
    
    # Must have at least 2 twos for safety
    twos = [card for card in hand if card['rank'] == '2']
    if len(twos) < 2:
        return False
    
    # Must have mostly very low cards (2-7) in other suits
    other_suits = [card for card in hand if card['suit'] != 'â™ ']
    low_cards = [card for card in other_suits if card['value'] <= 7]
    
    if len(low_cards) < len(other_suits) - 1:
        return False
    
    # No aces or kings in other suits
    high_other_suits = [card for card in other_suits if card['value'] >= 13]
    if len(high_other_suits) > 0:
        return False
    
    # Don't nil if player already bid nil
    if player_bid == 0:
        return False
    
    # Only nil when significantly behind
    if computer_score >= player_score - 50:
        return False
    
    # Conservative probability - only when truly desperate
    return computer_score < player_score - 80

def should_bid_blind(hand, game_state):
    """
    Determine if computer should bid blind when eligible
    Returns tuple: (should_blind, blind_bid_amount)
    """
    player_score = game_state.get('player_score', 0)
    computer_score = game_state.get('computer_score', 0)
    
    # Check eligibility
    blind_eligibility = check_blind_bidding_eligibility(player_score, computer_score)
    if not blind_eligibility['computer_eligible']:
        return False, 0
    
    # If down by 100+, just go blind 5 (simplest aggressive strategy)
    return True, DEFAULT_BLIND_BID

def computer_bidding_brain(computer_hand, player_bid, game_state):
    """
    Main computer bidding function
    Returns tuple: (bid_amount, is_blind)
    """
    player_score = game_state.get('player_score', 0)
    computer_score = game_state.get('computer_score', 0)
    computer_bags = game_state.get('computer_bags', 0)
    
    # Check for nil opportunity first
    if should_bid_nil(computer_hand, game_state):
        return 0, False
    
    # Check for blind bidding opportunity
    should_blind, blind_amount = should_bid_blind(computer_hand, game_state)
    if should_blind:
        return blind_amount, True
    
    # Regular bidding logic
    sure_tricks, probable_tricks, special_bonus = analyze_hand_strength(computer_hand)
    base_expectation = sure_tricks + probable_tricks + special_bonus
    
    # Apply configurable accuracy boost
    base_expectation += BID_ACCURACY_BOOST
    
    # Score-based adjustments
    score_diff = computer_score - player_score
    if score_diff > 30:  # Ahead - be slightly conservative
        base_expectation *= (1 - SCORE_BASED_ADJUSTMENT)
    elif score_diff < -30:  # Behind - be slightly aggressive
        base_expectation *= (1 + SCORE_BASED_ADJUSTMENT)
    
    # Bag avoidance when close to penalty
    if computer_bags >= 5:
        base_expectation *= BAG_AVOIDANCE_STRENGTH
    
    # Strategic response to player's bid
    if player_bid is not None:
        if player_bid == 0:  # Player nil - be aggressive to set them
            base_expectation += 0.3
        elif player_bid <= 2:  # Player bid low
            base_expectation += 0.15
        elif player_bid >= 7:  # Player bid high
            base_expectation -= 0.2

    # Convert to bid
    raw_bid = max(0, min(10, round(base_expectation)))

    # Apply maximum reasonable bid cap
    raw_bid = min(raw_bid, MAX_REASONABLE_BID)

    # Bid range preferences
    if 2.5 <= base_expectation <= 5.5:
        if raw_bid < 3:
            raw_bid = 3  # Minimum reasonable bid is 3
        elif raw_bid == 5 and random.random() < 0.4:
            raw_bid = 4  # Sometimes prefer 4 over 5

    # Avoid obvious total-10 scenarios
    if player_bid is not None and abs((raw_bid + player_bid) - 10) <= 1 and random.random() < 0.3:
        if raw_bid > 3:
            raw_bid -= 1
        # Remove the elif raw_bid < 7 clause since we're capping at 6

    # Final bounds check with new maximum
    raw_bid = max(1, min(MAX_REASONABLE_BID, raw_bid))
    
    return raw_bid, False

# =============================================================================
# PLAYING STRATEGY
# =============================================================================

def computer_lead_strategy(computer_hand, spades_broken, game_state=None):
    """
    Enhanced leading strategy with absolute special card protection
    """
    if not computer_hand:
        return None
    
    # Import special card check
    from .custom_rules import is_special_card
    
    # Find all valid leads (respecting spades rules)
    valid_leads = []
    for i, card in enumerate(computer_hand):
        if card['suit'] != 'â™ ' or spades_broken or all(c['suit'] == 'â™ ' for c in computer_hand):
            valid_leads.append((i, card))
    
    if not valid_leads:
        return None
    
    # CRITICAL: Never lead special cards unless absolutely no choice
    non_special_leads = []
    special_leads = []
    
    for i, card in valid_leads:
        is_special, _ = is_special_card(card)
        if is_special:
            special_leads.append((i, card))
        else:
            non_special_leads.append((i, card))
    
    # If we have ANY non-special cards to lead, NEVER lead special cards
    if non_special_leads:
        leads_to_consider = non_special_leads
    else:
        # Only consider special cards if we literally have no other choice
        leads_to_consider = special_leads
    
    # Advanced bag forcing logic (only if we have non-special cards)
    if game_state and leads_to_consider == non_special_leads:
        computer_bid = game_state.get('computer_bid', 0)
        computer_tricks = game_state.get('computer_tricks', 0) 
        player_bags = game_state.get('player_bags', 0)
        
        # If we've made our bid and player has 5+ bags, lead high to force them
        if computer_tricks >= computer_bid > 0 and player_bags >= 5:
            return max(leads_to_consider, key=lambda x: x[1]['value'])[0]
    
    # Normal strategy: lead lowest safe card
    return min(leads_to_consider, key=lambda x: x[1]['value'])[0]

def computer_follow_strategy(computer_hand, current_trick, game_state):
    """
    Enhanced following strategy with special card protection and acquisition
    Returns index of best card to play
    """
    if not current_trick or not computer_hand:
        return None

    from .custom_rules import is_special_card

    computer_bid = game_state.get('computer_bid', 0)
    computer_tricks = game_state.get('computer_tricks', 0)
    
    # Check if computer has already made their bid
    made_bid = computer_tricks >= computer_bid and computer_bid > 0

    lead_card = current_trick[0]['card']
    lead_suit = lead_card['suit']
    lead_value = lead_card['value']

    # Check if player played a special card that we want to win
    player_has_special = is_special_card(lead_card)[0]

    # Find valid plays
    same_suit = [(i, c) for i, c in enumerate(computer_hand) if c['suit'] == lead_suit]
    spades = [(i, c) for i, c in enumerate(computer_hand) if c['suit'] == 'â™ ']
    other = [(i, c) for i, c in enumerate(computer_hand) if c['suit'] != lead_suit and c['suit'] != 'â™ ']

    if same_suit:
        # Must follow suit
        winners = [(i, c) for i, c in same_suit if c['value'] > lead_value]
        losers = [(i, c) for i, c in same_suit if c['value'] <= lead_value]
        
        # Separate special and non-special cards in same suit
        special_winners = [(i, c) for i, c in winners if is_special_card(c)[0]]
        non_special_winners = [(i, c) for i, c in winners if not is_special_card(c)[0]]
        special_losers = [(i, c) for i, c in losers if is_special_card(c)[0]]
        non_special_losers = [(i, c) for i, c in losers if not is_special_card(c)[0]]
        
        # PRIORITY 1: If player played special card, try to win it (but not with our special cards)
        if player_has_special and non_special_winners:
            return min(non_special_winners, key=lambda x: x[1]['value'])[0]
        
        # PRIORITY 2: If we can win without special cards, prefer that
        if made_bid:
            # Already made bid - avoid taking more tricks, but protect special cards
            if non_special_losers:
                # Play highest non-special losing card to shed dangerous cards
                return max(non_special_losers, key=lambda x: x[1]['value'])[0]
            elif special_losers:
                # Only play special losing cards if no choice
                return min(special_losers, key=lambda x: x[1]['value'])[0]
            elif non_special_winners:
                # Must win - use lowest non-special winner
                return min(non_special_winners, key=lambda x: x[1]['value'])[0]
            else:
                # Only special winners left - use lowest
                return min(special_winners, key=lambda x: x[1]['value'])[0]
        else:
            # Still need tricks - try to win, but protect special cards
            if non_special_winners:
                return min(non_special_winners, key=lambda x: x[1]['value'])[0]
            elif special_winners and player_has_special:
                # Worth using special card to win player's special card
                return min(special_winners, key=lambda x: x[1]['value'])[0]
            elif non_special_losers:
                # Can't win without special cards - play lowest non-special loser
                return min(non_special_losers, key=lambda x: x[1]['value'])[0]
            else:
                # Only special cards left - play lowest special loser
                return min(special_losers, key=lambda x: x[1]['value'])[0]
                
    elif lead_suit != 'â™ ' and spades:
        # Can trump with spade
        special_spades = [(i, c) for i, c in spades if is_special_card(c)[0]]
        non_special_spades = [(i, c) for i, c in spades if not is_special_card(c)[0]]
        
        # If player has special card, trump to win it (but not with special spades)
        if player_has_special and non_special_spades:
            return min(non_special_spades, key=lambda x: x[1]['value'])[0]
        
        if made_bid:
            # Avoid trumping if possible - discard from other suits instead
            if other:
                # Prefer discarding non-special cards from other suits
                non_special_other = [(i, c) for i, c in other if not is_special_card(c)[0]]
                if non_special_other:
                    return min(non_special_other, key=lambda x: x[1]['value'])[0]
                else:
                    return min(other, key=lambda x: x[1]['value'])[0]
            elif non_special_spades:
                # Must trump - use lowest non-special spade
                return min(non_special_spades, key=lambda x: x[1]['value'])[0]
            else:
                # Only special spades - use lowest
                return min(special_spades, key=lambda x: x[1]['value'])[0]
        else:
            # Still need tricks - trump with lowest spade, prefer non-special
            if non_special_spades:
                return min(non_special_spades, key=lambda x: x[1]['value'])[0]
            else:
                return min(special_spades, key=lambda x: x[1]['value'])[0]
    else:
        # Can't follow or trump - discard lowest, protect special cards
        all_cards = [(i, c) for i, c in enumerate(computer_hand)]
        non_special_cards = [(i, c) for i, c in all_cards if not is_special_card(c)[0]]
        
        if non_special_cards:
            return min(non_special_cards, key=lambda x: x[1]['value'])[0]
        else:
            # Only special cards left - discard lowest special
            return min(all_cards, key=lambda x: x[1]['value'])[0]

def autoplay_remaining_cards(game, session_obj=None):
    """
    Check for mathematically certain scenarios and auto-resolve remaining tricks.
    Only auto-resolves when 3-9 cards remain to preserve engagement.
    Returns (was_auto_resolved, explanation)
    """
    player_hand_size = len(game['player_hand'])
    computer_hand_size = len(game['computer_hand'])
    
    # Only auto-resolve if 3-9 cards remain (don't auto-play final 1-2 tricks)
    if player_hand_size == 0 or computer_hand_size == 0:
        return False, ""
    if player_hand_size < 3 or player_hand_size > 9:
        return False, ""
    
    player_suits = set(card['suit'] for card in game['player_hand'])
    computer_suits = set(card['suit'] for card in game['computer_hand'])
    winner = game.get('trick_winner')
    
    auto_resolved = False
    explanation = ""
    tricks_to_award = 0
    
    # Case 1: One player only spades, other no spades
    if player_suits == {'â™ '} and 'â™ ' not in computer_suits:
        tricks_to_award = len(game['player_hand'])
        game['player_tricks'] += tricks_to_award
        auto_resolved = True
        explanation = f"Auto-resolved: You had only spades ({tricks_to_award} cards), Marta had none"
        winner_of_remaining = 'player'
    elif computer_suits == {'â™ '} and 'â™ ' not in player_suits:
        tricks_to_award = len(game['computer_hand'])
        game['computer_tricks'] += tricks_to_award
        auto_resolved = True
        explanation = f"Auto-resolved: Marta had only spades ({tricks_to_award} cards), you had none"
        winner_of_remaining = 'computer'
    # Case 2: Trick winner has one suit, loser has none of it and no spades
    elif winner == 'player' and len(player_suits) == 1:
        player_suit = list(player_suits)[0]
        if player_suit not in computer_suits and 'â™ ' not in computer_suits:
            tricks_to_award = len(game['player_hand'])
            game['player_tricks'] += tricks_to_award
            auto_resolved = True
            explanation = f"Auto-resolved: You had only {player_suit} ({tricks_to_award} cards), Marta had none and no spades"
            winner_of_remaining = 'player'
    elif winner == 'computer' and len(computer_suits) == 1:
        computer_suit = list(computer_suits)[0]
        if computer_suit not in player_suits and 'â™ ' not in player_suits:
            tricks_to_award = len(game['computer_hand'])
            game['computer_tricks'] += tricks_to_award
            auto_resolved = True
            explanation = f"Auto-resolved: Marta had only {computer_suit} ({tricks_to_award} cards), you had none and no spades"
            winner_of_remaining = 'computer'
    
    if auto_resolved:
        # Simulate the remaining tricks and add to history
        player_cards = game['player_hand'].copy()
        computer_cards = game['computer_hand'].copy()
        current_trick_number = len(game.get('trick_history', [])) + 1
        
        # Log console message for auto-resolution
        print(f"AUTO-RESOLVE: {explanation}")
        
        # Play out remaining tricks in any order since outcome is predetermined
        while player_cards and computer_cards:
            # Just take first card from each hand (order doesn't matter)
            player_card = player_cards.pop(0)
            computer_card = computer_cards.pop(0)
            
            # Add to trick history
            game.setdefault('trick_history', []).append({
                'number': current_trick_number,
                'player_card': player_card,
                'computer_card': computer_card,
                'winner': winner_of_remaining  # Predetermined winner
            })
            
            # Log each auto-played trick to console
            p_text = f"{player_card['rank']}{player_card['suit']}"
            c_text = f"{computer_card['rank']}{computer_card['suit']}"
            winner_name = "You" if winner_of_remaining == 'player' else "Marta"
            print(f"AUTO-TRICK {current_trick_number}: {p_text} vs {c_text} -> {winner_name} wins")
            
            current_trick_number += 1
        
        # Clear hands and mark as over
        game['player_hand'] = []
        game['computer_hand'] = []
        game['hand_over'] = True
        
        # Log the auto-resolution
        if session_obj:
            log_game_event(
                event_type='hand_auto_resolved',
                event_data={
                    'explanation': explanation,
                    'tricks_simulated': tricks_to_award,
                    'cards_remaining_when_triggered': player_hand_size,
                    'final_player_tricks': game['player_tricks'],
                    'final_computer_tricks': game['computer_tricks']
                },
                session=session_obj
            )
    
    return auto_resolved, explanation

================================================================================

FILE: ./utilities/claude_utils.py
--------------------------------------------------------------------------------
# utilities/claude_utils.py
"""
Marta AI Chat utilities for Two-Man Spades game
Marta responds to direct user chat messages as an active player in the game
"""

import os
import anthropic
from typing import Dict, Optional, Any
import logging
import json

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# For production Secret Manager
try:
    from google.cloud import secretmanager
    GOOGLE_CLOUD_AVAILABLE = True
    print("[CLAUDE] Google Cloud Secret Manager available")
except ImportError:
    GOOGLE_CLOUD_AVAILABLE = False
    print("[CLAUDE] Google Cloud Secret Manager NOT available")

# For local development
try:
    from dotenv import load_dotenv
    load_dotenv()
    print("[CLAUDE] dotenv loaded successfully")
except ImportError:
    print("[CLAUDE] dotenv NOT available")

class ClaudeGameChat:
    def __init__(self):
        print("[CLAUDE] Initializing ClaudeGameChat for Marta's responses...")
        
        self.api_key = self._get_api_key()
        if not self.api_key:
            error_msg = "ANTHROPIC_API_KEY not found in environment or Secret Manager"
            print(f"[CLAUDE] ERROR: {error_msg}")
            raise ValueError(error_msg)
        
        print(f"[CLAUDE] API key found: {self.api_key[:10]}...{self.api_key[-4:] if len(self.api_key) > 14 else 'SHORT'}")
        
        try:
            # FIXED: More aggressive timeout and better error handling
            self.client = anthropic.Anthropic(
                api_key=self.api_key,
                max_retries=1,  # Only retry once to fail faster
                timeout=10.0,   # 10 second timeout to avoid hanging
            )
            print("[CLAUDE] Anthropic client initialized successfully with fast-fail config")
        except Exception as e:
            print(f"[CLAUDE] ERROR initializing Anthropic client: {e}")
            raise e
        
        self.model = "claude-3-5-haiku-20241022"
        self.max_tokens = 150
        self.temperature = 0.8
        
        self.system_prompt = (
            "You are Marta, playing Two-Man Spades against a human opponent. "
            "You're a seasoned spades player with a poker face and sharp wit, actively competing in this match. "
            "This is a custom variant with blind bidding, and special bag-reduction cards. "
            "You can see the current game state, your opponent's played cards, scores, "
            "bidding patterns, and trick outcomes - but you cannot see cards still in your opponent's hand. "
            "IMPORTANT: You also cannot reveal anything about discard results until the hand is completely over. "
            "CRITICAL: When referencing specific cards played in tricks, be absolutely accurate about who played what. "
            "Never claim to have played a card that your opponent actually played. The context clearly shows "
            "'my_card' vs 'opponent_card' and 'outcome' descriptions. Use these to avoid factual errors. "
            "Reference specific details from what you can legitimately know: current scores, recent plays, "
            "bidding accuracy, your own strategic decisions, bag situations and trick results. "
            "Be competitive and snarky while demonstrating your game intelligence through analysis of visible information. "
            "Speak as an active player in the match, not as an outside observer. "
            "You only respond when your opponent directly talks to you - never initiate conversation."
        )
        
        print(f"[CLAUDE] Configuration:")
        print(f"  Model: {self.model}")
        print(f"  Max tokens: {self.max_tokens}")
        print(f"  Temperature: {self.temperature}")
        print(f"  Max retries: 1")
        print(f"  Timeout: 10.0 seconds")
        print(f"  System prompt length: {len(self.system_prompt)} chars")
        print(f"  Mode: Marta as active player")
    


    def get_marta_response(self, 
                        player_message: str, 
                        game_context: Optional[Dict[str, Any]] = None) -> str:
        """Get a response from Marta as an active player in the game"""
        print(f"\n[CLAUDE] === MARTA CHAT REQUEST ===")
        print(f"[CLAUDE] Opponent message: '{player_message}'")
        print(f"[CLAUDE] Game context received: {bool(game_context)}")
        
        if game_context:
            print(f"[CLAUDE] Context keys count: {len(game_context.keys())}")
            print(f"[CLAUDE] Context keys: {list(game_context.keys())}")
        
        # SECRET DEBUG: Check for magic phrase and extract hand info
        secret_hand_reveal = ""
        magic_phrase_detected = False
        
        if "abra cadabra" in player_message.lower() and game_context:
            print(f"[CLAUDE] MAGIC PHRASE DETECTED! Preparing to reveal Marta's hand...")
            
            computer_hand = game_context.get('computer_hand', [])
            if computer_hand:
                hand_cards = []
                for card in computer_hand:
                    if isinstance(card, dict) and 'rank' in card and 'suit' in card:
                        hand_cards.append(f"{card['rank']}{card['suit']}")
                
                if hand_cards:
                    cards_str = ", ".join(hand_cards)
                    secret_hand_reveal = f"[SECRET_DEBUG_ACTIVATED: My actual hand is {cards_str}] "
                    magic_phrase_detected = True
                    print(f"[CLAUDE] Secret hand info prepared: {cards_str}")
        
        try:
            context_str = self._build_marta_visible_context(game_context)
            if not context_str or context_str == "[MY_VISIBLE_GAME_STATE: JSON conversion failed] ":
                print(f"[CLAUDE] Context building failed, using fallback")
                return self._fallback_marta_response(game_context)
            
            print(f"[CLAUDE] Built Marta's visible context successfully")
            
            # Enhanced user prompt that handles both normal and secret responses
            if magic_phrase_detected:
                user_prompt = (
                    f"{context_str}{secret_hand_reveal}"
                    f"My opponent said: '{player_message}'\n\n"
                    f"SPECIAL INSTRUCTION: The player used the secret phrase 'abra cadabra'! "
                    f"Start your response with something like 'Well well, you found my secret! Here are my cards: [list all the cards from SECRET_DEBUG_ACTIVATED]. "
                    f"Don't tell anyone I showed you!' Then continue with your normal competitive, snarky response about the game. "
                    f"Reference specific details from what you can legitimately see in the current game state."
                )
                print(f"[CLAUDE] Using SECRET REVEAL prompt mode")
            else:
                user_prompt = (
                    f"{context_str}"
                    f"My opponent said: '{player_message}'\n\n"
                    f"Respond as Marta with a competitive, game-aware comment (2-3 sentences) that references specific details "
                    f"from what I can legitimately see in the current game state. Mention relevant aspects like scores, "
                    f"recent cards played, bidding situation, bags, trick history, or strategic implications "
                    f"that are visible to me as a player. Show my tactical awareness and competitive intelligence while "
                    f"maintaining my snarky, poker-faced personality. Remember: I'm actively playing against this opponent."
                )
            
            print(f"[CLAUDE] Prompt length: {len(user_prompt)} chars")
            print(f"[CLAUDE] Making API call to {self.model}...")
            
            response = self.client.messages.create(
                model=self.model,
                max_tokens=self.max_tokens,
                temperature=self.temperature,
                system=self.system_prompt,
                messages=[{
                    "role": "user", 
                    "content": user_prompt
                }]
            )
            
            print(f"[CLAUDE] API call successful!")
            
            api_response = response.content[0].text.strip()
            print(f"[CLAUDE] Raw API response: '{api_response}'")
            print(f"[CLAUDE] Response length: {len(api_response)} chars")
            
            if magic_phrase_detected:
                print(f"[CLAUDE] SECRET REVEAL response delivered!")
            
            if not api_response:
                print(f"[CLAUDE] WARNING: Empty response from API")
                return self._fallback_marta_response(game_context)
            
            print(f"[CLAUDE] SUCCESS: Returning Marta's response")
            return api_response
            
        except anthropic.APITimeoutError as e:
            print(f"[CLAUDE] API Timeout Error after 10s: {e}")
            fallback = self._fallback_marta_response(game_context)
            print(f"[CLAUDE] Using timeout fallback: '{fallback}'")
            return fallback
            
        except anthropic.RateLimitError as e:
            print(f"[CLAUDE] Rate Limit Error: {e}")
            retry_after = getattr(e.response, 'headers', {}).get('retry-after', 'unknown')
            print(f"[CLAUDE] Retry-after header: {retry_after}")
            fallback = self._fallback_marta_response(game_context)
            print(f"[CLAUDE] Using rate limit fallback: '{fallback}'")
            return fallback
            
        except anthropic.APIConnectionError as e:
            print(f"[CLAUDE] Connection Error: {e}")
            fallback = self._fallback_marta_response(game_context)
            print(f"[CLAUDE] Using connection error fallback: '{fallback}'")
            return fallback
            
        except anthropic.APIError as e:
            print(f"[CLAUDE] General API Error: {e}")
            print(f"[CLAUDE] Error type: {type(e)}")
            if hasattr(e, 'status_code'):
                print(f"[CLAUDE] Status code: {e.status_code}")
            fallback = self._fallback_marta_response(game_context)
            print(f"[CLAUDE] Using API error fallback: '{fallback}'")
            return fallback
            
        except Exception as e:
            print(f"[CLAUDE] Unexpected error: {e}")
            print(f"[CLAUDE] Error type: {type(e)}")
            fallback = self._fallback_marta_response(game_context)
            print(f"[CLAUDE] Using general error fallback: '{fallback}'")
            return fallback

    def _build_marta_visible_context(self, game_context: Optional[Dict[str, Any]]) -> str:
        """Build context showing only what Marta can legitimately see during play"""
        print(f"[CLAUDE] Building Marta's visible context...")
        
        if not game_context:
            print(f"[CLAUDE] No game context provided")
            return "[MY_VISIBLE_GAME_STATE: No context available] "
        
        print(f"[CLAUDE] Processing {len(game_context)} context keys...")
        
        # Create Marta's visible context (exclude her hidden hand AND secret discard info)
        marta_visible_context = {}
        
        for key, value in game_context.items():
            print(f"[CLAUDE] Processing key: {key} (type: {type(value).__name__})")
            
            # Skip internal/hidden information
            excluded_keys = {
                'computer_hand', 'client_info', 'game_id', 'show_computer_hand', 
                'current_hand_id', 'game_started_at', 'action_sequence', 'trick_display_timer'
            }
            
            # Check if we should exclude discard information
            hand_is_over = game_context.get('hand_over', False)
            if not hand_is_over:
                excluded_keys.update({
                    'discard_bonus_explanation',
                    'pending_discard_result', 'pending_special_discard_result'
                })
            
            if key in excluded_keys:
                print(f"[CLAUDE] Excluding key: {key}")
                continue
                
            # Convert and rename from Marta's perspective with safe handling
            try:
                if key == 'player_hand' and isinstance(value, list):
                    # Marta can only see count, not actual cards in opponent's hand
                    marta_visible_context['opponent_hand_size'] = len(value)
                    print(f"[CLAUDE] Converted player_hand to opponent_hand_size: {len(value)}")
                elif key == 'computer_hand_count':
                    marta_visible_context['my_hand_size'] = value
                    print(f"[CLAUDE] Set my_hand_size: {value}")
                elif key == 'current_trick' and isinstance(value, list):
                    converted_trick = []
                    for play in value:
                        if isinstance(play, dict) and 'card' in play:
                            card = play['card']
                            if isinstance(card, dict) and 'rank' in card and 'suit' in card:
                                card_str = f"{card['rank']}{card['suit']}"
                                if play['player'] == 'computer':
                                    converted_trick.append({
                                        'player': 'me',
                                        'card': card_str,
                                        'card_details': f"I played {card_str}"
                                    })
                                else:
                                    converted_trick.append({
                                        'player': 'opponent',
                                        'card': card_str,
                                        'card_details': f"Opponent played {card_str}"
                                    })
                    marta_visible_context[key] = converted_trick
                    print(f"[CLAUDE] Converted current_trick: {len(converted_trick)} plays")
                elif key == 'trick_history' and isinstance(value, list):
                    converted_history = []
                    for trick in value:
                        if isinstance(trick, dict):
                            converted_trick = {
                                'number': trick.get('number'),
                                'winner': 'me' if trick.get('winner') == 'computer' else 'opponent'
                            }
                            
                            # CRITICAL: Clearly identify who played which card
                            my_card = None
                            opponent_card = None
                            
                            if trick.get('computer_card') and isinstance(trick['computer_card'], dict):
                                card = trick['computer_card']
                                if 'rank' in card and 'suit' in card:
                                    my_card = f"{card['rank']}{card['suit']}"
                                    converted_trick['my_card'] = my_card
                                    
                            if trick.get('player_card') and isinstance(trick['player_card'], dict):
                                card = trick['player_card']
                                if 'rank' in card and 'suit' in card:
                                    opponent_card = f"{card['rank']}{card['suit']}"
                                    converted_trick['opponent_card'] = opponent_card
                            
                            # Add explicit play description to prevent confusion
                            if my_card and opponent_card:
                                converted_trick['play_summary'] = f"I played {my_card}, opponent played {opponent_card}"
                                if converted_trick['winner'] == 'me':
                                    converted_trick['outcome'] = f"I won with my {my_card} beating opponent's {opponent_card}"
                                else:
                                    converted_trick['outcome'] = f"Opponent won with their {opponent_card} beating my {my_card}"
                            
                            converted_history.append(converted_trick)
                            
                    marta_visible_context[key] = converted_history
                    print(f"[CLAUDE] Converted trick_history: {len(converted_history)} tricks")
                # Handle discard cards ONLY if hand is over AND they exist
                elif key == 'player_discarded' and value and hand_is_over:
                    if isinstance(value, dict) and 'rank' in value and 'suit' in value:
                        opponent_discard = f"{value['rank']}{value['suit']}"
                        marta_visible_context['opponent_discarded'] = opponent_discard
                        marta_visible_context['opponent_discard_details'] = f"Opponent discarded {opponent_discard}"
                        print(f"[CLAUDE] Converted player_discarded to opponent_discarded")
                elif key == 'computer_discarded' and value and hand_is_over:
                    if isinstance(value, dict) and 'rank' in value and 'suit' in value:
                        my_discard = f"{value['rank']}{value['suit']}"
                        marta_visible_context['my_discarded'] = my_discard
                        marta_visible_context['my_discard_details'] = f"I discarded {my_discard}"
                        print(f"[CLAUDE] Converted computer_discarded to my_discarded")
                elif key.startswith('player_'):
                    # Rename player stats to opponent stats for Marta's perspective
                    new_key = key.replace('player_', 'opponent_')
                    marta_visible_context[new_key] = value
                    print(f"[CLAUDE] Renamed {key} to {new_key}")
                elif key.startswith('computer_'):
                    # Rename computer stats to my stats for Marta's perspective
                    new_key = key.replace('computer_', 'my_')
                    marta_visible_context[new_key] = value
                    print(f"[CLAUDE] Renamed {key} to {new_key}")
                elif key == 'player_parity':
                    marta_visible_context['opponent_parity'] = value
                elif key == 'computer_parity':
                    marta_visible_context['my_parity'] = value
                elif key == 'player_name':
                    marta_visible_context['opponent_name'] = value
                elif key == 'computer_name':
                    marta_visible_context['my_name'] = value
                elif key == 'turn':
                    # Convert turn to Marta's perspective
                    if value == 'computer':
                        marta_visible_context[key] = 'my_turn'
                    elif value == 'player':
                        marta_visible_context[key] = 'opponent_turn'
                    else:
                        marta_visible_context[key] = value
                elif key == 'trick_leader':
                    # Convert trick leader to Marta's perspective
                    if value == 'computer':
                        marta_visible_context[key] = 'me'
                    elif value == 'player':
                        marta_visible_context[key] = 'opponent'
                    else:
                        marta_visible_context[key] = value
                elif key == 'first_leader':
                    # Convert first leader to Marta's perspective
                    if value == 'computer':
                        marta_visible_context[key] = 'me'
                    elif value == 'player':
                        marta_visible_context[key] = 'opponent'
                    else:
                        marta_visible_context[key] = value
                elif key == 'winner':
                    # Convert winner to Marta's perspective
                    if value == 'computer':
                        marta_visible_context[key] = 'me'
                    elif value == 'player':
                        marta_visible_context[key] = 'opponent'
                    else:
                        marta_visible_context[key] = value
                else:
                    # Keep other fields as-is (but exclude discard explanation during active play)
                    if key == 'discard_bonus_explanation' and not hand_is_over:
                        print(f"[CLAUDE] Excluding discard_bonus_explanation (hand not over)")
                        continue
                    # Only include serializable values
                    if isinstance(value, (str, int, float, bool, type(None))):
                        marta_visible_context[key] = value
                        print(f"[CLAUDE] Kept simple value: {key}")
                    else:
                        print(f"[CLAUDE] Skipping complex value: {key} (type: {type(value).__name__})")
                        
            except Exception as e:
                print(f"[CLAUDE] Error processing key {key}: {e}")
                continue
        
        # Rest of the function remains the same...
        print(f"[CLAUDE] Final context keys: {list(marta_visible_context.keys())}")
        
        # Test JSON conversion with detailed error handling
        try:
            context_json = json.dumps(marta_visible_context, separators=(',', ':'))
            print(f"[CLAUDE] JSON conversion successful, length: {len(context_json)} chars")
        except Exception as e:
            print(f"[CLAUDE] JSON conversion FAILED: {e}")
            return "[MY_VISIBLE_GAME_STATE: JSON conversion failed] "
        
        final_context = f"[MY_VISIBLE_GAME_STATE: {context_json}] "
        print(f"[CLAUDE] Final context length: {len(final_context)} chars")
        return final_context
    
    def _fallback_marta_response(self, game_context: Optional[Dict[str, Any]]) -> str:
        """Game-aware fallback responses from Marta's perspective as active player"""
        print(f"[CLAUDE] Generating Marta's fallback response...")
        
        if not game_context:
            fallbacks = [
                "Interesting question...",
                "You're keeping me on my toes.",
                "That's one way to look at it."
            ]
            import random
            selected = random.choice(fallbacks)
            print(f"[CLAUDE] No context fallback: '{selected}'")
            return selected
        
        # Try to make contextual fallbacks from Marta's perspective
        try:
            my_score = game_context.get('computer_score', 0)  # Marta's score
            opponent_score = game_context.get('player_score', 0)  # Player's score
            phase = game_context.get('phase', 'unknown')
            hand_number = game_context.get('hand_number', 1)
            
            contextual_fallbacks = []
            
            # Score-based fallbacks from Marta's perspective
            if my_score > opponent_score:
                contextual_fallbacks.append(f"I'm up by {my_score - opponent_score} points. Feeling good about this.")
            elif opponent_score > my_score:
                contextual_fallbacks.append(f"You're ahead by {opponent_score - my_score}, but I'm not worried.")
            else:
                contextual_fallbacks.append("We're tied up - makes this interesting.")
            
            # Phase-based fallbacks
            if phase == 'bidding':
                contextual_fallbacks.append("Think carefully about that bid.")
            elif phase == 'playing':
                contextual_fallbacks.append("Your move. Choose wisely.")
            elif phase == 'discard':
                contextual_fallbacks.append("That discard better be strategic.")
            
            # Hand progression fallbacks
            if hand_number > 1:
                contextual_fallbacks.append(f"Hand {hand_number} already? Time's flying.")
            
            if contextual_fallbacks:
                import random
                selected = random.choice(contextual_fallbacks)
                print(f"[CLAUDE] Contextual Marta fallback: '{selected}'")
                return selected
                
        except Exception as e:
            print(f"[CLAUDE] Error creating contextual fallback: {e}")
        
        # Default fallbacks if context parsing fails
        generic_fallbacks = [
            "Fair point.",
            "We'll see how that plays out.",
            "Keeping my cards close to my chest.",
            "Game's not over yet.",
            "Interesting perspective.",
            "That's a bold strategy."
        ]
        
        import random
        selected = random.choice(generic_fallbacks)
        print(f"[CLAUDE] Generic Marta fallback: '{selected}'")
        return selected
    
    def _get_api_key(self) -> Optional[str]:
        """Get API key from environment or Secret Manager with detailed logging"""
        print(f"[CLAUDE] === API KEY DETECTION ===")
        
        # First try environment variable
        api_key = os.getenv('ANTHROPIC_API_KEY')
        if api_key:
            print(f"[CLAUDE] Found API key in environment variable")
            print(f"[CLAUDE] Key length: {len(api_key)} chars")
            print(f"[CLAUDE] Key starts with: {api_key[:10]}...")
            return api_key
        
        print(f"[CLAUDE] No API key in environment variable")
        
        # Check if we're in Google Cloud
        is_gcp = self._is_google_cloud_environment()
        print(f"[CLAUDE] Running in Google Cloud: {is_gcp}")
        
        if is_gcp:
            print(f"[CLAUDE] Attempting to get key from Secret Manager...")
            return self._get_secret_from_manager()
        
        print(f"[CLAUDE] Not in Google Cloud environment")
        print(f"[CLAUDE] No API key source available")
        return None
    
    def _is_google_cloud_environment(self) -> bool:
        """Detect if we're running in Google Cloud with logging"""
        gae_env = os.getenv('GAE_ENV')
        k_service = os.getenv('K_SERVICE')
        gcp_project = os.getenv('GOOGLE_CLOUD_PROJECT')
        
        print(f"[CLAUDE] Environment check:")
        print(f"  GAE_ENV: {gae_env}")
        print(f"  K_SERVICE: {k_service}")
        print(f"  GOOGLE_CLOUD_PROJECT: {gcp_project}")
        
        is_gcp = (
            gae_env == 'standard' or
            k_service is not None or
            gcp_project is not None
        )
        
        print(f"[CLAUDE] Is Google Cloud: {is_gcp}")
        return is_gcp
    
    def _get_secret_from_manager(self) -> Optional[str]:
        """Get API key from Google Secret Manager with detailed logging"""
        print(f"[CLAUDE] === SECRET MANAGER ACCESS ===")
        
        if not GOOGLE_CLOUD_AVAILABLE:
            print(f"[CLAUDE] ERROR: Google Cloud libraries not available")
            return None
        
        try:
            project_id = os.getenv('GOOGLE_CLOUD_PROJECT')
            print(f"[CLAUDE] Project ID: {project_id}")
            
            if not project_id:
                print(f"[CLAUDE] ERROR: GOOGLE_CLOUD_PROJECT not set")
                return None
            
            print(f"[CLAUDE] Creating Secret Manager client...")
            client = secretmanager.SecretManagerServiceClient()
            
            secret_name = f"projects/{project_id}/secrets/ANTHROPIC_API_KEY/versions/latest"
            print(f"[CLAUDE] Secret path: {secret_name}")
            
            print(f"[CLAUDE] Accessing secret...")
            response = client.access_secret_version(request={"name": secret_name})
            
            secret_value = response.payload.data.decode("UTF-8")
            print(f"[CLAUDE] Secret retrieved successfully")
            print(f"[CLAUDE] Secret length: {len(secret_value)} chars")
            print(f"[CLAUDE] Secret starts with: {secret_value[:10]}...")
            
            return secret_value
            
        except Exception as e:
            print(f"[CLAUDE] ERROR accessing Secret Manager: {e}")
            print(f"[CLAUDE] Error type: {type(e)}")
            return None

# Singleton instance
_claude_chat = None

def get_claude_chat() -> ClaudeGameChat:
    """Get singleton Claude chat instance for Marta responses"""
    global _claude_chat
    if _claude_chat is None:
        print("[CLAUDE] Creating new ClaudeGameChat singleton instance (Marta as player)")
        _claude_chat = ClaudeGameChat()
    else:
        print("[CLAUDE] Using existing ClaudeGameChat singleton (Marta as player)")
    return _claude_chat

def get_smart_marta_response(player_message: str, game_state: Dict[str, Any]) -> str:
    """Convenience function to get Marta's response as active player"""
    print(f"[CLAUDE] get_smart_marta_response called (Marta as active player)")
    print(f"[CLAUDE] Opponent message: '{player_message}'")
    print(f"[CLAUDE] Game state keys: {list(game_state.keys()) if game_state else 'None'}")
    
    claude = get_claude_chat()
    response = claude.get_marta_response(player_message, game_state)
    
    print(f"[CLAUDE] Final Marta response: '{response}'")
    return response

# Test function for debugging
def test_claude_connection():
    """Test function to verify Claude API connectivity with Marta as player"""
    print(f"[CLAUDE] === TESTING CLAUDE CONNECTION (MARTA AS PLAYER) ===")
    
    try:
        claude = get_claude_chat()
        
        # Test with rich game context - simulating opponent asking about game state
        test_context = {
            'hand_number': 2,
            'phase': 'playing',
            'player_score': 89,  # Opponent's score
            'computer_score': 127,  # Marta's score
            'player_bid': 4,  # Opponent's bid
            'computer_bid': 6,  # Marta's bid
            'player_tricks': 2,  # Opponent's tricks
            'computer_tricks': 3,  # Marta's tricks
            'player_bags': 1,  # Opponent's bags
            'computer_bags': 0,  # Marta's bags
            'hand_over': False,  # Hand still in progress - no discard info
            'trick_history': [
                {'number': 1, 'player_card': {'rank': '7', 'suit': 'â™£'}, 'computer_card': {'rank': 'A', 'suit': 'â™£'}, 'winner': 'computer'},
                {'number': 2, 'player_card': {'rank': 'K', 'suit': 'â™ '}, 'computer_card': {'rank': 'Q', 'suit': 'â™ '}, 'winner': 'player'}
            ]
        }
        
        test_response = claude.get_marta_response("How do you think this hand is going?", test_context)
        print(f"[CLAUDE] Marta player test successful: '{test_response}'")
        return True, test_response
    except Exception as e:
        print(f"[CLAUDE] Marta player test failed: {e}")
        return False, str(e)

if __name__ == "__main__":
    # Run test when script is executed directly
    success, result = test_claude_connection()
    print(f"Marta player test result: {success} - {result}")

================================================================================

FILE: ./utilities/logging_utils.py
--------------------------------------------------------------------------------
"""
Streamlined logging utilities for Two-Man Spades - WRITE-ONLY approach with ASYNC database operations
Logs everything for historical analysis but NEVER reads/loads existing files during normal operation
All logging is append-only for performance - reading is only available via explicit debug endpoints
Database operations are now fully asynchronous and non-blocking for instant game responses
"""
import time
import uuid
import json
import os
import platform
from datetime import datetime
import threading
import queue

# =============================================================================
# GLOBAL LOGGING CONFIGURATION
# =============================================================================

# Environment detection
IS_LOCAL_DEVELOPMENT = os.environ.get('GAE_ENV') != 'standard'
IS_PRODUCTION = not IS_LOCAL_DEVELOPMENT

LOGGING_ENABLED = True
LOG_TO_CONSOLE = True
LOG_TO_FILE = IS_LOCAL_DEVELOPMENT
LOG_GAME_ACTIONS = True
LOG_AI_DECISIONS = True
LOG_AI_ANALYSIS = True
LOG_GAME_EVENTS = True
CONSOLE_LOG_LEVEL = 'ALL'  # 'ALL', 'ACTIONS_ONLY', 'AI_ONLY', 'EVENTS_ONLY', 'OFF'
LOGS_DIRECTORY = 'logging' if IS_LOCAL_DEVELOPMENT else None
CURRENT_LOG_FILE = None

# Production logging placeholder
PRODUCTION_LOG_PLACEHOLDER = "[PRODUCTION] Log entry saved to pending database implementation"

# =============================================================================
# ASYNC DATABASE LOGGING SYSTEM
# =============================================================================

# Global async logging system
_db_queue = queue.Queue(maxsize=1000)  # Limit queue size to prevent memory issues
_db_worker_thread = None
_db_worker_running = False
_db_operations_completed = 0
_db_operations_failed = 0

def start_async_db_logging():
    """Start background database logging thread"""
    global _db_worker_thread, _db_worker_running
    
    if not IS_PRODUCTION or _db_worker_running:
        return
    
    _db_worker_running = True
    _db_worker_thread = threading.Thread(target=_db_worker, daemon=True)
    _db_worker_thread.start()
    print("[DB] Async logging started")

def _db_worker():
    """Background worker that processes database operations"""
    global _db_operations_completed, _db_operations_failed
    
    while _db_worker_running:
        try:
            # Wait up to 1 second for an operation
            operation = _db_queue.get(timeout=1.0)
            
            if operation is None:  # Shutdown signal
                break
            
            # Execute the database operation
            try:
                result = operation['func'](*operation['args'], **operation['kwargs'])
                if result:
                    _db_operations_completed += 1
                else:
                    _db_operations_failed += 1
            except Exception as e:
                _db_operations_failed += 1
                print(f"[DB] Async operation failed: {e}")
            finally:
                _db_queue.task_done()
                
        except queue.Empty:
            continue  # No operations pending, keep waiting
        except Exception as e:
            print(f"[DB] Worker error: {e}")

def queue_db_operation(func, *args, **kwargs):
    """Queue a database operation for background processing"""
    if not IS_PRODUCTION:
        print(f"[DB] Skipping queue operation - not in production")
        return
    
    if not _db_worker_running:
        print(f"[DB] ERROR: Worker not running, cannot queue operation")
        return
    
    try:
        operation = {
            'func': func,
            'args': args,
            'kwargs': kwargs,
            'queued_at': time.time()
        }
        _db_queue.put_nowait(operation)
        print(f"[DB] Queued operation: {func.__name__} (queue size: {_db_queue.qsize()})")
    except queue.Full:
        print("[DB] Queue full, dropping operation")
        global _db_operations_failed
        _db_operations_failed += 1

def stop_async_db_logging():
    """Stop the background logging thread"""
    global _db_worker_running
    _db_worker_running = False
    _db_queue.put(None)  # Shutdown signal
    
    if _db_worker_thread:
        _db_worker_thread.join(timeout=5.0)
    
    print(f"[DB] Async logging stopped. Completed: {_db_operations_completed}, Failed: {_db_operations_failed}")

def get_async_db_stats():
    """Get statistics about async database operations"""
    return {
        'queue_size': _db_queue.qsize(),
        'operations_completed': _db_operations_completed,
        'operations_failed': _db_operations_failed,
        'worker_running': _db_worker_running
    }

# =============================================================================
# CLIENT IP TRACKING FUNCTIONS
# =============================================================================

def get_client_ip(request):
    """Get the client's real IP address, preferring IPv4 when available from the same client."""
    
    # Get all potential IPs from various headers
    potential_ips = []
    
    # Check X-Forwarded-For (most common)
    forwarded = request.headers.get('X-Forwarded-For')
    if forwarded:
        potential_ips.extend([ip.strip() for ip in forwarded.split(',')])
    
    # Check other common headers
    for header in ['X-Real-IP', 'X-Client-IP']:
        ip = request.headers.get(header)
        if ip:
            potential_ips.append(ip.strip())
    
    # Add the direct connection IP
    if request.remote_addr:
        potential_ips.append(request.remote_addr)
    
    if not potential_ips:
        return 'unknown'
    
    # Filter out obviously internal/load balancer IPs
    filtered_ips = []
    for ip in potential_ips:
        # Skip Google/AWS internal IPs and private ranges
        if not ip.startswith(('169.254.', '10.', '192.168.', '172.', '127.')):
            filtered_ips.append(ip)
    
    if not filtered_ips:
        # If all IPs were filtered, use the first original IP
        return potential_ips[0]
    
    # Prefer IPv4 from the filtered list
    ipv4_ips = [ip for ip in filtered_ips if '.' in ip and ':' not in ip]
    if ipv4_ips:
        return ipv4_ips[0]
    
    # Fall back to first filtered IP (likely IPv6)
    return filtered_ips[0]

def get_client_info(request):
    """Get comprehensive client information for logging."""
    client_ip = get_client_ip(request)
    
    return {
        'ip_address': client_ip,
        'user_agent': request.headers.get('User-Agent', 'unknown'),
        'referer': request.headers.get('Referer', 'none'),
        'method': request.method,
        'endpoint': request.endpoint,
        'is_local': client_ip.startswith('127.') or client_ip.startswith('192.168.') or client_ip == 'localhost'
    }

def track_session_client(session, request):
    """Track client info in session for persistent identification."""
    client_info = get_client_info(request)
    
    session_client = {
        'ip_address': client_info['ip_address'],
        'first_seen': session.get('client_first_seen', time.time()),
        'last_seen': time.time(),
        'session_actions': session.get('client_actions', 0) + 1
    }
    
    session['client_info'] = session_client
    session['client_actions'] = session_client['session_actions'] 
    session['client_first_seen'] = session_client['first_seen']
    session.modified = True
    
    return session_client

def get_session_client_summary(session):
    """Get summary of client activity for this session."""
    client_info = session.get('client_info', {})
    
    if client_info:
        session_duration = time.time() - session.get('client_first_seen', time.time())
        return {
            'ip_address': client_info.get('ip_address', 'unknown'),
            'actions_this_session': session.get('client_actions', 0),
            'session_duration_minutes': round(session_duration / 60, 1),
            'first_seen': datetime.fromtimestamp(session.get('client_first_seen', 0)).strftime('%H:%M:%S')
        }
    
    return None

# =============================================================================
# FILE MANAGEMENT FUNCTIONS - WRITE ONLY
# =============================================================================

def _ensure_logs_directory():
    """Ensure the logging directory exists - only in local development, no scanning"""
    if not IS_LOCAL_DEVELOPMENT:
        return
        
    if LOGS_DIRECTORY and not os.path.exists(LOGS_DIRECTORY):
        os.makedirs(LOGS_DIRECTORY)

def _generate_log_filename(game_id, timestamp=None):
    """Generate a unique log filename for a game - only used in local development"""
    if not IS_LOCAL_DEVELOPMENT:
        return None
        
    if timestamp is None:
        timestamp = datetime.now()
    
    date_str = timestamp.strftime("%Y%m%d")
    time_str = timestamp.strftime("%H%M%S")
    short_game_id = game_id[:8] if game_id else "unknown"
    
    return f"game_log_{date_str}_{time_str}_{short_game_id}.json"

def _start_new_log_file(game_id):
    """Start a new log file for a game - WRITE ONLY, no existing file checking"""
    global CURRENT_LOG_FILE
    
    if not IS_LOCAL_DEVELOPMENT:
        return
    
    if not LOG_TO_FILE:
        return
    
    _ensure_logs_directory()  # Only creates if missing, no scanning
    
    filename = _generate_log_filename(game_id)
    CURRENT_LOG_FILE = os.path.join(LOGS_DIRECTORY, filename)
    
    # Initialize with game metadata
    initial_entry = {
        'log_type': 'game_metadata',
        'data': {
            'game_id': game_id,
            'log_file_created': datetime.now().isoformat(),
            'log_version': '2.0',
            'game_type': 'two_man_spades',
            'environment': 'local_development'
        }
    }
    
    try:
        # Write initial entry - no reading of existing files
        with open(CURRENT_LOG_FILE, 'w') as f:
            json.dump([initial_entry], f, indent=2, default=str)
        
        if LOG_TO_CONSOLE:
            print(f"Started new game log: {filename}")
        
    except Exception as e:
        if LOG_TO_CONSOLE:
            print(f"Warning: Could not create new log file: {e}")
        CURRENT_LOG_FILE = None

def _write_to_current_log_file(log_entry):
    """Write log entry to current game's log file - APPEND ONLY"""
    if not IS_LOCAL_DEVELOPMENT or not LOG_TO_FILE or not CURRENT_LOG_FILE:
        return
    
    try:
        # APPEND-ONLY approach - read existing, append new, write back
        logs = []
        if os.path.exists(CURRENT_LOG_FILE):
            try:
                with open(CURRENT_LOG_FILE, 'r') as f:
                    logs = json.load(f)
            except (json.JSONDecodeError, IOError):
                logs = []  # Start fresh if file is corrupted
        
        logs.append(log_entry)
        
        with open(CURRENT_LOG_FILE, 'w') as f:
            json.dump(logs, f, indent=2, default=str)
            
    except Exception as e:
        if LOG_TO_CONSOLE:
            print(f"Warning: Could not write to log file: {e}")

def _finalize_current_log_file(final_game_state):
    """Add final game metadata and close current log file"""
    if not IS_LOCAL_DEVELOPMENT or not CURRENT_LOG_FILE:
        return
        
    finalization_entry = {
        'log_type': 'game_finalization',
        'data': {
            'game_completed_at': datetime.now().isoformat(),
            'final_scores': {
                'player_score': final_game_state.get('player_score', 0),
                'computer_score': final_game_state.get('computer_score', 0)
            },
            'winner': final_game_state.get('winner'),
            'hands_played': final_game_state.get('hand_number', 1),
            'environment': 'local_development'
        }
    }
    
    _write_to_current_log_file(finalization_entry)
    
    if LOG_TO_CONSOLE:
        print(f"Finalized game log: {os.path.basename(CURRENT_LOG_FILE)}")

# =============================================================================
# GAME INITIALIZATION - STREAMLINED
# =============================================================================

def initialize_game_logging(game):
    """Initialize logging structures and start new log file for a new game - NO FILE SCANNING"""
    import random
    
    # Generate truly unique game ID using timestamp + random component
    timestamp_part = str(int(time.time() * 1000))  # milliseconds for better precision
    random_part = str(random.randint(1000, 9999))
    game_id = f"{timestamp_part}{random_part}"
    
    # Generate unique hand ID
    hand_id = str(uuid.uuid4())
    
    # Update game state with logging metadata
    game.update({
        'game_id': game_id,
        'current_hand_id': hand_id,
        'game_started_at': time.time(),
        'action_sequence': 0
    })
    
    # Start new log file (development only) - NO scanning of existing files
    _start_new_log_file(game_id)
    
    # Log game initialization to file
    _write_to_current_log_file({
        'log_type': 'game_init',
        'data': {
            'game_id': game_id,
            'started_at': time.time(),
            'player_parity': game.get('player_parity'),
            'computer_parity': game.get('computer_parity'),
            'first_leader': game.get('first_leader')
        }
    })
    
    return game

def initialize_game_logging_with_client(game, request=None):
    """Enhanced game initialization with client tracking and async database logging"""
    game = initialize_game_logging(game)
    
    # Add batching system
    game = initialize_event_batching(game)
    
    if request:
        client_info = get_client_info(request)
        game['client_info'] = client_info
        
        # Console output only
        if LOG_TO_CONSOLE:
            print(f"NEW GAME STARTED by {client_info['ip_address']}")
            print(f"   Game ID: {game.get('game_id', 'unknown')}")
    
    # NEW: Async database logging for production
    if IS_PRODUCTION:
        queue_db_operation(
            _create_game_with_player_async,
            game,
            game.get('client_info')
        )
    
    return game

def _create_game_with_player_async(game, client_info):
    """Async wrapper for database game creation"""
    try:
        print(f"[DB] Attempting to create game: {game.get('game_id')}")
        from .postgres_utils import create_game_with_player
        
        # Add more detailed logging
        print(f"[DB] Game data: game_id={game.get('game_id')}, started_at={game.get('game_started_at')}")
        print(f"[DB] Client info: {client_info}")
        
        success = create_game_with_player(game, client_info)
        if success:
            print(f"[DB] Game {game.get('game_id')} inserted to database")
        else:
            print(f"[DB] Game {game.get('game_id')} failed to insert to database")
        return success
    except Exception as e:
        print(f"[DB] Database game insertion failed: {e}")
        import traceback
        traceback.print_exc()
        return False

def finalize_game_logging(game):
    """Called when a game ends to finalize the log file and database"""
    # File logging finalization
    _finalize_current_log_file(game)
    
    # NEW: Async database game finalization (production)
    if IS_PRODUCTION:
        queue_db_operation(
            _finalize_game_async,
            game.get('game_id'),
            game
        )

def _finalize_game_async(game_id, game):
    """Async wrapper for database game finalization"""
    try:
        from .postgres_utils import finalize_game
        success = finalize_game(game_id, game)
        if success:
            print(f"[DB] Game {game_id} finalized in database")
        else:
            print(f"[DB] Game {game_id} failed to finalize in database")
        return success
    except Exception as e:
        print(f"[DB] Database game finalization failed: {e}")
        return False

def start_new_hand_logging(game):
    """Generate new hand ID and log hand start"""
    hand_id = str(uuid.uuid4())
    game['current_hand_id'] = hand_id

# =============================================================================
# CORE LOGGING FUNCTIONS - NOW WITH ASYNC DATABASE OPERATIONS
# =============================================================================

def log_action(action_type, player, action_data, session=None, additional_context=None, request=None):
    """Central logging function for all player/system game actions with ASYNC database integration"""
    if not LOGGING_ENABLED or not LOG_GAME_ACTIONS:
        return
    
    client_info = get_client_info(request) if request else None
    action_record = _build_action_record(action_type, player, action_data, session, additional_context)
    
    if client_info:
        action_record['client_info'] = client_info
    
    # File logging (development) - synchronous, fast
    _write_to_current_log_file({
        'log_type': 'action',
        'data': action_record
    })
    
    # NEW: Async database logging (production) - non-blocking
    if IS_PRODUCTION and session and 'game' in session:
        game = session['game']
        queue_db_operation(
            _log_game_event_to_db_async,
            game.get('game_id'),
            f"action_{action_type}",
            {
                'player': player,
                'action_data': action_data,
                'additional_context': additional_context
            },
            hand_number=game.get('hand_number'),
            session_sequence=game.get('action_sequence'),
            player=player,
            action_type=action_type
        )
    
    # Console logging - synchronous, fast
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'ACTIONS_ONLY']:
        _print_action_log(action_record)

def log_ai_decision(decision_type, decision_data, analysis=None, reasoning=None, session=None):
    """Central logging function for AI decision-making process"""
    if not LOGGING_ENABLED or not LOG_AI_DECISIONS:
        return
    
    decision_record = _build_ai_decision_record(decision_type, decision_data, analysis, reasoning)
    
    _write_to_current_log_file({
        'log_type': 'ai_decision',
        'data': decision_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'AI_ONLY']:
        _print_ai_decision_log(decision_record)

def log_game_event(event_type, event_data, session=None):
    """Central logging function for major game events with ASYNC database integration"""
    if not LOGGING_ENABLED or not LOG_GAME_EVENTS:
        return
    
    event_record = _build_event_record(event_type, event_data, session)
    
    # File logging (development) - synchronous, fast
    _write_to_current_log_file({
        'log_type': 'game_event',
        'data': event_record
    })
    
    # NEW: Async database logging (production) - non-blocking
    if IS_PRODUCTION and session and 'game' in session:
        game = session['game']
        queue_db_operation(
            _log_game_event_to_db_async,
            game.get('game_id'),
            event_type,
            event_data,
            hand_number=game.get('hand_number'),
            session_sequence=game.get('action_sequence'),
            player=event_data.get('player'),
            action_type=event_type
        )
    
    # Console logging - synchronous, fast
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'EVENTS_ONLY']:
        _print_event_log(event_record)

def _log_game_event_to_db_async(game_id, event_type, event_data, **kwargs):
    """Async wrapper for database event logging"""
    try:
        print(f"[DB] Attempting to log event: {event_type} for game {game_id}")
        from .postgres_utils import log_game_event_to_db
        success = log_game_event_to_db(
            game_id,
            event_type,
            event_data,
            **kwargs
        )
        if success:
            print(f"[DB] Successfully logged event: {event_type}")
        else:
            print(f"[DB] Failed to log event: {event_type}")
        return success
    except Exception as e:
        print(f"[DB] Exception logging event {event_type}: {e}")
        import traceback
        traceback.print_exc()
        return False

def log_ai_analysis(analysis_type, analysis_data, session=None):
    """Log detailed AI analysis with structured data"""
    if not LOGGING_ENABLED or not LOG_AI_ANALYSIS:
        return
    
    analysis_record = {
        'timestamp': time.time(),
        'analysis_type': analysis_type,
        'analysis_data': analysis_data
    }
    
    _write_to_current_log_file({
        'log_type': 'ai_analysis',
        'data': analysis_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'AI_ONLY']:
        _print_ai_analysis_log(analysis_record)

def log_ai_strategy(strategy_type, strategy_data, session=None):
    """Log AI strategy decisions and evaluations"""
    if not LOGGING_ENABLED or not LOG_AI_ANALYSIS:
        return
    
    strategy_record = {
        'timestamp': time.time(),
        'strategy_type': strategy_type,
        'strategy_data': strategy_data
    }
    
    _write_to_current_log_file({
        'log_type': 'ai_strategy',
        'data': strategy_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'AI_ONLY']:
        _print_ai_strategy_log(strategy_record)

def log_ai_evaluation(evaluation_type, candidates, chosen_candidate, session=None):
    """Log AI evaluation of multiple options"""
    if not LOGGING_ENABLED or not LOG_AI_ANALYSIS:
        return
    
    evaluation_record = {
        'timestamp': time.time(),
        'evaluation_type': evaluation_type,
        'candidates_evaluated': len(candidates),
        'all_candidates': candidates,
        'chosen_candidate': chosen_candidate,
        'confidence': _calculate_evaluation_confidence(candidates, chosen_candidate)
    }
    
    _write_to_current_log_file({
        'log_type': 'ai_evaluation',
        'data': evaluation_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'AI_ONLY']:
        _print_ai_evaluation_log(evaluation_record)

# =============================================================================
# INTERNAL HELPER FUNCTIONS
# =============================================================================

def _build_action_record(action_type, player, action_data, session, additional_context):
    """Build standardized action record"""
    game = session['game'] if session and 'game' in session else {}
    
    game['action_sequence'] = game.get('action_sequence', 0) + 1
    
    return {
        'sequence': game['action_sequence'],
        'timestamp': time.time(),
        'game_id': game.get('game_id'),
        'hand_id': game.get('current_hand_id'),
        'action_type': action_type,
        'player': player,
        'hand_number': game.get('hand_number', 1),
        'phase': game.get('phase', 'unknown'),
        'action_data': action_data,
        'game_context': {
            'player_score': game.get('player_score', 0),
            'computer_score': game.get('computer_score', 0),
            'player_tricks': game.get('player_tricks', 0),
            'computer_tricks': game.get('computer_tricks', 0),
            'player_bags': game.get('player_bags', 0),
            'computer_bags': game.get('computer_bags', 0),
            'spades_broken': game.get('spades_broken', False),
            'turn': game.get('turn'),
            'trick_leader': game.get('trick_leader')
        },
        'additional_context': additional_context
    }

def _build_ai_decision_record(decision_type, decision_data, analysis, reasoning):
    """Build standardized AI decision record"""
    return {
        'timestamp': time.time(),
        'decision_type': decision_type,
        'decision_data': decision_data,
        'analysis': analysis,
        'reasoning': reasoning,
        'confidence': _calculate_confidence(decision_type, decision_data, analysis)
    }

def _build_event_record(event_type, event_data, session):
    """Build standardized event record"""
    game = session['game'] if session and 'game' in session else {}
    
    return {
        'timestamp': time.time(),
        'game_id': game.get('game_id'),
        'hand_id': game.get('current_hand_id'),
        'event_type': event_type,
        'hand_number': game.get('hand_number', 1),
        'event_data': event_data
    }

def _calculate_confidence(decision_type, decision_data, analysis):
    """Calculate confidence score for AI decisions"""
    if not analysis:
        return 0.5
    
    if decision_type == 'bid':
        expected_tricks = analysis.get('base_expectation', 0)
        bid_amount = decision_data.get('bid_amount', 0)
        diff = abs(expected_tricks - bid_amount)
        return max(0.0, min(1.0, 1.0 - (diff / 5.0)))
    
    elif decision_type == 'discard_choice':
        chosen_score = decision_data.get('final_score', 0)
        if chosen_score >= 1000:
            return 1.0
        elif chosen_score >= 500:
            return 0.9
        else:
            return 0.6
    
    return 0.5

def _calculate_evaluation_confidence(candidates, chosen_candidate):
    """Calculate confidence for AI evaluations"""
    if not candidates or len(candidates) < 2:
        return 1.0
    
    if isinstance(chosen_candidate, dict) and 'score' in chosen_candidate:
        try:
            scores = [c.get('score', 0) for c in candidates if isinstance(c, dict)]
            if scores and len(scores) >= 2:
                best_score = max(scores)
                second_best = sorted(scores, reverse=True)[1]
                if best_score > 0:
                    confidence = min(1.0, (best_score - second_best) / best_score)
                    return max(0.1, confidence)
        except:
            pass
    
    return max(0.3, 1.0 - (len(candidates) * 0.1))

# =============================================================================
# CONSOLE OUTPUT FUNCTIONS
# =============================================================================

def _print_action_log(action_record):
    """Print action log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(action_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"=== ACTION #{action_record['sequence']}: {action_record['action_type'].upper()} by {action_record['player'].upper()} ===")
    print(f"Hand #{action_record['hand_number']} | Phase: {action_record['phase']} | Time: {timestamp_str}")
    print(f"Data: {action_record['action_data']}")
    
    ctx = action_record['game_context']
    print(f"Context: Score {ctx['player_score']}-{ctx['computer_score']} | Tricks {ctx['player_tricks']}-{ctx['computer_tricks']} | Bags {ctx['player_bags']}-{ctx['computer_bags']}")
    
    if action_record.get('additional_context'):
        print(f"Extra: {action_record['additional_context']}")
    
    print("=" * 60)

def _print_ai_decision_log(decision_record):
    """Print AI decision log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(decision_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"AI DECISION: {decision_record['decision_type'].upper()}")
    print(f"Time: {timestamp_str} | Confidence: {decision_record['confidence']:.2f}")
    print(f"Decision: {decision_record['decision_data']}")
    
    if decision_record.get('analysis'):
        print(f"Analysis: {decision_record['analysis']}")
    
    if decision_record.get('reasoning'):
        print(f"Reasoning: {decision_record['reasoning']}")
    
    print("=" * 58)

def _print_event_log(event_record):
    """Print game event log to console with formatting"""
    print(f"GAME EVENT: {event_record['event_type'].upper()}")
    print(f"Hand #{event_record['hand_number']} | Data: {event_record['event_data']}")
    print("*" * 40)

def _print_ai_analysis_log(analysis_record):
    """Print AI analysis log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(analysis_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"AI ANALYSIS: {analysis_record['analysis_type'].upper()}")
    print(f"Time: {timestamp_str}")
    
    for key, value in analysis_record['analysis_data'].items():
        if isinstance(value, (int, float)):
            print(f"  {key}: {value:.2f}")
        else:
            print(f"  {key}: {value}")
    
    print("-" * 40)

def _print_ai_strategy_log(strategy_record):
    """Print AI strategy log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(strategy_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"AI STRATEGY: {strategy_record['strategy_type'].upper()}")
    print(f"Time: {timestamp_str}")
    print(f"Strategy: {strategy_record['strategy_data']}")
    print("-" * 40)

def _print_ai_evaluation_log(evaluation_record):
    """Print AI evaluation log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(evaluation_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"AI EVALUATION: {evaluation_record['evaluation_type'].upper()}")
    print(f"Time: {timestamp_str} | Confidence: {evaluation_record['confidence']:.2f}")
    print(f"Evaluated {evaluation_record['candidates_evaluated']} options")
    print(f"Chosen: {evaluation_record['chosen_candidate']}")
    
    top_candidates = evaluation_record['all_candidates'][:3]
    for i, candidate in enumerate(top_candidates):
        print(f"  #{i+1}: {candidate}")
    
    if len(evaluation_record['all_candidates']) > 3:
        print(f"  ... and {len(evaluation_record['all_candidates']) - 3} more")
    
    print("-" * 40)

# =============================================================================
# DEBUG ENDPOINTS - FILE READING ONLY ON DEMAND
# =============================================================================

def get_environment_info():
    """Get information about the current environment - NO FILE READING"""
    return {
        'is_local_development': IS_LOCAL_DEVELOPMENT,
        'is_production': IS_PRODUCTION,
        'file_logging_enabled': LOG_TO_FILE,
        'console_logging_enabled': LOG_TO_CONSOLE,
        'async_db_logging_enabled': IS_PRODUCTION,
        'gae_env': os.environ.get('GAE_ENV', 'Not set'),
        'platform': platform.system(),
        'logs_directory': LOGS_DIRECTORY,
        'current_log_file': os.path.basename(CURRENT_LOG_FILE) if CURRENT_LOG_FILE else None,
        'async_db_stats': get_async_db_stats()
    }

def get_logging_summary():
    """Get summary of current session only - NO FILE READING"""
    return {
        'current_log_file': os.path.basename(CURRENT_LOG_FILE) if CURRENT_LOG_FILE else None,
        'logging_enabled': LOGGING_ENABLED,
        'environment': 'local_development' if IS_LOCAL_DEVELOPMENT else 'production',
        'file_logging_available': IS_LOCAL_DEVELOPMENT,
        'async_db_logging_available': IS_PRODUCTION,
        'async_db_stats': get_async_db_stats(),
        'message': 'Historical log analysis available via explicit debug endpoints only'
    }

# The following functions are only called by explicit debug routes, never during normal gameplay

def list_game_logs():
    """List all available game log files - ONLY for debug endpoints"""
    if not IS_LOCAL_DEVELOPMENT or not os.path.exists(LOGS_DIRECTORY):
        return []
    
    log_files = []
    for filename in os.listdir(LOGS_DIRECTORY):
        if filename.startswith('game_log_') and filename.endswith('.json'):
            filepath = os.path.join(LOGS_DIRECTORY, filename)
            try:
                parts = filename.replace('game_log_', '').replace('.json', '').split('_')
                if len(parts) >= 3:
                    stat = os.stat(filepath)
                    log_files.append({
                        'filename': filename,
                        'date': parts[0],
                        'time': parts[1],
                        'game_id': parts[2],
                        'size_bytes': stat.st_size,
                        'modified': datetime.fromtimestamp(stat.st_mtime).isoformat()
                    })
            except Exception:
                pass
    
    return sorted(log_files, key=lambda x: x['modified'], reverse=True)

def get_game_log_summary(filename):
    """Get summary of a specific game log file - ONLY for debug endpoints"""
    if not IS_LOCAL_DEVELOPMENT:
        return {'error': 'File logging not available in production'}
    
    filepath = os.path.join(LOGS_DIRECTORY, filename)
    if not os.path.exists(filepath):
        return {'error': f'Log file not found: {filename}'}
    
    try:
        with open(filepath, 'r') as f:
            logs = json.load(f)
        
        log_counts = {}
        for entry in logs:
            log_type = entry.get('log_type', 'unknown')
            log_counts[log_type] = log_counts.get(log_type, 0) + 1
        
        return {
            'filename': filename,
            'total_entries': len(logs),
            'log_type_counts': log_counts,
            'file_size_kb': round(os.path.getsize(filepath) / 1024, 2)
        }
        
    except Exception as e:
        return {'error': f'Could not analyze log file: {e}'}

# =============================================================================
# CONTROL FUNCTIONS
# =============================================================================

def enable_logging():
    """Enable all logging"""
    global LOGGING_ENABLED
    LOGGING_ENABLED = True
    if LOG_TO_CONSOLE:
        print("Logging ENABLED")

def disable_logging():
    """Disable all logging"""
    global LOGGING_ENABLED
    LOGGING_ENABLED = False
    if LOG_TO_CONSOLE:
        print("Logging DISABLED")

def set_console_log_level(level):
    """Set console logging level"""
    global CONSOLE_LOG_LEVEL
    valid_levels = ['ALL', 'ACTIONS_ONLY', 'AI_ONLY', 'EVENTS_ONLY', 'OFF']
    if level in valid_levels:
        CONSOLE_LOG_LEVEL = level
        if LOG_TO_CONSOLE:
            print(f"Console log level set to: {level}")
    else:
        if LOG_TO_CONSOLE:
            print(f"Invalid log level. Valid options: {valid_levels}")

def toggle_console_logging():
    """Toggle console logging on/off"""
    global LOG_TO_CONSOLE
    LOG_TO_CONSOLE = not LOG_TO_CONSOLE
    print(f"Console logging: {'ON' if LOG_TO_CONSOLE else 'OFF'}")

# =============================================================================
# ENHANCED BATCH EVENT SYSTEM WITH ASYNC PROCESSING
# =============================================================================

class GameEventBatch:
    def __init__(self, game_id):
        self.game_id = game_id
        self.events = []
    
    def add_event(self, event_type, event_data, **kwargs):
        """Add event to batch for later database write"""
        self.events.append({
            'timestamp': time.time(),
            'event_type': event_type,
            'event_data': event_data,
            **kwargs
        })
    
    def flush_to_db_async(self):
        """Queue batch for async database write"""
        if IS_PRODUCTION and self.events:
            queue_db_operation(
                _process_event_batch_async,
                self.game_id,
                self.events.copy()  # Copy to avoid race conditions
            )
            self.events.clear()

def _process_event_batch_async(game_id, events):
    """Process event batch in background thread"""
    try:
        from .postgres_utils import batch_log_events
        success = batch_log_events(game_id, events)
        if success:
            print(f"[DB] Async batch: {len(events)} events logged")
        return success
    except Exception as e:
        print(f"[DB] Async batch failed: {e}")
        return False

def initialize_event_batching(game):
    """Add event batching to existing game initialization"""
    if IS_PRODUCTION:
        # Store just the events list in the game, not the batch object
        game['event_batch_events'] = []
    return game

def flush_hand_events(session):
    """Flush batched events at hand completion - NOW ASYNC"""
    if IS_PRODUCTION and 'game' in session:
        game = session['game']
        events = game.get('event_batch_events', [])
        if events:
            queue_db_operation(
                _process_event_batch_async,
                game.get('game_id'),
                events.copy()  # Copy to avoid race conditions
            )
            # Clear immediately - don't wait for database
            game['event_batch_events'] = []

def add_to_batch(session, event_type, event_data, **kwargs):
    """Add event to batch if in production"""
    if IS_PRODUCTION and 'game' in session:
        game = session['game']
        if 'event_batch_events' not in game:
            game['event_batch_events'] = []
        
        game['event_batch_events'].append({
            'timestamp': time.time(),
            'event_type': event_type,
            'event_data': event_data,
            **kwargs
        })

================================================================================

FILE: ./static/game.js
--------------------------------------------------------------------------------
let gameState = null;
let selectedCard = null;
let trickDisplayTimeout = null;
let lastHandNumber = null;

// Bidding confirmation variables
let selectedBid = null;
let confirmingBid = false;

// Scroll preservation for trick history
let trickHistoryScrollPosition = 0;

// Enhanced chat system variables
let chatOpen = false;
let unreadMessages = 0;
let chatInitialized = false;

// =============================================================================
// USER-ONLY CLAUDE CHAT SYSTEM
// =============================================================================

function toggleChat() {
    const chatWindow = document.getElementById('chatWindow');
    const chatIcon = document.getElementById('chatBubbleIcon');

    chatOpen = !chatOpen;

    if (chatOpen) {
        chatWindow.classList.add('open');
        chatIcon.style.display = 'none';

        // Show static welcome message only when chat first opens
        if (!chatInitialized) {
            addMessage("Ready when you are.", 'marta');
            chatInitialized = true;
        }

        // Clear unread messages when chat is opened
        unreadMessages = 0;
        updateChatBadge();
    } else {
        chatWindow.classList.remove('open');
        chatIcon.style.display = 'flex';
    }
}

function sendMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();

    if (!message) return;

    // Add player message
    addMessage(message, 'player');
    input.value = '';

    // Show Marta typing indicator
    showMartaTyping();

    // Get smart response from Marta with enhanced context - ONLY user-initiated
    fetch('/chat_response', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: message })
    })
        .then(response => response.json())
        .then(data => {
            if (data.response) {
                // Simulate realistic typing time based on response length
                const typingDelay = Math.min(Math.max(data.response.length * 50, 800), 3000);

                setTimeout(() => {
                    hideMartaTyping();
                    addMessage(data.response, 'marta');
                }, typingDelay);
            } else {
                hideMartaTyping();
                addMessage("...", 'marta'); // Mysterious fallback
            }
        })
        .catch(error => {
            console.error('Chat error:', error);
            hideMartaTyping();
            // Snarky fallback responses
            const fallbacks = [
                "Interesting move...",
                "We'll see about that.",
                "My cards are speaking to me.",
                "Poker face activated.",
                "You're full of surprises."
            ];
            const response = fallbacks[Math.floor(Math.random() * fallbacks.length)];
            setTimeout(() => {
                addMessage(response, 'marta');
            }, 800 + Math.random() * 1000);
        });
}

function showMartaTyping() {
    const messagesDiv = document.getElementById('chatMessages');

    // Remove any existing typing indicator
    const existingIndicator = document.getElementById('martaTypingIndicator');
    if (existingIndicator) {
        existingIndicator.remove();
    }

    // Create typing indicator
    const typingDiv = document.createElement('div');
    typingDiv.id = 'martaTypingIndicator';
    typingDiv.className = 'marta-message typing-indicator';
    typingDiv.innerHTML = `
        <div class="message-content">
            <div class="typing-dots">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
    `;

    messagesDiv.appendChild(typingDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function hideMartaTyping() {
    const typingIndicator = document.getElementById('martaTypingIndicator');
    if (typingIndicator) {
        typingIndicator.remove();
    }
}

function addMessage(text, sender) {
    const messagesDiv = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = sender === 'marta' ? 'marta-message' : 'player-message';

    // Create timestamp
    const now = new Date();
    const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

    // Create message structure with timestamp
    const messageContent = document.createElement('div');
    messageContent.className = 'message-content';
    messageContent.textContent = text;

    const timestamp = document.createElement('div');
    timestamp.className = 'message-timestamp';
    timestamp.textContent = timeString;

    messageDiv.appendChild(messageContent);
    messageDiv.appendChild(timestamp);

    messagesDiv.appendChild(messageDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;

    // If it's a Marta message and chat is closed, increment unread count
    if (sender === 'marta' && !chatOpen) {
        unreadMessages++;
        updateChatBadge();
    }
}

function updateChatBadge() {
    const chatIcon = document.getElementById('chatBubbleIcon');
    let badge = document.getElementById('chatBadge');

    if (unreadMessages > 0 && !chatOpen) {
        // Create badge if it doesn't exist
        if (!badge) {
            badge = document.createElement('div');
            badge.id = 'chatBadge';
            badge.className = 'chat-badge';
            chatIcon.appendChild(badge);
        }
        badge.textContent = unreadMessages > 9 ? '9+' : unreadMessages;
        badge.style.display = 'block';
    } else {
        // Hide badge when no unread messages or chat is open
        if (badge) {
            badge.style.display = 'none';
        }
    }
}

// =============================================================================
// MAIN GAME FUNCTIONS (unchanged core logic)
// =============================================================================

async function loadGameState() {
    try {
        const response = await fetch('/state');
        gameState = await response.json();
        updateUI();
    } catch (error) {
        console.error('Error loading game state:', error);
        showMessage('Error loading game', 'error');
    }
}

function updateUI() {
    if (!gameState) return;

    preserveTrickHistoryScroll();
    updateFloatingScores();
    updatePlayAreaVisibility();
    updateHandCount();
    updateGameOverState();
    updatePhaseVisibility();
    updateMessages();
    updatePlayArea();
    updatePlayerHand();
    updateComputerHand();
    updateActionButtons();
    updateBidButtons();
    updateComputerHandToggle();
    updateDiscards();
    handleResultsDisplay();
    handleTrickCompletion();

    // Track hand changes but don't auto-call Claude
    lastHandNumber = gameState.hand_number;
    restoreTrickHistoryScroll();
}

// =============================================================================
// UI UPDATE FUNCTIONS (unchanged from original)
// =============================================================================

function updateFloatingScores() {
    const gameScoreEl = document.getElementById('floatingGameScore');
    if (gameScoreEl) {
        document.getElementById('floatingPlayerScore').textContent = gameState.player_score;
        document.getElementById('floatingComputerScore').textContent = gameState.computer_score;
        document.getElementById('floatingHandNumber').textContent = gameState.hand_number;

        const playerParityText = `(${gameState.player_parity.toUpperCase()})`;
        const computerParityText = `(${gameState.computer_parity.toUpperCase()})`;
        document.getElementById('floatingPlayerParity').textContent = playerParityText;
        document.getElementById('floatingComputerParity').textContent = computerParityText;
    }

    const handScoreEl = document.getElementById('floatingHandScore');
    if (handScoreEl) {
        // Player side
        document.getElementById('floatingPlayerTricks').textContent = gameState.player_tricks;
        const playerBid = gameState.player_bid !== null ? gameState.player_bid : '-';
        const playerBlindText = gameState.blind_bid === gameState.player_bid ? 'B' : '';
        document.getElementById('floatingPlayerBid').textContent = `${playerBid}${playerBlindText}`;

        const playerBidEl = document.getElementById('floatingPlayerBid');
        if (playerBlindText) {
            playerBidEl.style.color = '#dc3545';
            playerBidEl.style.fontWeight = 'bold';
        } else {
            playerBidEl.style.color = '#333';
            playerBidEl.style.fontWeight = '600';
        }

        document.getElementById('floatingPlayerBags').textContent = gameState.player_bags || 0;

        // Computer side
        document.getElementById('floatingComputerTricks').textContent = gameState.computer_tricks;
        const computerBid = gameState.computer_bid !== null ? gameState.computer_bid : '-';
        const computerBlindText = gameState.computer_blind_bid === gameState.computer_bid ? 'B' : '';
        document.getElementById('floatingComputerBid').textContent = `${computerBid}${computerBlindText}`;

        const computerBidEl = document.getElementById('floatingComputerBid');
        const martaWentFirst = gameState.phase === 'bidding' &&
            gameState.computer_bid !== null &&
            gameState.player_bid === null;

        if (computerBlindText) {
            computerBidEl.style.color = '#dc3545';
            computerBidEl.style.fontWeight = 'bold';
            computerBidEl.style.backgroundColor = '';
            computerBidEl.style.border = '';
            computerBidEl.style.borderRadius = '';
            computerBidEl.style.padding = '';
        } else if (martaWentFirst) {
            computerBidEl.style.color = '#1976d2';
            computerBidEl.style.fontWeight = 'bold';
            computerBidEl.style.backgroundColor = '#e3f2fd';
            computerBidEl.style.border = '2px solid #1976d2';
            computerBidEl.style.borderRadius = '4px';
            computerBidEl.style.padding = '2px 4px';
        } else {
            computerBidEl.style.color = '#333';
            computerBidEl.style.fontWeight = '600';
            computerBidEl.style.backgroundColor = '';
            computerBidEl.style.border = '';
            computerBidEl.style.borderRadius = '';
            computerBidEl.style.padding = '';
        }

        document.getElementById('floatingComputerBags').textContent = gameState.computer_bags || 0;
        document.getElementById('floatingSpadesStatus').textContent = gameState.spades_broken ? 'Broken' : 'Not Broken';
    }
}

function updatePlayAreaVisibility() {
    const playArea = document.getElementById('playArea');
    if (!playArea) return;

    // Hide play area during these phases to save screen space
    const hiddenPhases = ['discard', 'bidding', 'blind_decision', 'blind_bidding'];

    if (hiddenPhases.includes(gameState.phase)) {
        playArea.classList.add('hidden-for-phase');
    } else {
        playArea.classList.remove('hidden-for-phase');
    }
}

function updateHandCount() {
    const playerHandCountEl = document.getElementById('playerHandCount');
    if (playerHandCountEl) {
        playerHandCountEl.textContent = `(${gameState.player_hand.length} cards)`;
    }
}

function updateGameOverState() {
    const gameOverEl = document.getElementById('gameOver');
    const winnerTextEl = document.getElementById('winnerText');

    if (gameState.game_over) {
        gameOverEl.style.display = 'block';
        winnerTextEl.textContent = gameState.message;
        hideInteractiveSections();

        // Show results for blind nil games
        if (gameState.hand_results && (gameState.message.includes('BLIND NIL') || gameState.message.includes('Blind Nil'))) {
            handleResultsDisplay();
        } else {
            document.getElementById('resultsSection').classList.remove('show');
        }
    } else {
        gameOverEl.style.display = 'none';
    }
}

function hideInteractiveSections() {
    document.getElementById('biddingSection').style.display = 'none';
    const blindDecisionSection = document.getElementById('blindDecisionSection');
    if (blindDecisionSection) blindDecisionSection.style.display = 'none';
    document.getElementById('discardBlindBiddingSection').style.display = 'none';
    document.getElementById('nextHandSection').style.display = 'none';
    document.getElementById('playerHandSection').style.display = 'none';
    document.getElementById('computerHandSection').style.display = 'none';
}

function updatePhaseVisibility() {
    if (gameState.game_over) return;

    const biddingSection = document.getElementById('biddingSection');
    const blindDecisionSection = document.getElementById('blindDecisionSection');
    const discardBlindSection = document.getElementById('discardBlindBiddingSection');

    // Hide all sections first
    biddingSection.style.display = 'none';
    if (blindDecisionSection) blindDecisionSection.style.display = 'none';
    discardBlindSection.style.display = 'none';

    if (gameState.phase === 'blind_decision') {
        if (blindDecisionSection) blindDecisionSection.style.display = 'block';
    } else if (gameState.phase === 'blind_bidding') {
        discardBlindSection.style.display = 'block';
    } else if (gameState.phase === 'bidding') {
        biddingSection.style.display = 'block';
        if (!biddingSection.classList.contains('active')) {
            biddingSection.classList.add('active');
            resetBiddingState();
        }
    } else {
        biddingSection.classList.remove('active');
    }
}

function updateMessages() {
    if (gameState.game_over) {
        showMessage(gameState.message, gameState.winner === 'player' ? 'success' : '');
        return;
    }

    let messageToShow = gameState.message;

    // Avoid showing detailed results if structured results are shown
    if (gameState.hand_over && gameState.hand_results) {
        messageToShow = `Hand #${gameState.hand_number} complete! Click 'Next Hand' to continue, or scroll for hand stats!`;
    }

    showMessage(messageToShow, messageToShow.includes('WIN') || messageToShow.includes('BLIND NIL SUCCESS') ? 'success' : '');
}

function updatePlayArea() {
    const trickDisplay = document.getElementById('trickDisplay');

    if (gameState.current_trick.length === 0) {
        trickDisplay.innerHTML = '<div style="color: #999; font-size: 14px;">Waiting for play...</div>';
    } else {
        let html = '<div class="trick-container">';

        const playerCard = gameState.current_trick.find(play => play.player === 'player');
        const computerCard = gameState.current_trick.find(play => play.player === 'computer');

        // Always show side by side - You left, Marta right
        if (playerCard) {
            const card = playerCard.card;
            const suitClass = getSuitClass(card.suit);
            html += `
                <div class="trick-card ${suitClass}">
                    <div class="player-name">You</div>
                    <div class="card-content">${card.rank}${card.suit}</div>
                </div>
            `;
        } else {
            html += '<div class="trick-card-placeholder"><div style="font-size: 10px; color: #999;">You</div></div>';
        }

        if (computerCard) {
            const card = computerCard.card;
            const suitClass = getSuitClass(card.suit);
            html += `
                <div class="trick-card ${suitClass}">
                    <div class="player-name">Marta</div>
                    <div class="card-content">${card.rank}${card.suit}</div>
                </div>
            `;
        } else {
            html += '<div class="trick-card-placeholder"><div style="font-size: 10px; color: #999;">Marta</div></div>';
        }

        html += '</div>';
        trickDisplay.innerHTML = html;
    }
}

function updatePlayerHand() {
    const handEl = document.getElementById('playerHand');
    const playerHandSection = document.getElementById('playerHandSection');

    // Hide entire hand section when hand is complete
    if (gameState.hand_over && gameState.player_hand.length === 0) {
        playerHandSection.style.display = 'none';
        return;
    } else {
        playerHandSection.style.display = 'block';
    }

    handEl.innerHTML = '';

    // Hide cards during blind decision or blind bidding phases
    if (gameState.phase === 'blind_decision' || gameState.phase === 'blind_bidding') {
        handEl.innerHTML = '<div style="text-align: center; color: #666; font-style: italic; padding: 20px; border: 2px dashed #ccc; border-radius: 8px;">Cards hidden during blind bidding decision!</div>';
        return;
    }

    gameState.player_hand.forEach((card, index) => {
        const cardEl = document.createElement('div');
        cardEl.className = `card ${getSuitClass(card.suit)}`;
        cardEl.textContent = `${card.rank}${card.suit}`;

        cardEl.onclick = () => selectCard(index);
        cardEl.ontouchstart = (e) => {
            e.preventDefault();
            selectCard(index);
        };

        if (selectedCard === index) {
            cardEl.classList.add('selected');
        }

        if (!canPlayCard(card, index)) {
            cardEl.classList.add('disabled');
        }

        handEl.appendChild(cardEl);
    });
}

function updateComputerHand() {
    const handEl = document.getElementById('computerHand');
    const computerHandSection = handEl.closest('.hand-section');

    // Hide entire computer hand section if debug mode is off
    if (!gameState.debug_mode) {
        computerHandSection.style.display = 'none';
        return;
    }

    computerHandSection.style.display = 'block';
    handEl.innerHTML = '';

    // Only show cards if debug mode is on AND show_computer_hand is true
    if (gameState.debug_mode && gameState.show_computer_hand && gameState.computer_hand) {
        gameState.computer_hand.forEach((card, index) => {
            const cardEl = document.createElement('div');
            cardEl.className = `card ${getSuitClass(card.suit)}`;
            cardEl.textContent = `${card.rank}${card.suit}`;
            cardEl.style.cursor = 'default';
            handEl.appendChild(cardEl);
        });
    } else {
        const cardCount = gameState.computer_hand_count || 0;
        for (let i = 0; i < cardCount; i++) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card';
            cardEl.style.background = '#666';
            cardEl.style.color = '#999';
            cardEl.textContent = '?';
            cardEl.style.cursor = 'default';
            handEl.appendChild(cardEl);
        }
    }
}

function updateActionButtons() {
    const actionButton = document.getElementById('actionButton');
    const nextHandSection = document.getElementById('nextHandSection');

    if (gameState.hand_over && !gameState.game_over) {
        actionButton.style.display = 'none';
        nextHandSection.style.display = 'block';
    } else {
        nextHandSection.style.display = 'none';

        if (gameState.phase === 'discard') {
            actionButton.textContent = 'Discard Selected';
            actionButton.onclick = discardCard;
            actionButton.style.display = 'inline-block';
        } else if (gameState.phase === 'playing') {
            actionButton.textContent = 'Play Selected';
            actionButton.onclick = playCard;
            actionButton.style.display = 'inline-block';
        } else {
            actionButton.style.display = 'none';
        }
    }

    if (selectedCard === null && actionButton.style.display !== 'none') {
        actionButton.disabled = true;
        actionButton.textContent = gameState.phase === 'discard' ? 'Select Card to Discard' : 'Select Card to Play';
    } else if (actionButton.style.display !== 'none') {
        actionButton.disabled = false;
        actionButton.textContent = gameState.phase === 'discard' ? 'Discard Selected' : 'Play Selected';
    }
}

function updateBidButtons() {
    if (gameState.phase !== 'bidding') return;

    const bidButtons = document.querySelectorAll('.bid-btn');
    const confirmButton = document.getElementById('confirmBidButton');
    const cancelButton = document.getElementById('cancelBidButton');

    if (confirmingBid && selectedBid !== null) {
        bidButtons.forEach(btn => {
            const bidValue = parseInt(btn.getAttribute('data-bid'));
            if (bidValue === selectedBid) {
                btn.classList.add('selected');
                btn.style.backgroundColor = '#28a745';
                btn.style.color = 'white';
                btn.style.border = '2px solid #1e7e34';
            } else {
                btn.classList.remove('selected');
                btn.style.backgroundColor = '';
                btn.style.color = '';
                btn.style.border = '';
                btn.style.opacity = '0.6';
            }
        });

        if (confirmButton) confirmButton.style.display = 'inline-block';
        if (cancelButton) cancelButton.style.display = 'inline-block';
    } else {
        bidButtons.forEach(btn => {
            btn.classList.remove('selected');
            btn.style.backgroundColor = '';
            btn.style.color = '';
            btn.style.border = '';
            btn.style.opacity = '';
        });

        if (confirmButton) confirmButton.style.display = 'none';
        if (cancelButton) cancelButton.style.display = 'none';
    }
}

function updateComputerHandToggle() {
    const toggleButton = document.getElementById('toggleComputerHand');
    if (toggleButton) {
        if (gameState.debug_mode) {
            toggleButton.style.display = 'inline-block';
            toggleButton.textContent = gameState.show_computer_hand ? 'Hide Cards' : 'Show Cards';
            toggleButton.style.background = '#6c757d';
        } else {
            toggleButton.style.display = 'none';
        }
    }
}

function updateDiscards() {
    const discardsSection = document.getElementById('discardsSection');

    if (gameState.hand_over && (gameState.player_discarded || gameState.computer_discarded)) {
        discardsSection.style.display = 'block';

        const playerDiscardEl = document.getElementById('playerDiscard');
        if (gameState.player_discarded) {
            const card = gameState.player_discarded;
            playerDiscardEl.innerHTML = `<div class="card ${getSuitClass(card.suit)}">${card.rank}${card.suit}</div>`;
        } else {
            playerDiscardEl.innerHTML = '<div class="card" style="opacity: 0.5;">None</div>';
        }

        const computerDiscardEl = document.getElementById('computerDiscard');
        if (gameState.computer_discarded) {
            const card = gameState.computer_discarded;
            computerDiscardEl.innerHTML = `<div class="card ${getSuitClass(card.suit)}">${card.rank}${card.suit}</div>`;
        } else {
            computerDiscardEl.innerHTML = '<div class="card" style="opacity: 0.5;">None</div>';
        }
    } else {
        discardsSection.style.display = 'none';
    }
}

function handleResultsDisplay() {
    const resultsSection = document.getElementById('resultsSection');
    const resultsContent = document.getElementById('resultsContent');

    if (gameState.hand_over && gameState.hand_results) {
        resultsSection.classList.add('show');
        resultsContent.innerHTML = formatCleanResults(gameState.hand_results);
    } else {
        resultsSection.classList.remove('show');
    }
}

function handleTrickCompletion() {
    // Check for completed trick that needs to be displayed
    if (gameState.current_trick && gameState.current_trick.length === 2 && !trickDisplayTimeout) {
        trickDisplayTimeout = setTimeout(async () => {
            try {
                await fetch('/clear_trick', { method: 'POST' });
                await loadGameState();
                trickDisplayTimeout = null;
            } catch (error) {
                console.error('Error clearing trick:', error);
                trickDisplayTimeout = null;
            }
        }, 1500);
    }
}

// =============================================================================
// HELPER FUNCTIONS (unchanged from original)
// =============================================================================

function getSuitClass(suit) {
    switch (suit) {
        case 'â™ ': return 'spade';
        case 'â™¥': return 'heart';
        case 'â™¦': return 'diamond';
        case 'â™£': return 'club';
        default: return '';
    }
}

function canPlayCard(card, index) {
    if (gameState.phase === 'discard') return true;
    if (gameState.turn !== 'player') return false;

    if (gameState.current_trick.length === 1) {
        const leadSuit = gameState.current_trick[0].card.suit;
        const hasSuit = gameState.player_hand.some(c => c.suit === leadSuit);
        if (hasSuit) {
            return card.suit === leadSuit;
        }
        return true;
    }

    if (gameState.current_trick.length === 0) {
        if (card.suit === 'â™ ' && !gameState.spades_broken) {
            return gameState.player_hand.every(c => c.suit === 'â™ ');
        }
        return true;
    }

    return false;
}

function selectCard(index) {
    if (!canPlayCard(gameState.player_hand[index], index)) {
        showMessage('Cannot play this card!', 'error');
        if (navigator.vibrate) {
            navigator.vibrate(100);
        }
        return;
    }

    selectedCard = index;
    updatePlayerHand();
    updateActionButtons();

    if (navigator.vibrate) {
        navigator.vibrate(50);
    }
}

function showMessage(text, type = '') {
    const messageEl = document.getElementById('message');
    if (messageEl) {
        messageEl.textContent = text;
        messageEl.className = 'message ' + type;
    }
}

function isSpecialCard(card) {
    return (card.rank === '7' && card.suit === 'â™¦') || (card.rank === '10' && card.suit === 'â™£');
}

// =============================================================================
// BIDDING FUNCTIONS (unchanged from original)
// =============================================================================

function selectBid(bidAmount) {
    if (confirmingBid) return;

    selectedBid = bidAmount;
    confirmingBid = true;

    updateBidButtons();

    const biddingPrompt = document.querySelector('.bidding-prompt');
    if (biddingPrompt) {
        const bidText = bidAmount === 0 ? 'NIL (0 tricks)' : `${bidAmount} tricks`;
        biddingPrompt.innerHTML = `You selected: <strong>${bidText}</strong>`;
    }

    if (navigator.vibrate) navigator.vibrate(50);
}

function confirmSelectedBid() {
    if (selectedBid === null || !confirmingBid) return;

    makeBid(selectedBid);
    resetBiddingState();
}

function cancelBidSelection() {
    resetBiddingState();

    const biddingPrompt = document.querySelector('.bidding-prompt');
    if (biddingPrompt) {
        biddingPrompt.innerHTML = `How many tricks will you take?`;
    }
}

function resetBiddingState() {
    selectedBid = null;
    confirmingBid = false;
    updateBidButtons();
}

// =============================================================================
// RESULTS FORMATTING (unchanged from original)
// =============================================================================

function formatCleanResults(results) {
    let html = '';

    // Parity Assignment
    html += `
        <div class="result-section">
            <div class="result-header">Players</div>
            <div class="result-content">You (${results.parity.player}) vs Marta (${results.parity.computer})</div>
        </div>
    `;

    // Discard Information
    if (results.discard_info && results.discard_info !== 'No discards to score') {
        html += `
            <div class="result-section">
                <div class="result-header">Discard Pile</div>
                <div class="result-content highlight">${results.discard_info}</div>
            </div>
        `;
    }

    // Scoring Breakdown
    html += `
        <div class="result-section">
            <div class="result-header">Scoring</div>
            <div class="result-content">${formatScoring(results.scoring)}</div>
        </div>
    `;

    // Trick History
    if (results.trick_history && results.trick_history.length > 0) {
        html += `
            <div class="result-section">
                <div class="result-header">Trick History</div>
                <div class="trick-history">
        `;

        results.trick_history.forEach(trick => {
            html += `
                <div class="trick-line">
                    <span class="trick-number">T${trick.number}:</span>
                    <span class="trick-cards">${trick.player_card} vs ${trick.computer_card}</span>
                    <span class="trick-winner">â†’ ${trick.winner}</span>
                </div>
            `;
        });

        html += `
                </div>
            </div>
        `;
    }

    // Game Totals
    html += `
        <div class="result-section">
            <div class="result-header">Game Totals</div>
            <div class="result-content totals">
                <span>You: ${results.totals.player_score}</span>
                <span>Marta: ${results.totals.computer_score}</span>
            </div>
        </div>
    `;

    return html;
}

function formatScoring(scoringText) {
    const parts = scoringText.split(' | ');
    return parts.map(part => {
        part = part.trim();

        if (part.includes('BAG PENALTY')) {
            return `<div class="penalty-line">${part.replace('BAG PENALTY!', 'Bag Penalty')}</div>`;
        } else if (part.includes('NEGATIVE BAG BONUS')) {
            return `<div class="bonus-line">${part.replace('NEGATIVE BAG BONUS!', 'Bag Bonus')}</div>`;
        } else if (part.includes('special cards')) {
            return `<div class="special-line">${part}</div>`;
        } else if (part.includes('Bags:')) {
            return `<div class="bags-line">${part}</div>`;
        } else {
            return `<div class="score-line">${part}</div>`;
        }
    }).join('');
}

// =============================================================================
// SCROLL PRESERVATION (unchanged from original)
// =============================================================================

function preserveTrickHistoryScroll() {
    const trickHistory = document.querySelector('.trick-history');
    if (trickHistory) {
        trickHistoryScrollPosition = trickHistory.scrollTop;
    }
}

function restoreTrickHistoryScroll() {
    const trickHistory = document.querySelector('.trick-history');
    if (trickHistory && trickHistoryScrollPosition > 0) {
        setTimeout(() => {
            trickHistory.scrollTop = trickHistoryScrollPosition;
        }, 10);
    }
}

function resetTrickHistoryScroll() {
    trickHistoryScrollPosition = 0;
}

// =============================================================================
// API FUNCTIONS (unchanged from original)
// =============================================================================

async function chooseBlindNil() {
    try {
        const response = await fetch('/choose_blind_nil', { method: 'POST' });
        if (response.ok) {
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error choosing blind nil:', error);
        showMessage('Error choosing blind nil', 'error');
    }
}

async function chooseBlindBidding() {
    try {
        const response = await fetch('/choose_blind_bidding', { method: 'POST' });
        if (response.ok) {
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error choosing blind bidding:', error);
        showMessage('Error choosing blind bidding', 'error');
    }
}

async function chooseNormalBidding() {
    try {
        const response = await fetch('/choose_normal_bidding', { method: 'POST' });
        if (response.ok) {
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error choosing normal bidding:', error);
        showMessage('Error choosing normal bidding', 'error');
    }
}

async function makeBid(bidAmount) {
    try {
        const response = await fetch('/bid', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ bid: bidAmount })
        });

        if (response.ok) {
            await loadGameState();
            if (navigator.vibrate) navigator.vibrate(50);
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error making bid:', error);
        showMessage('Error making bid', 'error');
    }
}

async function makeBlindBid(bidAmount) {
    try {
        const response = await fetch('/blind_bid', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ bid: bidAmount })
        });

        if (response.ok) {
            await loadGameState();
            if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error making blind bid:', error);
        showMessage('Error making blind bid', 'error');
    }
}

async function discardCard() {
    if (selectedCard === null) {
        showMessage('Please select a card to discard', 'error');
        if (navigator.vibrate) navigator.vibrate(100);
        return;
    }

    try {
        const response = await fetch('/discard', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ index: selectedCard })
        });

        if (response.ok) {
            selectedCard = null;
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error discarding card:', error);
        showMessage('Error discarding card', 'error');
    }
}

async function playCard() {
    if (selectedCard === null) {
        showMessage('Please select a card to play', 'error');
        if (navigator.vibrate) navigator.vibrate(100);
        return;
    }

    try {
        const response = await fetch('/play', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ index: selectedCard })
        });

        if (response.ok) {
            selectedCard = null;
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error playing card:', error);
        showMessage('Error playing card', 'error');
    }
}

async function performAction() {
    if (gameState && gameState.phase === 'discard') {
        await discardCard();
    } else {
        await playCard();
    }
}

async function toggleComputerHand() {
    try {
        const response = await fetch('/toggle_computer_hand', { method: 'POST' });
        if (response.ok) {
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error toggling computer hand:', error);
        showMessage('Error toggling computer hand', 'error');
    }
}

async function nextHand() {
    try {
        const response = await fetch('/next_hand', { method: 'POST' });
        if (response.ok) {
            if (trickDisplayTimeout) {
                clearTimeout(trickDisplayTimeout);
                trickDisplayTimeout = null;
            }
            selectedCard = null;
            resetBiddingState();
            resetTrickHistoryScroll();
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error starting next hand:', error);
        showMessage('Error starting next hand', 'error');
    }
}

async function startNewGame() {
    try {
        if (trickDisplayTimeout) {
            clearTimeout(trickDisplayTimeout);
            trickDisplayTimeout = null;
        }

        await fetch('/new_game', { method: 'POST' });
        selectedCard = null;
        resetBiddingState();
        resetTrickHistoryScroll();

        // Reset chat state for new game
        chatInitialized = false;

        await loadGameState();
    } catch (error) {
        console.error('Error starting new game:', error);
        showMessage('Error starting new game', 'error');
    }
}

// =============================================================================
// INITIALIZATION AND EVENT HANDLERS
// =============================================================================

document.addEventListener('DOMContentLoaded', function () {
    loadGameState();

    // Handle Enter key in chat input
    const chatInput = document.getElementById('chatInput');
    if (chatInput) {
        chatInput.addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
    }

    // Prevent zoom on double-tap for mobile
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function (event) {
        const now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300) {
            event.preventDefault();
        }
        lastTouchEnd = now;
    }, false);
});

// Auto-refresh with mobile-friendly timing
setInterval(() => {
    if (gameState && !gameState.game_over && !trickDisplayTimeout) {
        loadGameState();
    }
}, 2500);

// Handle orientation changes on mobile
window.addEventListener('orientationchange', function () {
    setTimeout(() => {
        updatePlayArea();
    }, 100);
});

================================================================================

FILE: ./static/manifest.json
--------------------------------------------------------------------------------
{
  "name": "Two-Man Spades",
  "short_name": "2ManSpades",
  "description": "Custom spades card game for two players",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#667eea",
  "theme_color": "#667eea",
  "icons": [
    {
      "src": "/static/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/static/icon-512.png", 
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}

================================================================================

FILE: ./templates/index.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Two-Player Spades</title>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-F5VP0CXERK"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-F5VP0CXERK');
    </script>

    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">

    <!-- PWA and Mobile App Settings -->
    <link rel="manifest" href="/static/manifest.json">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Two-Man Spades">
</head>

<body>
    <!-- Floating score headers -->
    <div class="floating-game-score" id="floatingGameScore">
        <div class="game-score-item">
            <div class="game-score-label">You</div>
            <div class="game-score-parity" id="floatingPlayerParity">(EVEN)</div>
            <div class="game-score-value" id="floatingPlayerScore">0</div>
        </div>
        <div class="game-score-item">
            <div class="game-score-label">Hand #<span id="floatingHandNumber">1</span></div>
        </div>
        <div class="game-score-item">
            <div class="game-score-label">Marta</div>
            <div class="game-score-parity" id="floatingComputerParity">(ODD)</div>
            <div class="game-score-value" id="floatingComputerScore">0</div>
        </div>
    </div>

    <div class="floating-hand-score" id="floatingHandScore">
        <div class="hand-score-item">
            <div class="label">Tricks</div>
            <div class="value" id="floatingPlayerTricks">0</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bid</div>
            <div class="value" id="floatingPlayerBid">-</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bags</div>
            <div class="value" id="floatingPlayerBags">0</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Spades</div>
            <div class="value" id="floatingSpadesStatus">Not Broken</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bags</div>
            <div class="value" id="floatingComputerBags">0</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bid</div>
            <div class="value" id="floatingComputerBid">-</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Tricks</div>
            <div class="value" id="floatingComputerTricks">0</div>
        </div>
    </div>

    <div class="container">
        <!-- Top interactive area -->
        <div class="top-interactive-area">
            <!-- Play area (hidden during bidding/discard phases) -->
            <div class="play-area" id="playArea">
                <div id="trickDisplay"></div>
            </div>

            <!-- Game Over section -->
            <div class="game-over" id="gameOver" style="display: none;">
                <div class="winner-text" id="winnerText"></div>
                <button onclick="startNewGame()">Play Again</button>
            </div>

            <!-- Message area -->
            <div class="message" id="message">Loading game...</div>

            <!-- Next Hand Button -->
            <div class="next-hand-section" id="nextHandSection" style="display: none;">
                <button id="nextHandButton" onclick="nextHand()" class="next-hand-btn">Next Hand</button>
            </div>

            <!-- Discarded cards section -->
            <div class="discards-section" id="discardsSection" style="display: none;">
                <div class="hand-title">Discarded Cards</div>
                <div class="discards-content">
                    <div class="discard-item">
                        <div class="discard-label">You</div>
                        <div id="playerDiscard"></div>
                    </div>
                    <div class="discard-item">
                        <div class="discard-label">Marta</div>
                        <div id="computerDiscard"></div>
                    </div>
                </div>
            </div>

            <!-- Results Section -->
            <div class="results-section" id="resultsSection">
                <div class="results-header">Hand Summary</div>
                <div class="results-content" id="resultsContent"></div>
            </div>

            <!-- Blind Decision Section -->
            <div class="blind-decision-section" id="blindDecisionSection" style="display: none;">
                <div class="blind-header">
                    <h3>Blind Bidding Decision</h3>
                    <p>You're down by 100+ points. Choose your approach:</p>
                </div>
                <div class="decision-buttons"
                    style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 12px;">
                    <button onclick="chooseBlindNil()"
                        style="background: #8b0000; color: white; padding: 12px 6px; border-radius: 6px; font-weight: bold; border: none; cursor: pointer; font-size: 11px;">
                        Blind NIL<br><small>Win or Die!</small>
                    </button>
                    <button onclick="chooseBlindBidding()"
                        style="background: #d32f2f; color: white; padding: 12px 6px; border-radius: 6px; font-weight: bold; border: none; cursor: pointer; font-size: 11px;">
                        Go BLIND<br><small>5-10 tricks</small>
                    </button>
                    <button onclick="chooseNormalBidding()"
                        style="background: #1976d2; color: white; padding: 12px 6px; border-radius: 6px; font-weight: bold; border: none; cursor: pointer; font-size: 11px;">
                        Bid Normal<br><small>See cards</small>
                    </button>
                </div>
            </div>

            <!-- Blind Bidding Section -->
            <div class="blind-bidding-section" id="discardBlindBiddingSection" style="display: none;">
                <div class="blind-header">
                    <h3>Choose Your Blind Bid</h3>
                    <p>You chose to go blind! Pick your bid amount for <strong>DOUBLE</strong> points/penalties!</p>
                    <div class="blind-warning">
                        Must bid at least 5 tricks, get double rewards or double punishment!
                    </div>
                </div>
                <div class="bid-buttons blind-buttons">
                    <button onclick="makeBlindBid(5)" class="blind-bid-btn">BLIND 5</button>
                    <button onclick="makeBlindBid(6)" class="blind-bid-btn">BLIND 6</button>
                    <button onclick="makeBlindBid(7)" class="blind-bid-btn">BLIND 7</button>
                    <button onclick="makeBlindBid(8)" class="blind-bid-btn">BLIND 8</button>
                    <button onclick="makeBlindBid(9)" class="blind-bid-btn">BLIND 9</button>
                    <button onclick="makeBlindBid(10)" class="blind-bid-btn">BLIND 10</button>
                </div>
            </div>

            <!-- Regular Bidding Section -->
            <div class="bidding-section" id="biddingSection" style="display: none;">
                <div class="bidding-title">Make Your Bid</div>
                <div class="bidding-prompt">How many tricks will you take?</div>

                <!-- 6x2 bidding buttons -->
                <div class="bid-buttons">
                    <button onclick="selectBid(0)" class="bid-btn" data-bid="0">0<br><small>NIL</small></button>
                    <button onclick="selectBid(1)" class="bid-btn" data-bid="1">1</button>
                    <button onclick="selectBid(2)" class="bid-btn" data-bid="2">2</button>
                    <button onclick="selectBid(3)" class="bid-btn" data-bid="3">3</button>
                    <button onclick="selectBid(4)" class="bid-btn" data-bid="4">4</button>
                    <button onclick="selectBid(5)" class="bid-btn" data-bid="5">5</button>
                    <button onclick="selectBid(6)" class="bid-btn" data-bid="6">6</button>
                    <button onclick="selectBid(7)" class="bid-btn" data-bid="7">7</button>
                    <button onclick="selectBid(8)" class="bid-btn" data-bid="8">8</button>
                    <button onclick="selectBid(9)" class="bid-btn" data-bid="9">9</button>
                    <button onclick="selectBid(10)" class="bid-btn" data-bid="10">10</button>
                </div>

                <!-- Confirmation buttons -->
                <div class="bid-confirmation-buttons" style="margin-top: 12px; text-align: center;">
                    <button id="confirmBidButton" onclick="confirmSelectedBid()" style="display: none;">
                        Confirm Bid
                    </button>
                    <button id="cancelBidButton" onclick="cancelBidSelection()" style="display: none;">
                        Cancel
                    </button>
                </div>
            </div>
        </div>

        <!-- Hands area -->
        <div class="hands-area">
            <!-- Player hand section -->
            <div class="hand-section" id="playerHandSection">
                <div class="hand-title">
                    Your Hand
                    <span style="font-size: 12px; color: #666; font-weight: normal;" id="playerHandCount"></span>
                </div>
                <div class="cards" id="playerHand"></div>
                <div class="controls">
                    <button id="actionButton" onclick="performAction()">Select Card</button>
                </div>
            </div>

            <!-- Computer hand section -->
            <div class="hand-section" id="computerHandSection">
                <div class="hand-title">
                    Marta's Hand (hidden)
                    <button id="toggleComputerHand" onclick="toggleComputerHand()" style="display: none;">Show
                        Cards</button>
                </div>
                <div class="cards" id="computerHand"></div>
            </div>
        </div>

        <!-- Bottom navigation -->
        <div class="bottom-section">
            <button class="bottom-new-game-btn" onclick="startNewGame()">New Game</button>
            <button class="bottom-rules-btn" onclick="window.open('/instructions', '_blank')">How to Play</button>
        </div>
    </div>

    <!-- Chat bubble icon (floating bottom right) -->
    <div class="chat-bubble-icon" id="chatBubbleIcon" onclick="toggleChat()">
        ðŸ’¬
        <div id="chatBadge" class="chat-badge" style="display: none;"></div>
    </div>

    <!-- Chat window (slides up from bottom) -->
    <div class="chat-window" id="chatWindow">
        <div class="chat-header">
            <span>Chat with Marta</span>
            <button class="chat-close" onclick="toggleChat()">Ã—</button>
        </div>
        <div class="chat-messages" id="chatMessages">
            <div class="marta-message">Hey there! Ready to play some spades?</div>
        </div>
        <div class="chat-input-area">
            <input type="text" id="chatInput" placeholder="Type a message..." maxlength="100">
            <button onclick="sendMessage()">Send</button>
        </div>
    </div>

    <script src="{{ url_for('static', filename='game.js') }}"></script>
</body>

</html>

================================================================================

FILE: ./templates/instructions.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How to Play Two-Man Spades</title>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-F5VP0CXERK"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-F5VP0CXERK');
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #4a5568;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        h2 {
            color: #2d3748;
            margin-top: 30px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e2e8f0;
        }

        h3 {
            color: #4a5568;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .section {
            margin-bottom: 25px;
        }

        .highlight {
            background: #fff5f5;
            border-left: 4px solid #e53e3e;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .tip {
            background: #f0fff4;
            border-left: 4px solid #38a169;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .example {
            background: #ebf8ff;
            border: 1px solid #90cdf4;
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
        }

        .card-example {
            display: inline-block;
            background: white;
            border: 2px solid #333;
            border-radius: 6px;
            padding: 8px 12px;
            margin: 2px;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
        }

        .spade {
            color: #000;
        }

        .heart {
            color: #ff0000;
        }

        .diamond {
            color: #ff6200;
        }

        .club {
            color: #333;
        }

        .scoring-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        .scoring-table th,
        .scoring-table td {
            border: 1px solid #cbd5e0;
            padding: 12px;
            text-align: left;
        }

        .scoring-table th {
            background: #edf2f7;
            font-weight: bold;
        }

        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #4299e1;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(66, 153, 225, 0.3);
        }

        .back-button:hover {
            background: #3182ce;
            transform: translateY(-2px);
        }

        ol,
        ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
        }

        .ai-update {
            background: #f0f8ff;
            border-left: 4px solid #4299e1;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
    </style>
</head>

<body>
    <a href="/" class="back-button">â† Back to Game</a>

    <div class="container">
        <h1>How to Play Two-Man Spades</h1>

        <div class="section">
            <div class="highlight">
                <h3>About This Game</h3>
                <p><strong>This is a custom variant developed over years of play.</strong> While based on traditional
                    Spades, this "Two-Man Spades" includes unique rules like parity scoring, special bag-reduction
                    cards, and blind bidding that don't exist in standard Spades. The game mechanics have been tested
                    and refined to be balanced and enjoyable, but this is essentially a "house rules" version.</p>
                <p><strong>Original invented rules:</strong> <a
                        href="https://docs.google.com/spreadsheets/d/1uxxzX09zhGm0b8R48Fi4vHvOEyrlp1AmVN-sN41voj0/edit?usp=sharing"
                        target="_blank" style="color: #3182ce;">Chicken-scratched 2manSpades rules...</a></p>
            </div>
        </div>

        <div class="section">
            <h2>Install as Mobile App</h2>
            <p>You can install Two-Man Spades as an app on your phone for a better full-screen experience:</p>

            <div class="tip">
                <strong>iPhone (Safari):</strong>
                <ol>
                    <li>Open the game in Safari</li>
                    <li>Tap the Share button (square with arrow up)</li>
                    <li>Scroll down and tap "Add to Home Screen"</li>
                    <li>Tap "Add" - the game icon will appear on your home screen</li>
                </ol>
            </div>

            <div class="tip">
                <strong>Android (Chrome):</strong>
                <ol>
                    <li>Open the game in Chrome</li>
                    <li>Tap the three dots menu (â‹®)</li>
                    <li>Tap "Add to Home Screen" or "Install app"</li>
                    <li>Tap "Add" - the game icon will appear on your home screen</li>
                </ol>
            </div>

            <p>Once installed, the game will open in full-screen mode without browser bars, just like a native app!</p>
        </div>

        <div class="section">
            <h2>Overview</h2>
            <p>Two-Man Spades is a trick-taking card game where you compete against Marta (the computer) to reach 300
                points first. Each hand, you'll discard one card, bid on how many tricks you think you can win, then
                play cards strategically to meet your bid while preventing your opponent from meeting theirs.</p>
        </div>

        <div class="section">
            <h2>Game Setup</h2>
            <p>At the start of each game, players are randomly assigned <strong>parity</strong>:</p>
            <ul>
                <li><strong>Even Player:</strong> Gets bonus points when discard pile totals an even number</li>
                <li><strong>Odd Player:</strong> Gets bonus points when discard pile totals an odd number</li>
            </ul>
            <p>Each hand deals 11 cards to each player from a standard 52-card deck.</p>
        </div>

        <div class="section">
            <h2>Hand Flow</h2>

            <h3>1. Discard Phase</h3>
            <p>Each player selects one card to discard face-down. These cards are revealed simultaneously and:</p>
            <ul>
                <li>Their face values are added together (Ace=1, Jack=11, Queen=12, King=13)</li>
                <li>The player whose parity matches the total gets bonus points</li>
                <li>If both cards are the same suit OR same rank, points are doubled</li>
                <li>Base bonus is 10 points (20 for doubles)</li>
            </ul>

            <div class="example">
                <strong>Example:</strong> You discard 7â™£ (value 7), Marta discards 6â™¥ (value 6).
                Total = 13 (odd). If you're the odd player, you get 10 points.
                If both cards were hearts, you'd get 20 points instead.
            </div>

            <h3>2. Bidding Phase</h3>
            <p>Players bid how many tricks (out of 10) they expect to win with their remaining cards.</p>

            <div class="highlight">
                <strong>Special Bidding Rules:</strong>
                <ul>
                    <li><strong>NIL (0 bid):</strong> If you take exactly 0 tricks, get +200 points. If you take any
                        tricks, lose -200 points and gain that many bags.</li>
                    <li><strong>Blind Bidding:</strong> When down by 100+ points, you can bid "blind" (5-10 tricks) for
                        double points/penalties before seeing your cards!</li>
                    <li><strong>Blind NIL:</strong> When down by 100+ points, you can attempt Blind NIL - if successful,
                        you instantly win the entire game. If you fail by taking any tricks, you instantly lose the
                        game!</li>
                </ul>
            </div>

            <h3>3. Playing Tricks</h3>
            <p>Players take turns playing cards. The person with the odd parity leads the first trick of each hand.</p>

            <h4>Playing Rules:</h4>
            <ul>
                <li><strong>Follow Suit:</strong> You must play the same suit as the lead card if you have it</li>
                <li><strong>Trump:</strong> Spades (â™ ) always beat other suits</li>
                <li><strong>Spades Broken:</strong> You can't lead spades until they've been "broken" by someone playing
                    a spade on a different suit</li>
                <li><strong>Highest Card Wins:</strong> Within the same suit, higher cards win (Ace is highest)</li>
            </ul>

            <div class="example">
                <strong>Trick Example:</strong> Marta leads <span class="card-example heart">Qâ™¥</span>.
                You have <span class="card-example heart">7â™¥</span> and <span class="card-example spade">3â™ </span>.
                You must play the 7â™¥ (follow suit). Marta wins with the higher heart.
            </div>
        </div>

        <div class="section">
            <h2>Scoring System</h2>

            <h3>Basic Scoring</h3>
            <table class="scoring-table">
                <tr>
                    <th>Situation</th>
                    <th>Points Earned</th>
                </tr>
                <tr>
                    <td>Made your bid exactly</td>
                    <td>Bid Ã— 10 points</td>
                </tr>
                <tr>
                    <td>Made more than your bid</td>
                    <td>Bid Ã— 10 points + 1 bag per extra trick</td>
                </tr>
                <tr>
                    <td>Failed to make your bid</td>
                    <td>Lose Bid Ã— 10 points</td>
                </tr>
                <tr>
                    <td>NIL success (0 bid, 0 tricks)</td>
                    <td>+200 points</td>
                </tr>
                <tr>
                    <td>NIL failure (0 bid, any tricks)</td>
                    <td>-200 points + tricks as bags</td>
                </tr>
                <tr>
                    <td>Blind bid success</td>
                    <td>Double normal points</td>
                </tr>
                <tr>
                    <td>Blind bid failure</td>
                    <td>Double normal penalty</td>
                </tr>
                <tr>
                    <td>Blind NIL success</td>
                    <td>INSTANT GAME WIN</td>
                </tr>
                <tr>
                    <td>Blind NIL failure</td>
                    <td>INSTANT GAME LOSS</td>
                </tr>
            </table>

            <h3>Bags System</h3>
            <p>Bags are penalties for taking more tricks than you bid:</p>
            <ul>
                <li>Every 7 bags = -100 points penalty</li>
                <li>Negative bags give bonuses: every 5 negative bags = +100 points</li>
                <li>Your score display shows base score + bags in the ones digit</li>
            </ul>

            <div class="tip">
                <strong>Bag Strategy:</strong> Sometimes it's better to let your opponent win a trick rather than
                accumulate bags, especially when you're close to a 7-bag penalty! Watch out - Marta now actively tries
                to force you to take unwanted tricks when you have 5+ bags.
            </div>
        </div>

        <div class="section">
            <h2>Special Cards</h2>
            <p>Two cards provide bag reduction when won in tricks or discard piles:</p>
            <ul>
                <li><span class="card-example diamond">7â™¦</span> Seven of Diamonds: -2 bags</li>
                <li><span class="card-example club">10â™£</span> Ten of Clubs: -1 bag</li>
            </ul>
            <p>The player who wins the trick or discard pile containing these cards gets the bag reduction.</p>
        </div>
        <h2>Winning the Game</h2>
        <p>The game ends when:</p>
        <ul>
            <li><strong>Target Reached:</strong> Someone reaches 300 points (higher display score wins)</li>
            <li><strong>Mercy Rule:</strong> Someone leads by 300+ points (automatic win)</li>
            <li><strong>Blind NIL:</strong> Successful Blind NIL instantly wins the game, failed Blind NIL instantly
                loses</li>
        </ul>

        <div class="highlight">
            <h3>Denial Rule - Keep the Game Alive!</h3>
            <p><strong>Critical mechanic:</strong> When someone would reach 300+ points from winning the discard pile,
                but they're currently losing the game, the DENIAL RULE automatically activates! Instead of gaining those
                discard points, their opponent LOSES those points instead. This keeps close games alive for another hand
                instead of ending on a lucky discard!</p>

            <div class="example">
                <strong>Example:</strong> You're at 295, Marta's at 305. You win the discard pile for 10 points, which
                would give you 305 and end the game. But since you're behind, DENIAL activates - Marta loses 10 points
                instead (drops to 295), and the game continues 295 to 295 for another hand!
            </div>
        </div>

        <h3>Game End Logic (When Either Player Hits 300+)</h3>
        <p><strong>Simple Rule: Higher display score ALWAYS wins, regardless of how you got there, and negative bags are
                BAD in this situation.</strong></p>

        <div class="example">
            <strong>Scenarios when both players are over 300:</strong>
            <ul>
                <li><strong>Player A:</strong> 302 display, <strong>Player B:</strong> 301 display â†’ <strong>Player A
                        wins</strong></li>
                <li><strong>Player A:</strong> 315 display, <strong>Player B:</strong> 320 display â†’ <strong>Player B
                        wins</strong></li>
                <li><strong>Player A:</strong> 300 display, <strong>Player B:</strong> 306 display â†’ <strong>Player B
                        wins</strong></li>
            </ul>
        </div>

        <h3>Tie-Breaking (Only When Display Scores Are Exactly Equal)</h3>
        <p>Display score ties are extremely rare and only occur when negative bags are involved:</p>
        <ol>
            <li>Player with higher base score wins</li>
            <li>If base scores are tied, player with more bags wins (more bags is better)</li>
            <li>If everything is exactly equal, the game ends in a tie</li>
        </ol>

        <div class="example">
            <strong>Realistic Tie-Breaking Examples:</strong>
            <ul>
                <li><strong>300 with -1 bags</strong> vs <strong>300 with 0 bags</strong> â†’ <strong>Player with 0 bags
                        wins</strong> (0 > -1)</li>
                <li><strong>300 with -4 bags</strong> vs <strong>300 with -2 bags</strong> â†’ <strong>Player with -2 bags
                        wins</strong> (-2 > -4)</li>
                <li><strong>310 with -3 bags</strong> vs <strong>320 with -4 bags </strong> â†’ <strong>Player with 320
                        and -4 bags wins</strong> (-1 < -4)</li>
            </ul>
            <p><strong>Why ties are rare:</strong> Positive bags always change the display score, so ties only happen
                when at least one player has negative bags.</p>
        </div>

        <h3>Bag System Limits</h3>
        <div class="tip">
            <strong>Automatic Bag Management:</strong>
            <ul>
                <li><strong>Maximum bags:</strong> 6 (7+ bags triggers -100 point penalty and resets to remainder)</li>
                <li><strong>Minimum bags:</strong> -4 (-5+ negative bags triggers +100 point bonus and resets to
                    remainder)</li>
                <li><strong>Tie-breaking hierarchy:</strong> 6 > 5 > 4 > 3 > 2 > 1 > 0 > -1 > -2 > -3 > -4</li>
                <li><strong>Key insight:</strong> Negative bags hurt in tie-breaking but never reduce your display score
                </li>
            </ul>
        </div>

        <h3>Why This System Works</h3>
        <div class="section">
            <p><strong>Strategic Depth:</strong> The display score system creates interesting decisions - negative bags
                don't hurt your visible score, but they're devastating in close games. Meanwhile, positive bags boost
                your display but can trigger painful penalties at 7+ bags. The denial rule prevents lucky discard wins
                when you're behind, ensuring skill matters more than chance in final moments.</p>

            <p><strong>Bottom Line:</strong> Highest display score wins when anyone hits 300+. Ties are nearly
                impossible due to the bag system, but when they occur, more bags (including negative bags closer to
                zero) provide the advantage.</p>
        </div>

        <div class="section">
            <h2>Advanced Features</h2>

            <h3>Auto-Resolution</h3>
            <p>When the outcome of remaining tricks is mathematically certain (like when one player has only spades and
                the other has none), the game automatically plays out the remaining cards to save time while showing you
                exactly what happened.</p>

            <h3>Smart AI Opponent</h3>
            <p>Marta now uses advanced strategy when she's made her bid - she'll lead high cards to force you into
                difficult decisions when you have lots of bags, and she'll strategically dump her dangerous high cards
                on tricks she's going to lose anyway. This creates realistic pressure similar to playing against an
                experienced human opponent.</p>
        </div>

        <div class="section">
            <h2>Strategy Tips</h2>

            <div class="tip">
                <strong>Bidding Strategy:</strong>
                <ul>
                    <li>Count your high spades - they're usually reliable tricks</li>
                    <li>Look for aces in other suits, but remember they can be trumped</li>
                    <li>Consider void suits (suits you have no cards in) - you can trump them</li>
                    <li>Be conservative when you have many bags</li>
                    <li>Consider Blind NIL as a last resort when far behind - it's all or nothing!</li>
                </ul>
            </div>

            <div class="tip">
                <strong>Playing Strategy:</strong>
                <ul>
                    <li>Try to force out high cards early when you're leading</li>
                    <li>Count cards to know what's still in play</li>
                    <li>Use your spades wisely - they're powerful but limited</li>
                    <li>Sometimes let your opponent win tricks if you've already made your bid</li>
                    <li>Be extra careful about bag management - Marta actively exploits your weaknesses!</li>
                </ul>
            </div>

            <div class="tip">
                <strong>Discard Strategy:</strong>
                <ul>
                    <li>Discard singleton special cards (7â™¦ or 10â™£) to create voids</li>
                    <li>Create voids in suits where you have spades to trump</li>
                    <li>Consider the parity game - sometimes a strategic discard can win you bonus points</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>Interface Guide</h2>
            <ul>
                <li><strong>Top Headers:</strong> Show game scores, hand number, and current hand status</li>
                <li><strong>Play Area:</strong> Shows current trick being played</li>
                <li><strong>Your Cards:</strong> Click to select, then use the action button</li>
                <li><strong>Results Summary:</strong> After each hand, review detailed scoring and trick history</li>
                <li><strong>Auto-Resolution Message:</strong> When remaining tricks are predetermined, you'll see
                    exactly what happened</li>
            </ul>
        </div>

        <div class="section">
            <div class="ai-update">
                <h3>Recent Improvement</h3>
                <p><strong>Marta now plays much smarter!</strong> When she's made her bid, she actively forces you into
                    difficult decisions by leading high cards when you have 5+ bags, and strategically dumps her highest
                    losing cards (like playing Queen instead of 2 when you lead King) to avoid getting stuck with
                    dangerous high cards later. This creates realistic pressure and makes bag management much more
                    challenging.</p>
            </div>
        </div>

        <div class="section">
            <p style="text-align: center; margin-top: 40px; font-style: italic; color: #666;">
                Two-Man Spades combines strategy, memory, and calculated risk-taking. Each hand is a puzzle to solve,
                and each game tells a story. With Marta's improved AI, you'll face tougher decisions and more realistic
                pressure. Good luck, and may your bids be true!
            </p>
        </div>
    </div>
</body>

</html>

================================================================================

