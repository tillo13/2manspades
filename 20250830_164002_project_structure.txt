Number of files: 9
Number of directories: 5

Directory structure:
.
static
templates
utilities
utilities/__pycache__

List of file paths by type:

CSS Files (1):
  ./static/style.css

HTML Files (1):
  ./templates/index.html

JS Files (1):
  ./static/game.js

PY Files (6):
  ./app.py
  ./gather_pythons.py
  ./gcloud_deploy.py
  ./utilities/computer_logic.py
  ./utilities/custom_rules.py
  ./utilities/gameplay_logic.py

================================================================================
FILE CONTENTS
================================================================================

FILE: ./gcloud_deploy.py
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Deployment script for Two Man Spades
This script manages deployment to Google App Engine for twomanspades project.
"""

import subprocess
import json
import time
import os
import sys
import random
import string

# Configuration - TWO MAN SPADES PROJECT SPECIFIC
EXPECTED_PROJECT_ID = "twomanspades"  # Critical: This must match your project
SERVICE_NAME = "default"
VERSION_MAX = 15  # Keep 15 versions to minimize storage costs

def print_separator():
    """Print a visual separator in console output."""
    print("\n" + "="*70 + "\n")

def check_gcloud_project():
    """Verify we're using the correct GCP project - CRITICAL SAFEGUARD."""
    print_separator()
    print("üîí VERIFYING GOOGLE CLOUD PROJECT CONFIGURATION...")
    print(f"Expected project: {EXPECTED_PROJECT_ID}")
    
    try:
        current_project = subprocess.run(
            ["gcloud", "config", "get-value", "project"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True
        ).stdout.decode().strip()
        
        print(f"Current project:  {current_project}")
        
        if current_project != EXPECTED_PROJECT_ID:
            print(f"‚ùå ERROR: Current gcloud project is '{current_project}' but expected '{EXPECTED_PROJECT_ID}'")
            print(f"üîÑ Attempting to switch to the correct project...")
            
            # Try to use an existing configuration first
            try:
                configs_result = subprocess.run(
                    ["gcloud", "config", "configurations", "list", "--format=value(name)"],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True
                )
                configs = configs_result.stdout.decode().strip().split('\n')
                
                if "twomanspades-config" in configs:
                    print("üìã Using existing twomanspades-config configuration")
                    subprocess.run(
                        ["gcloud", "config", "configurations", "activate", "twomanspades-config"],
                        check=True
                    )
                else:
                    print("‚öôÔ∏è  Setting project directly")
                    subprocess.run(
                        ["gcloud", "config", "set", "project", EXPECTED_PROJECT_ID],
                        check=True
                    )
            except subprocess.CalledProcessError:
                print("‚öôÔ∏è  Setting project directly")
                subprocess.run(
                    ["gcloud", "config", "set", "project", EXPECTED_PROJECT_ID],
                    check=True
                )
            
            # CRITICAL: Verify the switch was successful
            current_project = subprocess.run(
                ["gcloud", "config", "get-value", "project"],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True
            ).stdout.decode().strip()
            
            if current_project != EXPECTED_PROJECT_ID:
                print(f"‚ùå CRITICAL ERROR: Failed to switch to project {EXPECTED_PROJECT_ID}")
                print("üõë DEPLOYMENT ABORTED to prevent deploying to wrong project!")
                print("")
                print("Please manually set the project with one of these commands:")
                print(f"  gcloud config configurations activate twomanspades-config")
                print(f"  gcloud config set project {EXPECTED_PROJECT_ID}")
                print("")
                print("Then re-run this script.")
                sys.exit(1)
            else:
                print(f"‚úÖ Successfully switched to project {EXPECTED_PROJECT_ID}")
        else:
            print(f"‚úÖ Project verification passed - correctly configured for {EXPECTED_PROJECT_ID}")
    
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Error checking Google Cloud project: {e}")
        print("üõë DEPLOYMENT ABORTED")
        sys.exit(1)

# Function to get versions of a service
def get_versions(service_name):
    """Fetch the current versions of the App Engine service."""
    print(f"üìã Checking existing versions for service: {service_name}...")
    try:
        result = subprocess.run(
            ["gcloud", "app", "versions", "list", 
             "--service", service_name, 
             "--format", "json", 
             "--project", EXPECTED_PROJECT_ID],  # Always specify project
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        versions = json.loads(result.stdout)
        versions.sort(key=lambda x: x["version"]["createTime"], reverse=True)
        return versions
    except subprocess.CalledProcessError as e:
        if "Service not found" in e.stderr.decode() or f"Service [{service_name}] not found" in e.stderr.decode():
            print(f"üìù Service {service_name} not found. It will be created during deployment.")
            return []
        else:
            print(f"‚ùå Error getting versions: {e.stderr.decode()}")
            raise e

# Function to delete versions
def delete_old_versions(service_name, versions_to_delete):
    """Delete older versions to maintain version limit."""
    if not versions_to_delete:
        return
    
    print(f"üßπ Cleaning up old versions. Deleting {len(versions_to_delete)} older versions...")
    
    for v in versions_to_delete:
        version_id = v["id"]
        print(f"  - Deleting version {service_name}-{version_id}")
        subprocess.run(
            ["gcloud", "app", "versions", "delete", version_id, 
             "--service", service_name, 
             "--quiet", 
             "--project", EXPECTED_PROJECT_ID],  # Always specify project
            check=True)
    
    print("‚úÖ Cleanup complete.")

# Function to get changed files using git diff
def get_changed_files(directory):
    """Get list of new or modified files using git diff"""
    try:
        result = subprocess.run(
            ["git", "-C", directory, "diff", "--name-only", "HEAD^", "HEAD"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        files = result.stdout.decode().strip().split("\n")
        return [os.path.join(directory, f) for f in files if f]
    except subprocess.CalledProcessError:
        print("‚ÑπÔ∏è  Error determining changed files (this is normal for first deployment).")
        return []

def list_files_to_upload():
    """List files that will be uploaded to Google Cloud Storage."""
    print("üìÅ Files to be uploaded:")
    
    # Fallback: manually parse .gcloudignore and list files
    ignored_patterns = set()
    if os.path.exists('.gcloudignore'):
        with open('.gcloudignore', 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    ignored_patterns.add(line.rstrip('/'))
    
    # Default ignore patterns if no .gcloudignore exists
    if not ignored_patterns:
        ignored_patterns = {
            '.git', '__pycache__', '*.pyc', '.env', 'venv*', 
            '.vscode', '.idea', '*.md', 'gather_pythons.py', 
            '*_project_structure.txt'
        }
    
    # Walk directory and respect .gcloudignore patterns
    files_to_upload = []
    for root, dirs, files in os.walk('.'):
        # Remove ignored directories from dirs to prevent walking into them
        dirs[:] = [d for d in dirs if not any(
            d == pattern or f"{root}/{d}".startswith(f"./{pattern}")
            for pattern in ignored_patterns
        )]
        
        for file in files:
            rel_path = os.path.relpath(os.path.join(root, file), '.')
            # Skip if file matches any ignore pattern
            if not any(
                rel_path.startswith(pattern) or file.endswith(pattern.lstrip('*'))
                for pattern in ignored_patterns
            ):
                files_to_upload.append(rel_path)
    
    # Print the files
    for file in sorted(files_to_upload):
        print(f"  - {file}")
    
    print(f"\nüìä Total files to upload: {len(files_to_upload)}")

# Function to generate a valid version name
def generate_version_name():
    random_string = ''.join(random.choices(string.ascii_lowercase + string.digits, k=10))
    return f"version-{random_string}"

# Function to deploy the services
def deploy_service(service_name, yaml_path):
    """Deploy the application to Google App Engine."""
    start_time = time.time()
    current_directory = os.path.dirname(os.path.abspath(yaml_path))
    
    print_separator()
    print(f"üöÄ DEPLOYING TWO MAN SPADES TO GOOGLE APP ENGINE")
    print(f"üì¶ Project: {EXPECTED_PROJECT_ID}")
    print(f"‚öôÔ∏è  Service: {service_name}")
    print(f"üìÇ Deploy from: {current_directory}")
    print(f"üìÑ Using config: {yaml_path}")
    print_separator()
    
    # List changed files
    print("üìù Listing new or modified files to be uploaded:")
    changed_files = get_changed_files(current_directory)
    if changed_files:
        for file_path in changed_files:
            print(f"  üìÑ Changed file: {file_path}")
    else:
        print("  ‚ÑπÔ∏è  No new or modified files detected (normal for first deployment).")
    
    # Check the current versions
    try:
        versions = get_versions(service_name)
        print(f"‚úÖ {len(versions)} versions retrieved successfully.")
    except subprocess.CalledProcessError as e:
        versions = []
        print(f"‚ö†Ô∏è  Failed to get versions. Error: {e}")
        print(f"üìù First deployment for service {service_name}. Proceeding with deployment.")
    
    print(f"üìä You currently have {len(versions)} versions for {service_name}.")
    if versions:
        print(f"üìã The latest version is {versions[0]['id']} for {service_name}.")
    
    if len(versions) > VERSION_MAX:
        print(f"üßπ More than {VERSION_MAX} versions exist for {service_name}.")
    
    # Show files that will be uploaded
    print_separator()
    list_files_to_upload()
    
    # Deploy new version
    print_separator()
    version_name = generate_version_name()
    print(f"üöÄ Deploying new version: {version_name}")
    try:
        result = subprocess.run([
            "gcloud", "app", "deploy", yaml_path, 
            "--quiet", 
            "--project", EXPECTED_PROJECT_ID,  # Always specify project
            "--version", version_name
        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        print("‚úÖ Deployment successful!")
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Failed to deploy new version. Error: {e.stderr.decode()}")
        return  # Early exit if deployment fails
    
    # Delete old versions if needed
    if len(versions) > VERSION_MAX:
        print_separator()
        try:
            # Get fresh list of versions after deployment
            updated_versions = get_versions(service_name)
            versions_to_delete = updated_versions[VERSION_MAX:]
            delete_old_versions(service_name, versions_to_delete)
        except subprocess.CalledProcessError as e:
            print(f"‚ö†Ô∏è  Failed to delete old versions. Error: {e.stderr.decode()}")

    # Calculate and display execution time
    end_time = time.time()
    execution_time = end_time - start_time
    
    # Display the target URL
    print_separator()
    print(f"‚è±Ô∏è  Deployment completed in {execution_time:.2f} seconds.")
    print(f"üåê Your Two Man Spades game is now live at:")
    print(f"  - https://{EXPECTED_PROJECT_ID}.appspot.com")
    print_separator()

# Main deployment function
def main_deploy():
    # CRITICAL: Verify project before doing ANYTHING
    check_gcloud_project()
    
    # Deploy the service
    deploy_service(SERVICE_NAME, 'app.yaml')
    
    # Automatically tail logs
    print(f"\nüìã Tailing logs... (Press Ctrl+C to stop)")
    try:
        subprocess.run([
            "gcloud", "app", "logs", "tail",
            "--service", SERVICE_NAME,
            "--project", EXPECTED_PROJECT_ID  # Always specify project
        ])
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è  Stopped tailing logs.")
        print(f"üìã You can view logs anytime with: gcloud app logs tail -s {SERVICE_NAME} --project {EXPECTED_PROJECT_ID}")

if __name__ == "__main__":
    print(f"üîí You have chosen to keep {VERSION_MAX} versions of your app.")
    main_deploy()

================================================================================

FILE: ./app.py
--------------------------------------------------------------------------------
from flask import Flask, render_template, request, session, jsonify
import sys
import os

# Add utilities directory to path if running as main
if __name__ == '__main__':
    sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from utilities.gameplay_logic import (
    init_game,
    init_new_hand,
    sort_hand,
    is_valid_play,
    resolve_trick_with_delay,
    computer_follow,
    computer_lead,
    check_game_over
)

from utilities.custom_rules import (
    assign_even_odd_at_game_start,
    calculate_discard_score_with_winner,
    calculate_hand_scores_with_bags,
    get_player_names_with_parity,
    check_special_cards_in_discard,
    reduce_bags_safely,
    check_blind_bidding_eligibility
)

from utilities.computer_logic import (
    computer_bidding_brain,
    computer_discard_strategy
)

app = Flask(__name__)
app.secret_key = 'your-secret-key-change-this'

DEBUG_MODE = False  # Set to False to hide Marta's cards completely

# In the index() route:
@app.route('/')
def index():
    # Always start completely fresh
    session.clear()
    player_parity, computer_parity, first_player = assign_even_odd_at_game_start()
    session['game'] = init_game(player_parity, computer_parity, first_player)
    return render_template('index.html')




# In the get_state() route, modify the safe_state dict:
@app.route('/state')
def get_state():
    if 'game' not in session:
        player_parity, computer_parity = assign_even_odd_at_game_start()
        session['game'] = init_game(player_parity, computer_parity)
    
    game = session['game']
    
    # Get player names with parity
    player_name, computer_name = get_player_names_with_parity(
        game.get('player_parity', 'even'),
        game.get('computer_parity', 'odd')
    )
    
    # Only show discard_bonus_explanation if hand is over
    show_discard_explanation = game.get('hand_over', False)
    discard_explanation = game.get('discard_bonus_explanation') if show_discard_explanation else None
    
    # Prepare safe state
    safe_state = {
        'player_hand': game['player_hand'],
        'computer_hand_count': len(game['computer_hand']),
        'current_trick': game['current_trick'],
        'player_tricks': game['player_tricks'],
        'computer_tricks': game['computer_tricks'],
        'spades_broken': game['spades_broken'],
        'phase': game['phase'],
        'turn': game['turn'],
        'trick_leader': game.get('trick_leader'),
        'hand_over': game.get('hand_over', False),
        'game_over': game.get('game_over', False),
        'winner': game['winner'],
        'message': game['message'],
        'player_discarded': game.get('player_discarded'),
        'computer_discarded': game.get('computer_discarded'),
        'show_computer_hand': game.get('show_computer_hand', False) and DEBUG_MODE,  # Hide if DEBUG_MODE=False
        'player_bid': game.get('player_bid'),
        'computer_bid': game.get('computer_bid'),
        'total_tricks': game.get('total_tricks', 10),
        'player_score': game.get('player_score', 0),
        'computer_score': game.get('computer_score', 0),
        'player_bags': game.get('player_bags', 0),
        'computer_bags': game.get('computer_bags', 0),
        'hand_number': game.get('hand_number', 1),
        'target_score': game.get('target_score', 300),
        'player_parity': game.get('player_parity', 'even'),
        'computer_parity': game.get('computer_parity', 'odd'),
        'player_name': player_name,
        'computer_name': computer_name,
        'discard_bonus_explanation': discard_explanation,
        'blind_bidding_available': game.get('blind_bidding_available', False),
        'blind_bid': game.get('blind_bid'),
        'computer_blind_bid': game.get('computer_blind_bid'),
        'debug_mode': DEBUG_MODE  # Send debug mode state to frontend
    }
    
    # Include computer hand only if debug mode is on AND showing
    if DEBUG_MODE and game.get('show_computer_hand', False):
        safe_state['computer_hand'] = game['computer_hand']
    
    return jsonify(safe_state)

# Modify the toggle_computer_hand route:
@app.route('/toggle_computer_hand', methods=['POST'])
def toggle_computer_hand():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    # Don't allow toggling if debug mode is off
    if not DEBUG_MODE:
        return jsonify({'error': 'Debug mode disabled'}), 400
    
    game = session['game']
    game['show_computer_hand'] = not game.get('show_computer_hand', False)
    session.modified = True
    
    return jsonify({'success': True, 'showing': game['show_computer_hand']})

@app.route('/blind_bid', methods=['POST'])
def make_blind_bid():
    """Handle blind bidding before discard phase"""
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    game = session['game']
    data = request.get_json()
    bid = data.get('bid')
    
    if game['phase'] != 'discard':
        return jsonify({'error': 'Can only make blind bid before discard'}), 400
    
    # Check blind bidding eligibility
    blind_eligibility = check_blind_bidding_eligibility(
        game.get('player_score', 0),
        game.get('computer_score', 0)
    )
    
    if not blind_eligibility['player_eligible']:
        return jsonify({'error': 'Not eligible for blind bidding'}), 400
    
    if bid < 5 or bid > 10:
        return jsonify({'error': 'Blind bid must be between 5 and 10'}), 400
    
    # Set blind bid and regular bid
    game['blind_bid'] = bid
    game['player_bid'] = bid
    
    # Computer makes its decision (might also go blind if eligible)
    computer_bid, computer_is_blind = computer_bidding_brain(
        game['computer_hand'], 
        bid, 
        game
    )
    game['computer_bid'] = computer_bid
    
    if computer_is_blind:
        game['computer_blind_bid'] = computer_bid
    
    # Now proceed to discard with bids already set
    player_blind_text = " (BLIND)"
    computer_blind_text = " (BLIND)" if computer_is_blind else ""
    game['message'] = f'You bid {bid}{player_blind_text}, Marta bid {computer_bid}{computer_blind_text}. Now select a card to discard.'
    
    # Stay in discard phase but with bids set
    session.modified = True
    return jsonify({'success': True})

@app.route('/bid', methods=['POST'])
def make_bid():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    game = session['game']
    data = request.get_json()
    bid = data.get('bid')
    
    if game['phase'] != 'bidding':
        return jsonify({'error': 'Not in bidding phase'}), 400
    
    if bid < 0 or bid > 10:
        return jsonify({'error': 'Bid must be between 0 and 10'}), 400
    
    # Player makes regular bid
    game['player_bid'] = bid
    
    # Computer makes intelligent bid using enhanced brain
    computer_bid, computer_is_blind = computer_bidding_brain(
        game['computer_hand'], 
        bid, 
        game
    )
    game['computer_bid'] = computer_bid
    
    # Handle computer blind bid
    if computer_is_blind:
        game['computer_blind_bid'] = computer_bid
    
    # Start playing phase with the designated first leader
    game['phase'] = 'playing'
    first_leader = game.get('first_leader', 'player')
    game['turn'] = first_leader
    game['trick_leader'] = first_leader
    
    # Create message indicating who leads first
    player_blind_text = " (BLIND)" if game.get('blind_bid') == bid else ""
    computer_blind_text = " (BLIND)" if computer_is_blind else ""
    
    if first_leader == 'player':
        game['message'] = f'You bid {bid}{player_blind_text}, Marta bid {computer_bid}{computer_blind_text}. Your turn to lead the first trick.'
    else:
        game['message'] = f'You bid {bid}{player_blind_text}, Marta bid {computer_bid}{computer_blind_text}. Marta leads the first trick.'
        # If computer leads, make the computer play immediately
        computer_lead(game)
        game['turn'] = 'player'
        game['message'] = f'You bid {bid}{player_blind_text}, Marta bid {computer_bid}{computer_blind_text}. Marta led. Your turn to follow.'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/discard', methods=['POST'])
def discard_card():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    game = session['game']
    data = request.get_json()
    card_index = data.get('index')
    
    if game['phase'] != 'discard':
        return jsonify({'error': 'Not in discard phase'}), 400
    
    if card_index < 0 or card_index >= len(game['player_hand']):
        return jsonify({'error': 'Invalid card index'}), 400
    
    # Player discards
    game['player_discarded'] = game['player_hand'].pop(card_index)
    
    # Computer discards using enhanced strategy
    idx = computer_discard_strategy(game['computer_hand'], game)
    game['computer_discarded'] = game['computer_hand'].pop(idx)
    
    # Calculate discard bonus points and determine winner
    discard_result = calculate_discard_score_with_winner(
        game['player_discarded'],
        game['computer_discarded'],
        game.get('player_parity', 'even'),
        game.get('computer_parity', 'odd')
    )
    
    # Store discard results for later reveal
    game['pending_discard_result'] = discard_result
    
    # Check for special cards in discards and store for later
    special_discard_result = check_special_cards_in_discard(
        game['player_discarded'],
        game['computer_discarded'],
        discard_result['winner']
    )
    
    game['pending_special_discard_result'] = special_discard_result
    
    # Check if bids were already made (blind bidding scenario)
    if game.get('player_bid') is not None:
        # Bids already set, go straight to playing
        game['phase'] = 'playing'
        game['turn'] = 'player'
        game['trick_leader'] = 'player'
        
        player_blind_text = " (BLIND)" if game.get('blind_bid') else ""
        computer_blind_text = " (BLIND)" if game.get('computer_blind_bid') else ""
        game['message'] = f'Cards discarded. You bid {game["player_bid"]}{player_blind_text}, Marta bid {game["computer_bid"]}{computer_blind_text}. Your turn to lead the first trick.'
    else:
        # Normal flow - check if player is eligible for blind bidding
        blind_eligibility = check_blind_bidding_eligibility(
            game.get('player_score', 0),
            game.get('computer_score', 0)
        )
        
        if blind_eligibility['player_eligible']:
            game['blind_bidding_available'] = True
            game['message'] = f'Cards discarded. You are down by {blind_eligibility["player_deficit"]} points - would you like to go BLIND? (5-10 tricks, double points/penalties) Or make a regular bid? (0-10)'
        else:
            game['blind_bidding_available'] = False
            game['message'] = f'Cards discarded. Now make your bid: How many tricks will you take? (0-10)'
        
        # Start bidding phase
        game['phase'] = 'bidding'
        game['turn'] = 'player'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/play', methods=['POST'])
def play_card():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    game = session['game']
    data = request.get_json()
    card_index = data.get('index')
    
    if game['phase'] != 'playing':
        return jsonify({'error': 'Not in playing phase'}), 400
    
    if game['turn'] != 'player':
        return jsonify({'error': 'Not your turn'}), 400
    
    if card_index < 0 or card_index >= len(game['player_hand']):
        return jsonify({'error': 'Invalid card index'}), 400
    
    card = game['player_hand'][card_index]
    
    # Validate the play
    if not is_valid_play(card, game['player_hand'], game['current_trick'], game['spades_broken']):
        return jsonify({'error': 'Invalid play - must follow suit if possible'}), 400
    
    # Play the card
    game['player_hand'].pop(card_index)
    game['current_trick'].append({'player': 'player', 'card': card})
    
    if card['suit'] == '‚ô†':
        game['spades_broken'] = True
    
    # Determine next action based on trick state
    if len(game['current_trick']) == 1:
        # Player just led, computer needs to follow
        game['trick_leader'] = 'player'
        game['turn'] = 'computer'
        computer_follow(game)
        # After computer follows, resolve the trick with delay
        resolve_trick_with_delay(game)
    elif len(game['current_trick']) == 2:
        # This shouldn't happen in normal flow, but handle it
        resolve_trick_with_delay(game)
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/clear_trick', methods=['POST'])
def clear_trick():
    """Called by frontend after displaying trick for 3 seconds"""
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    game = session['game']
    
    if not game.get('trick_completed'):
        return jsonify({'error': 'No completed trick to clear'}), 400
    
    winner = game.get('trick_winner')
    
    # Clear the trick
    game['current_trick'] = []
    game['trick_completed'] = False
    game['trick_winner'] = None
    
    # Check for hand over
    if len(game['player_hand']) == 0:
        game['hand_over'] = True
        
        # Apply stored discard results at the end of the hand
        if 'pending_discard_result' in game:
            discard_result = game['pending_discard_result']
            game['player_score'] += discard_result['player_bonus']
            game['computer_score'] += discard_result['computer_bonus']
            
            # Apply special card effects from discards
            if 'pending_special_discard_result' in game:
                special_discard_result = game['pending_special_discard_result']
                
                if special_discard_result['player_bag_reduction'] > 0:
                    game['player_bags'] = reduce_bags_safely(
                        game.get('player_bags', 0), 
                        special_discard_result['player_bag_reduction']
                    )
                
                if special_discard_result['computer_bag_reduction'] > 0:
                    game['computer_bags'] = reduce_bags_safely(
                        game.get('computer_bags', 0), 
                        special_discard_result['computer_bag_reduction']
                    )
                
                # Store explanation for the final message
                game['discard_bonus_explanation'] = discard_result['explanation']
                if special_discard_result['explanation']:
                    game['discard_bonus_explanation'] += " | " + special_discard_result['explanation']
            else:
                game['discard_bonus_explanation'] = discard_result['explanation']
            
            # Clean up pending results
            del game['pending_discard_result']
            if 'pending_special_discard_result' in game:
                del game['pending_special_discard_result']
        
        # Calculate scoring with bags system
        scoring_result = calculate_hand_scores_with_bags(game)
        
        # Build comprehensive final message
        message_parts = []
        
        # Hand completion header
        message_parts.append(f"Hand #{game['hand_number']} complete!")
        
        # Show parity assignments
        player_parity = game.get('player_parity', 'even').title()
        computer_parity = game.get('computer_parity', 'odd').title()
        message_parts.append(f"Tom ({player_parity}) vs Marta ({computer_parity})")
        
        # Show discard bonus details
        discard_explanation = game.get('discard_bonus_explanation')
        if discard_explanation and discard_explanation != 'No discards to score':
            message_parts.append(f"DISCARD PILE REVEALS: {discard_explanation}")
        
        # Add the comprehensive scoring explanation
        message_parts.append(scoring_result['explanation'])
        
        # Show running totals
        totals = f"Game totals: Tom {game['player_score']}, Marta {game['computer_score']}"
        message_parts.append(totals)
        
        # Add instruction
        message_parts.append("Click 'Next Hand' to continue")
        
        # Join all parts with separators
        game['message'] = " | ".join(message_parts)
        
        # Check if game is over
        check_game_over(game)
        
    elif winner == 'computer':
        # Computer won last trick, so computer leads
        computer_lead(game)
        game['turn'] = 'player'
        game['message'] = 'Marta led. Your turn to follow.'
    else:
        # Player won last trick, player leads next
        game['turn'] = 'player'
        game['message'] = 'You won the trick! Your turn to lead.'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/next_hand', methods=['POST'])
def next_hand():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    game = session['game']
    
    if not game.get('hand_over', False) or game.get('game_over', False):
        return jsonify({'error': 'Cannot start next hand'}), 400
    
    # Increment hand number and start new hand
    game['hand_number'] += 1
    init_new_hand(game)
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/new_game', methods=['POST'])
def new_game():
    # Assign new even/odd and first player for the new game
    player_parity, computer_parity, first_player = assign_even_odd_at_game_start()
    session['game'] = init_game(player_parity, computer_parity, first_player)
    return jsonify({'success': True})

if __name__ == '__main__':
    import subprocess
    import webbrowser
    import time
    import socket
    
    # Kill existing processes on port 5000
    try:
        result = subprocess.run(['lsof', '-ti:5000'], capture_output=True, text=True)
        if result.stdout.strip():
            pids = result.stdout.strip().split('\n')
            for pid in pids:
                if pid.strip():
                    subprocess.run(['kill', '-9', pid.strip()])
                    print(f"Killed process {pid.strip()} on port 5000")
            time.sleep(1)
    except FileNotFoundError:
        try:
            result = subprocess.run(['netstat', '-ano'], capture_output=True, text=True)
            for line in result.stdout.split('\n'):
                if ':5000' in line and 'LISTENING' in line:
                    parts = line.split()
                    pid = parts[-1]
                    subprocess.run(['taskkill', '/F', '/PID', pid], capture_output=True)
                    print(f"Killed process {pid} on port 5000")
                    time.sleep(1)
        except:
            pass
    except Exception as e:
        print(f"Could not check for existing processes: {e}")
    
    # Check if port is still in use and find an alternative
    port = 5000
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(1)
    
    for p in range(5000, 5011):
        result = sock.connect_ex(('localhost', p))
        if result != 0:
            port = p
            break
    sock.close()
    
    if port != 5000:
        print(f"Port 5000 is in use, using port {port} instead")
    
    def open_browser():
        time.sleep(1.5)
        url = f'http://localhost:{port}'
        
        chrome_paths = [
            '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',
            'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe',
            'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
            '/usr/bin/google-chrome',
            '/usr/bin/chromium-browser',
        ]
        
        opened = False
        for chrome_path in chrome_paths:
            if os.path.exists(chrome_path):
                try:
                    subprocess.Popen([chrome_path, url])
                    print(f"Opened Chrome at {url}")
                    opened = True
                    break
                except:
                    pass
        
        # If Chrome wasn't found, use default browser
        if not opened:
            webbrowser.open(url)
            print(f"Opened default browser at {url}")
    
    # Start browser opening in a separate thread
    from threading import Thread
    browser_thread = Thread(target=open_browser)
    browser_thread.daemon = True
    browser_thread.start()
    
    print(f"Starting Flask app on port {port}...")
    print(f"The browser should open automatically in a moment...")
    print(f"If not, navigate to http://localhost:{port}")
    
    # Run Flask app
    app.run(debug=True, port=port, use_reloader=False)

================================================================================

FILE: ./gather_pythons.py
--------------------------------------------------------------------------------
import os
from datetime import datetime

# Configuration
# Set file types to include
FILE_EXTENSIONS = [
    '.py',    # Python files (always included)
    '.html',  # HTML files
    '.js',    # JavaScript files
    '.css',   # CSS files
    '.json',  # JSON configuration files
]

# Flag to control directory depth
ONLY_ROOT_DIRECTORY = False  # Set to True to only search in root directory

# Filename patterns to exclude (new)
EXCLUDED_FILENAME_PATTERNS = [
    'copy',   # Any file with 'copy' in the name
    'backup', # Any file with 'backup' in the name
    'temp',   # Any file with 'temp' in the name
        'archives',   # Any file with 'temp' in the name
]

# Directories to completely exclude from both scanning and output
EXCLUDED_DIRECTORIES = [
    "assets",
    "tests",
    "previous_versions",
    "projects",
    "tools",
    "revisions_app",
    "venv_de",
    ".git",
    "archives"

]

def gather_files(root_dir, excluded_directories, file_extensions, excluded_patterns, only_root=False):
    """
    Gathers files with specified extensions within the root directory and its subdirectories,
    excluding specified directories and filename patterns.

    Parameters:
        root_dir (str): The root directory to search for files.
        excluded_directories (list): List of directory names to exclude.
        file_extensions (list): List of file extensions to include.
        excluded_patterns (list): List of filename patterns to exclude.
        only_root (bool): If True, only search in the root directory (no subdirectories).

    Returns:
        tuple: (files_data, included_directories)
    """
    files_data = []
    included_directories = set()

    if only_root:
        # Only process files in the root directory
        relative_path = "."
        included_directories.add(relative_path)
        
        try:
            filenames = os.listdir(root_dir)
            for filename in filenames:
                file_path = os.path.join(root_dir, filename)
                
                # Skip directories
                if os.path.isdir(file_path):
                    continue
                
                # Skip files with excluded patterns in the filename
                if any(pattern.lower() in filename.lower() for pattern in excluded_patterns):
                    continue
                    
                # Only include files with the specified extensions
                if any(filename.endswith(ext) for ext in file_extensions):
                    try:
                        with open(file_path, 'r', encoding='utf-8') as file:
                            file_contents = file.read()
                        files_data.append((file_path, file_contents))
                    except UnicodeDecodeError:
                        print(f"Could not read file {file_path} due to encoding error. Skipping.")
                    except Exception as e:
                        print(f"Error with file {file_path}: {e}")
        except Exception as e:
            print(f"Error accessing root directory: {e}")
    else:
        # Original recursive behavior
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Get the relative path
            relative_path = os.path.relpath(dirpath, root_dir)
            
            # Skip excluded directories - check if any part of the path matches exclusion patterns
            should_exclude = False
            for excluded_dir in excluded_directories:
                # Check both exact match and path-based matches
                if excluded_dir == relative_path or excluded_dir in relative_path.replace('\\', '/'):
                    should_exclude = True
                    break
                    
            if should_exclude:
                continue

            # Add directory to our structure
            included_directories.add(relative_path)
            
            # Process files
            for filename in filenames:
                file_path = os.path.join(dirpath, filename)
                
                # Skip files with excluded patterns in the filename
                if any(pattern.lower() in filename.lower() for pattern in excluded_patterns):
                    continue
                    
                # Only include files with the specified extensions
                if any(filename.endswith(ext) for ext in file_extensions):
                    try:
                        with open(file_path, 'r', encoding='utf-8') as file:
                            file_contents = file.read()
                        files_data.append((file_path, file_contents))
                    except UnicodeDecodeError:
                        print(f"Could not read file {file_path} due to encoding error. Skipping.")
                    except Exception as e:
                        print(f"Error with file {file_path}: {e}")

    return files_data, sorted(included_directories)

def write_to_file(output_filepath, files_data, included_directories):
    """
    Writes the gathered data to a file with project information and file contents.
    """
    with open(output_filepath, 'w', encoding='utf-8') as file:
        # Write statistics
        file.write(f"Number of files: {len(files_data)}\n")
        file.write(f"Number of directories: {len(included_directories)}\n\n")
        
        # Write directory structure
        file.write("Directory structure:\n")
        for directory in included_directories:
            file.write(f"{directory}\n")
        file.write("\n")
        
        # Group and list files by extension
        extension_groups = {}
        for filepath, _ in files_data:
            ext = os.path.splitext(filepath)[1].lower()
            if ext not in extension_groups:
                extension_groups[ext] = []
            extension_groups[ext].append(filepath)
        
        file.write("List of file paths by type:\n")
        for ext, filepaths in sorted(extension_groups.items()):
            file.write(f"\n{ext.upper()[1:]} Files ({len(filepaths)}):\n")
            for filepath in sorted(filepaths):
                file.write(f"  {filepath}\n")
        file.write("\n")
        
        # Write file contents
        file.write("="*80 + "\n")
        file.write("FILE CONTENTS\n")
        file.write("="*80 + "\n\n")
        
        for filepath, file_contents in files_data:
            file.write(f"FILE: {filepath}\n")
            file.write("-"*80 + "\n")
            file.write(f"{file_contents}\n\n")
            file.write("="*80 + "\n\n")

def scan_project_structure():
    """
    Main function to scan the project structure and write the results to a file.
    """
    root_dir = "."  # Current directory
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_filepath = f"{timestamp}_project_structure.txt"
    
    print(f"Starting to scan project structure at {root_dir}...")
    print(f"Including file types: {', '.join(FILE_EXTENSIONS)}")
    print(f"Excluding file patterns: {', '.join(EXCLUDED_FILENAME_PATTERNS)}")
    
    if ONLY_ROOT_DIRECTORY:
        print("Scanning ONLY root directory (subdirectories will be skipped)")
    else:
        print(f"Excluding directories: {', '.join(EXCLUDED_DIRECTORIES)}")
    
    # Gather files and directory information
    files_data, included_directories = gather_files(
        root_dir, 
        EXCLUDED_DIRECTORIES, 
        FILE_EXTENSIONS,
        EXCLUDED_FILENAME_PATTERNS,
        only_root=ONLY_ROOT_DIRECTORY
    )
    
    print(f"Found {len(files_data)} files across {len(included_directories)} directories.")
    if not ONLY_ROOT_DIRECTORY:
        print(f"Excluded directories won't appear in the output file.")
    
    # Write the output file
    write_to_file(
        output_filepath, 
        files_data, 
        included_directories
    )
    
    print(f"Project structure has been written to {output_filepath}")
    print(f"File size: {os.path.getsize(output_filepath) / (1024*1024):.2f} MB")

if __name__ == "__main__":
    scan_project_structure()

================================================================================

FILE: ./utilities/gameplay_logic.py
--------------------------------------------------------------------------------
import random

def create_deck():
    """Create a standard 52-card deck"""
    suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£']
    ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
    deck = []
    for suit in suits:
        for rank in ranks:
            deck.append({'rank': rank, 'suit': suit, 'value': get_card_value(rank)})
    return deck

def get_card_value(rank):
    """Get numerical value of a card rank"""
    if rank == 'A':
        return 14
    elif rank == 'K':
        return 13
    elif rank == 'Q':
        return 12
    elif rank == 'J':
        return 11
    else:
        return int(rank)

def sort_hand(hand):
    """Sort hand by suit (clubs, diamonds, hearts, spades) then by value"""
    suit_order = {'‚ô£': 0, '‚ô¶': 1, '‚ô•': 2, '‚ô†': 3}
    return sorted(hand, key=lambda x: (suit_order[x['suit']], x['value']))

def init_game(player_parity='even', computer_parity='odd', first_leader='player'):
    """Initialize a new game"""
    deck = create_deck()
    random.shuffle(deck)
    
    return {
        'player_hand': sort_hand(deck[:11]),
        'computer_hand': sort_hand(deck[11:22]),
        'current_trick': [],
        'player_tricks': 0,
        'computer_tricks': 0,
        'spades_broken': False,
        'phase': 'discard',
        'turn': 'player',  # Both players can discard simultaneously
        'trick_leader': None,
        'hand_over': False,
        'game_over': False,
        'winner': None,
        'message': 'Select a card to discard',
        'player_discarded': None,
        'computer_discarded': None,
        'show_computer_hand': False,
        'trick_display_timer': None,
        'player_bid': None,
        'computer_bid': None,
        'total_tricks': 10,
        'player_score': 0,
        'computer_score': 0,
        'player_bags': 0,
        'computer_bags': 0,
        'player_trick_special_cards': 0,
        'computer_trick_special_cards': 0,
        'hand_number': 1,
        'target_score': 300,
        'player_parity': player_parity,
        'computer_parity': computer_parity,
        'first_leader': first_leader,  # Who leads the first trick of each hand
        'discard_bonus_explanation': None,
        'pending_discard_result': None,
        'pending_special_discard_result': None,
        'blind_bidding_available': False,
        'blind_bid': None,
        'computer_blind_bid': None,
        'blind_multiplier': 2
    }

# Update init_new_hand() to alternate who leads the first trick
def init_new_hand(game):
    """Start a new hand while preserving scores, bags, and parity assignments"""
    deck = create_deck()
    random.shuffle(deck)
    
    # Alternate who leads the first trick each hand
    current_first_leader = game.get('first_leader', 'player')
    next_first_leader = 'computer' if current_first_leader == 'player' else 'player'
    
    game.update({
        'player_hand': sort_hand(deck[:11]),
        'computer_hand': sort_hand(deck[11:22]),
        'current_trick': [],
        'player_tricks': 0,
        'computer_tricks': 0,
        'spades_broken': False,
        'phase': 'discard',
        'turn': 'player',  # Always player can discard first (simultaneous)
        'trick_leader': None,
        'hand_over': False,
        'message': f'Hand #{game["hand_number"]} - Select a card to discard',
        'player_discarded': None,
        'computer_discarded': None,
        'show_computer_hand': False,
        'trick_display_timer': None,
        'player_bid': None,
        'computer_bid': None,
        'total_tricks': 10,
        'discard_bonus_explanation': None,
        'player_trick_special_cards': 0,
        'computer_trick_special_cards': 0,
        'pending_discard_result': None,
        'pending_special_discard_result': None,
        'blind_bidding_available': False,
        'blind_bid': None,
        'computer_blind_bid': None,
        'first_leader': next_first_leader  # Alternate who leads first trick
    })

def computer_bidding_brain(computer_hand, player_bid, game_state=None):
    """
    Computer bidding function - now delegates to computer_logic module
    """
    if game_state is None:
        # Fallback for backward compatibility
        game_state = {'player_score': 0, 'computer_score': 0, 'computer_bags': 0}
    
    from .computer_logic import computer_bidding_brain as enhanced_brain
    return enhanced_brain(computer_hand, player_bid, game_state)

def computer_discard_strategy(computer_hand, game_state=None):
    """
    Computer discard strategy - now delegates to computer_logic module
    """
    if game_state is None:
        # Fallback to simple strategy for backward compatibility
        computer_discards = []
        for i, card in enumerate(computer_hand):
            if card['suit'] != '‚ô†':
                computer_discards.append((i, card['value']))
        
        if computer_discards:
            return min(computer_discards, key=lambda x: x[1])[0]
        else:
            return 0
    
    from .computer_logic import computer_discard_strategy as enhanced_discard
    return enhanced_discard(computer_hand, game_state)

def is_valid_play(card, hand, trick, spades_broken):
    """Check if a card play is valid according to Spades rules"""
    if len(trick) == 0:
        # Leading
        if card['suit'] == '‚ô†' and not spades_broken:
            # Can only lead spades if no other suits
            for c in hand:
                if c['suit'] != '‚ô†':
                    return False
        return True
    else:
        # Following
        lead_suit = trick[0]['card']['suit']
        # Must follow suit if possible
        has_suit = any(c['suit'] == lead_suit for c in hand)
        if has_suit:
            return card['suit'] == lead_suit
        return True

def determine_trick_winner(trick):
    """
    Determine who won a completed trick
    Returns the player who won ('player' or 'computer')
    """
    if len(trick) != 2:
        return None
    
    first = trick[0]
    second = trick[1]
    
    if first['card']['suit'] == second['card']['suit']:
        # Same suit, higher value wins
        if first['card']['value'] > second['card']['value']:
            return first['player']
        else:
            return second['player']
    elif first['card']['suit'] == '‚ô†':
        # First player trumped
        return first['player']
    elif second['card']['suit'] == '‚ô†':
        # Second player trumped  
        return second['player']
    else:
        # Different suits, no trump - first player (leader) wins
        return first['player']

def resolve_trick_with_delay(game):
    """Resolve trick and set it up to be displayed for 3 seconds"""
    if len(game['current_trick']) != 2:
        return
    
    winner = determine_trick_winner(game['current_trick'])
    
    # Check for special cards in the trick and apply bag reduction IMMEDIATELY
    from utilities.custom_rules import check_special_cards_in_trick, reduce_bags_safely
    special_result = check_special_cards_in_trick(game['current_trick'], winner)
    
    if special_result['bag_reduction'] > 0:
        if winner == 'player':
            current_bags = game.get('player_bags', 0)
            game['player_bags'] = reduce_bags_safely(current_bags, special_result['bag_reduction'])
            game['player_trick_special_cards'] = game.get('player_trick_special_cards', 0) + special_result['bag_reduction']
        else:
            current_bags = game.get('computer_bags', 0)
            game['computer_bags'] = reduce_bags_safely(current_bags, special_result['bag_reduction'])
            game['computer_trick_special_cards'] = game.get('computer_trick_special_cards', 0) + special_result['bag_reduction']
        
        game['special_card_message'] = special_result['explanation']
    
    # Award trick
    if winner == 'player':
        game['player_tricks'] += 1
        base_message = 'You won the trick!'
    else:
        game['computer_tricks'] += 1
        base_message = 'Marta won the trick!'
    
    # Add special card info to message if present
    if special_result['explanation']:
        game['message'] = f"{base_message} {special_result['explanation']} Cards will clear in 3 seconds..."
    else:
        game['message'] = f"{base_message} Cards will clear in 3 seconds..."
    
    # Mark trick as completed but don't clear yet
    game['trick_completed'] = True
    game['trick_winner'] = winner

def computer_follow(game):
    """Computer plays a card when following"""
    hand = game['computer_hand']
    trick = game['current_trick']
    
    if not trick or not hand:
        return
    
    lead_card = trick[0]['card']
    lead_suit = lead_card['suit']
    lead_value = lead_card['value']
    
    # Find valid plays
    same_suit = [(i, c) for i, c in enumerate(hand) if c['suit'] == lead_suit]
    spades = [(i, c) for i, c in enumerate(hand) if c['suit'] == '‚ô†']
    other = [(i, c) for i, c in enumerate(hand) if c['suit'] != lead_suit and c['suit'] != '‚ô†']
    
    if same_suit:
        # Must follow suit - try to win with lowest winning card
        winners = [(i, c) for i, c in same_suit if c['value'] > lead_value]
        if winners:
            chosen = min(winners, key=lambda x: x[1]['value'])
        else:
            # Can't win, play lowest
            chosen = min(same_suit, key=lambda x: x[1]['value'])
    elif lead_suit != '‚ô†' and spades:
        # Can't follow suit, can trump with spade
        chosen = min(spades, key=lambda x: x[1]['value'])
    else:
        # Can't follow or trump, discard lowest
        all_cards = [(i, c) for i, c in enumerate(hand)]
        chosen = min(all_cards, key=lambda x: x[1]['value'])
    
    idx, card = chosen
    game['computer_hand'].pop(idx)
    game['current_trick'].append({'player': 'computer', 'card': card})
    
    if card['suit'] == '‚ô†':
        game['spades_broken'] = True

def computer_lead(game):
    """Computer plays a card when leading"""
    hand = game['computer_hand']
    
    if not hand:
        return
    
    # Find valid leads
    valid = []
    for i, card in enumerate(hand):
        if card['suit'] != '‚ô†' or game['spades_broken'] or all(c['suit'] == '‚ô†' for c in hand):
            valid.append((i, card))
    
    if not valid:
        return
    
    # Lead lowest valid card
    chosen = min(valid, key=lambda x: (x[1]['suit'] == '‚ô†', x[1]['value']))
    idx, card = chosen
    
    game['computer_hand'].pop(idx)
    game['current_trick'] = [{'player': 'computer', 'card': card}]
    game['trick_leader'] = 'computer'
    
    if card['suit'] == '‚ô†':
        game['spades_broken'] = True

def check_game_over(game):
    """
    Check if the game is over (someone reached target score OR down by 300+ points)
    Updates game state with winner information if game is over
    """
    player_score = game['player_score']
    computer_score = game['computer_score']
    target_score = game['target_score']
    
    # Check for 300-point deficit rule (mercy rule)
    if player_score - computer_score >= 300:
        game['game_over'] = True
        game['winner'] = 'player'
        game['message'] = f"GAME OVER! You WIN by mercy rule {player_score} to {computer_score}! (300+ point lead)"
        return True
    elif computer_score - player_score >= 300:
        game['game_over'] = True
        game['winner'] = 'computer'
        game['message'] = f"GAME OVER! Marta WINS by mercy rule {computer_score} to {player_score}! (300+ point lead)"
        return True
    
    # Check for regular target score (300 points)
    if player_score >= target_score or computer_score >= target_score:
        game['game_over'] = True
        if player_score > computer_score:
            game['winner'] = 'player'
            game['message'] = f"GAME OVER! You WIN {player_score} to {computer_score}!"
        elif computer_score > player_score:
            game['winner'] = 'computer'
            game['message'] = f"GAME OVER! Marta WINS {computer_score} to {player_score}!"
        else:
            game['winner'] = 'tie'
            game['message'] = f"GAME OVER! TIE at {player_score} points each!"
        return True
    return False

================================================================================

FILE: ./utilities/custom_rules.py
--------------------------------------------------------------------------------
import random

def get_discard_value(card):
    """
    Get the numerical value of a card for discard scoring.
    J=11, Q=12, K=13, A=1, numbers are face value
    """
    rank = card['rank']
    if rank == 'A':
        return 1
    elif rank == 'J':
        return 11
    elif rank == 'Q':
        return 12
    elif rank == 'K':
        return 13
    else:
        return int(rank)

def assign_even_odd_at_game_start():
    """
    Randomly assign even/odd to players at the start of a new game.
    Also determines who leads the first trick - if player is odd, they lead first.
    Returns tuple: (player_parity, computer_parity, first_leader)
    """
    coin_flip = random.choice(['even', 'odd'])
    if coin_flip == 'even':
        player_parity = 'even'
        computer_parity = 'odd'
        first_leader = 'computer'  # Computer (odd) leads first trick
    else:
        player_parity = 'odd'
        computer_parity = 'even'
        first_leader = 'player'   # Player (odd) leads first trick
    
    return (player_parity, computer_parity, first_leader)

def is_special_card(card):
    """
    Check if a card is one of the special bag-reducing cards.
    Returns tuple: (is_special, bags_to_remove)
    """
    if card['rank'] == '7' and card['suit'] == '‚ô¶':
        return True, 2  # 7 of diamonds removes 2 bags
    elif card['rank'] == '10' and card['suit'] == '‚ô£':
        return True, 1  # 10 of clubs removes 1 bag
    else:
        return False, 0

def check_blind_bidding_eligibility(player_score, computer_score, target_score=300):
    """
    Check if a player is eligible for blind bidding (down by 100+ points).
    
    Returns:
        dict: {
            'player_eligible': bool,
            'computer_eligible': bool,
            'player_deficit': int,
            'computer_deficit': int
        }
    """
    player_deficit = computer_score - player_score
    computer_deficit = player_score - computer_score
    
    return {
        'player_eligible': player_deficit >= 100,
        'computer_eligible': computer_deficit >= 100,
        'player_deficit': max(0, player_deficit),
        'computer_deficit': max(0, computer_deficit)
    }

def apply_blind_scoring(base_points, blind_bid, actual_tricks):
    """
    Apply blind bidding scoring rules.
    
    Args:
        base_points: Normal points that would be awarded
        blind_bid: The blind bid amount (5-10)
        actual_tricks: Actual tricks taken
        
    Returns:
        int: Modified points (doubled if successful, doubled penalty if failed)
    """
    if actual_tricks >= blind_bid:
        # Successful blind bid: double the points
        return base_points * 2
    else:
        # Failed blind bid: double the penalty
        return base_points * 2  # base_points will already be negative for failed bids

def check_special_cards_in_discard(player_discard, computer_discard, discard_winner):
    """
    Check for special cards in the discard pile and apply bag reduction to the winner.
    """
    total_reduction = 0
    special_cards_found = []
    
    # Check both discarded cards for special cards
    for card, discarder in [(player_discard, 'Tom'), (computer_discard, 'Marta')]:
        if card:
            is_special, reduction = is_special_card(card)
            if is_special:
                total_reduction += reduction
                card_name = f"{card['rank']}{card['suit']}"
                special_cards_found.append(f"{card_name} (-{reduction} bags)")
    
    # Apply all reductions to the winner of the discard pile
    player_reduction = 0
    computer_reduction = 0
    
    if total_reduction > 0:
        if discard_winner == 'player':
            player_reduction = total_reduction
        else:
            computer_reduction = total_reduction
    
    # Create explanation
    explanation = ""
    if special_cards_found:
        winner_name = "Tom" if discard_winner == 'player' else "Marta"
        cards_text = ", ".join(special_cards_found)
        explanation = f"{winner_name} won discard pile with special cards: {cards_text}"
    
    return {
        'player_bag_reduction': player_reduction,
        'computer_bag_reduction': computer_reduction,
        'explanation': explanation
    }

def check_special_cards_in_trick(trick, winner):
    """
    Check for special cards in a completed trick and apply bag reduction to winner.
    """
    total_reduction = 0
    special_cards_found = []
    
    for play in trick:
        card = play['card']
        is_special, reduction = is_special_card(card)
        if is_special:
            total_reduction += reduction
            card_name = f"{card['rank']}{card['suit']}"
            special_cards_found.append(f"{card_name} (-{reduction} bags)")
    
    explanation = ""
    if special_cards_found:
        winner_name = "Tom" if winner == 'player' else "Marta"
        cards_text = ", ".join(special_cards_found)
        explanation = f"{winner_name} won trick with special cards: {cards_text}"
    
    return {
        'bag_reduction': total_reduction,
        'explanation': explanation
    }

def calculate_discard_score_with_winner(player_discard, computer_discard, player_parity, computer_parity):
    """Calculate the bonus points from discarded cards and determine winner."""
    if not player_discard or not computer_discard:
        return {
            'player_bonus': 0,
            'computer_bonus': 0, 
            'total': 0,
            'is_double': False,
            'winner': None,
            'explanation': 'No discards to score'
        }
    
    # Calculate total value
    player_value = get_discard_value(player_discard)
    computer_value = get_discard_value(computer_discard)
    total = player_value + computer_value
    
    # Check for doubles (same suit OR same rank)
    is_double = (player_discard['suit'] == computer_discard['suit'] or 
                 player_discard['rank'] == computer_discard['rank'])
    
    # Determine base points (10 for normal, 20 for doubles)
    base_points = 20 if is_double else 10
    
    # Award points based on parity and determine winner
    player_bonus = 0
    computer_bonus = 0
    winner = None
    
    is_total_even = (total % 2 == 0)
    
    if is_total_even and player_parity == 'even':
        player_bonus = base_points
        winner = 'player'
    elif not is_total_even and player_parity == 'odd':
        player_bonus = base_points
        winner = 'player'
    elif is_total_even and computer_parity == 'even':
        computer_bonus = base_points
        winner = 'computer'
    elif not is_total_even and computer_parity == 'odd':
        computer_bonus = base_points
        winner = 'computer'
    
    # Create explanation
    double_text = ""
    if is_double:
        if player_discard['suit'] == computer_discard['suit']:
            double_text = f" (DOUBLE: Both {player_discard['suit']} suit!)"
        else:
            double_text = f" (DOUBLE: Both {player_discard['rank']}s!)"
    
    parity_text = "even" if is_total_even else "odd"
    
    explanation = f"Discards: {player_discard['rank']}{player_discard['suit']} ({player_value}) + {computer_discard['rank']}{computer_discard['suit']} ({computer_value}) = {total} ({parity_text}){double_text}"
    
    if player_bonus > 0:
        explanation += f" ‚Üí Tom gets {player_bonus} pts!"
    elif computer_bonus > 0:
        explanation += f" ‚Üí Marta gets {computer_bonus} pts!"
    else:
        explanation += " ‚Üí No bonus points this hand."
    
    return {
        'player_bonus': player_bonus,
        'computer_bonus': computer_bonus,
        'total': total,
        'is_double': is_double,
        'winner': winner,
        'explanation': explanation
    }

def apply_bags_penalty(score, bags):
    """Apply bags penalty system."""
    penalty_applied = False
    bonus_applied = False
    
    while bags >= 7:
        score -= 100
        bags -= 7
        penalty_applied = True
    
    while bags <= -5:
        score += 100
        bags += 5
        bonus_applied = True
    
    return score, bags, penalty_applied, bonus_applied

def reduce_bags_safely(current_bags, reduction):
    """Reduce bags by the specified amount. Bags can go negative."""
    return current_bags - reduction

def calculate_hand_scores_with_bags(game):
    """
    Calculate hand scoring including bags system, nil bids, and blind bidding for both players.
    """
    player_bid = game.get('player_bid', 0)
    computer_bid = game.get('computer_bid', 0)
    player_actual = game.get('player_tricks', 0)
    computer_actual = game.get('computer_tricks', 0)
    
    # Check blind bids for both players
    is_player_blind = game.get('blind_bid') == player_bid and game.get('blind_bid') is not None
    is_computer_blind = game.get('computer_blind_bid') == computer_bid and game.get('computer_blind_bid') is not None
    
    # Get current bags
    current_player_bags = game.get('player_bags', 0)
    current_computer_bags = game.get('computer_bags', 0)
    
    # Calculate player points
    if player_bid == 0:
        if player_actual == 0:
            player_hand_points = 100
            player_bags_added = 0
        else:
            player_hand_points = -100
            player_bags_added = player_actual
    elif player_actual >= player_bid:
        player_hand_points = (player_bid * 10)
        player_bags_added = player_actual - player_bid
        if is_player_blind:
            player_hand_points = apply_blind_scoring(player_hand_points, player_bid, player_actual)
    else:
        player_hand_points = -(player_bid * 10)
        player_bags_added = 0
        if is_player_blind:
            player_hand_points = apply_blind_scoring(player_hand_points, player_bid, player_actual)
    
    # Calculate computer points (now with blind support!)
    if computer_bid == 0:
        if computer_actual == 0:
            computer_hand_points = 100
            computer_bags_added = 0
        else:
            computer_hand_points = -100
            computer_bags_added = computer_actual
    elif computer_actual >= computer_bid:
        computer_hand_points = (computer_bid * 10)
        computer_bags_added = computer_actual - computer_bid
        if is_computer_blind:
            computer_hand_points = apply_blind_scoring(computer_hand_points, computer_bid, computer_actual)
    else:
        computer_hand_points = -(computer_bid * 10)
        computer_bags_added = 0
        if is_computer_blind:
            computer_hand_points = apply_blind_scoring(computer_hand_points, computer_bid, computer_actual)
    
    # Update bag counts
    new_player_bags = current_player_bags + player_bags_added
    new_computer_bags = current_computer_bags + computer_bags_added
    
    # Apply bag penalties/bonuses
    player_score = game.get('player_score', 0) + player_hand_points
    computer_score = game.get('computer_score', 0) + computer_hand_points
    
    player_score, final_player_bags, player_penalty, player_bonus = apply_bags_penalty(player_score, new_player_bags)
    computer_score, final_computer_bags, computer_penalty, computer_bonus = apply_bags_penalty(computer_score, new_computer_bags)
    
    # Update game state
    game['player_bags'] = final_player_bags
    game['computer_bags'] = final_computer_bags
    game['player_score'] = player_score
    game['computer_score'] = computer_score
    
    # Get special card tracking for summary
    player_trick_special_cards = game.get('player_trick_special_cards', 0)
    computer_trick_special_cards = game.get('computer_trick_special_cards', 0)
    
    # Reset special card tracking for next hand
    game['player_trick_special_cards'] = 0
    game['computer_trick_special_cards'] = 0
    
    # Create explanation with blind bid support
    explanation_parts = []
    
    # Player explanation
    if player_bid == 0:
        if player_actual == 0:
            explanation_parts.append(f"Tom: NIL SUCCESS! 0 bid, 0 tricks (+100 pts)")
        else:
            explanation_parts.append(f"Tom: NIL FAILED! 0 bid, {player_actual} tricks (-100 pts, +{player_bags_added} bags)")
    elif is_player_blind:
        if player_actual >= player_bid:
            explanation_parts.append(f"Tom: BLIND {player_bid} SUCCESS! {player_actual} tricks (DOUBLE POINTS: +{player_hand_points} pts)")
        else:
            explanation_parts.append(f"Tom: BLIND {player_bid} FAILED! {player_actual} tricks (DOUBLE PENALTY: {player_hand_points} pts)")
        if player_bags_added > 0:
            explanation_parts[-1] += f", +{player_bags_added} bags"
    elif player_bags_added > 0:
        explanation_parts.append(f"Tom: {player_bid} bid, {player_actual} tricks (+{player_bags_added} bags)")
    else:
        explanation_parts.append(f"Tom: {player_bid} bid, {player_actual} tricks")
    
    # Computer explanation with blind support
    if computer_bid == 0:
        if computer_actual == 0:
            explanation_parts.append(f"Marta: NIL SUCCESS! 0 bid, 0 tricks (+100 pts)")
        else:
            explanation_parts.append(f"Marta: NIL FAILED! 0 bid, {computer_actual} tricks (-100 pts, +{computer_bags_added} bags)")
    elif is_computer_blind:
        if computer_actual >= computer_bid:
            explanation_parts.append(f"Marta: BLIND {computer_bid} SUCCESS! {computer_actual} tricks (DOUBLE POINTS: +{computer_hand_points} pts)")
        else:
            explanation_parts.append(f"Marta: BLIND {computer_bid} FAILED! {computer_actual} tricks (DOUBLE PENALTY: {computer_hand_points} pts)")
        if computer_bags_added > 0:
            explanation_parts[-1] += f", +{computer_bags_added} bags"
    elif computer_bags_added > 0:
        explanation_parts.append(f"Marta: {computer_bid} bid, {computer_actual} tricks (+{computer_bags_added} bags)")
    else:
        explanation_parts.append(f"Marta: {computer_bid} bid, {computer_actual} tricks")
    
    # Show special card effects from tricks
    if player_trick_special_cards > 0:
        explanation_parts.append(f"Tom won special cards: -{player_trick_special_cards} bags")
    if computer_trick_special_cards > 0:
        explanation_parts.append(f"Marta won special cards: -{computer_trick_special_cards} bags")
    
    # Show penalties and bonuses
    if player_penalty:
        penalty_count = (current_player_bags + player_bags_added) // 7
        explanation_parts.append(f"Tom: BAG PENALTY! -{penalty_count * 100} pts")
    
    if player_bonus:
        bonus_count = abs((current_player_bags + player_bags_added) // -5)
        explanation_parts.append(f"Tom: NEGATIVE BAG BONUS! +{bonus_count * 100} pts")
        
    if computer_penalty:
        penalty_count = (current_computer_bags + computer_bags_added) // 7
        explanation_parts.append(f"Marta: BAG PENALTY! -{penalty_count * 100} pts")
    
    if computer_bonus:
        bonus_count = abs((current_computer_bags + computer_bags_added) // -5)
        explanation_parts.append(f"Marta: NEGATIVE BAG BONUS! +{bonus_count * 100} pts")
    
    # Show current bag counts
    if final_player_bags != 0 or final_computer_bags != 0:
        explanation_parts.append(f"Bags: Tom {final_player_bags}/7, Marta {final_computer_bags}/7")
    
    return {
        'player_hand_points': player_hand_points,
        'computer_hand_points': computer_hand_points,
        'player_bags_added': player_bags_added,
        'computer_bags_added': computer_bags_added,
        'player_penalty': player_penalty,
        'computer_penalty': computer_penalty,
        'player_bonus': player_bonus,
        'computer_bonus': computer_bonus,
        'explanation': " | ".join(explanation_parts)
    }

def get_player_names_with_parity(player_parity, computer_parity):
    """
    Get display names that include the parity assignment.
    """
    player_name = f"Tom ({player_parity.title()})"
    computer_name = f"Marta ({computer_parity.title()})"
    
    return (player_name, computer_name)

================================================================================

FILE: ./utilities/computer_logic.py
--------------------------------------------------------------------------------
"""
Computer AI logic for Two-Man Spades
Handles all computer decision making including bidding, discarding, and play strategy
"""
import random
from .custom_rules import (
    get_discard_value, 
    is_special_card, 
    check_blind_bidding_eligibility,
    apply_blind_scoring
)

def analyze_hand_strength(hand):
    """
    Analyze hand strength and return expected trick count
    Returns tuple: (sure_tricks, probable_tricks, special_card_bonus)
    """
    sure_tricks = 0
    probable_tricks = 0
    special_card_bonus = 0
    
    # Count special cards for strategic value
    for card in hand:
        is_special, bag_reduction = is_special_card(card)
        if is_special:
            special_card_bonus += 0.2  # Special cards provide strategic value
    
    # Separate spades from other suits
    spades = [card for card in hand if card['suit'] == '‚ô†']
    other_suits = [card for card in hand if card['suit'] != '‚ô†']
    
    # Group other suits
    suits = {'‚ô•': [], '‚ô¶': [], '‚ô£': []}
    for card in other_suits:
        suits[card['suit']].append(card)
    
    # Analyze spades
    spade_values = sorted([card['value'] for card in spades], reverse=True)
    
    # High spades analysis
    if 14 in spade_values:  # Ace of spades
        sure_tricks += 0.95
    if 13 in spade_values:  # King of spades
        sure_tricks += 0.8 if 14 in spade_values else 0.65  # Protected vs unprotected
    if 12 in spade_values:  # Queen of spades
        if len([v for v in spade_values if v >= 11]) >= 2:
            probable_tricks += 0.6
        else:
            probable_tricks += 0.3
    
    # Long spade suits
    if len(spades) >= 5:
        probable_tricks += (len(spades) - 4) * 0.4
    elif len(spades) >= 3:
        probable_tricks += (len(spades) - 2) * 0.25
    
    # Analyze other suits
    for suit, cards in suits.items():
        if not cards:
            continue
            
        values = sorted([card['value'] for card in cards], reverse=True)
        
        # Aces in other suits (can be trumped)
        if 14 in values:
            sure_tricks += 0.75
        
        # Protected kings
        if 13 in values:
            if 14 in values:  # Protected king
                probable_tricks += 0.5
            elif len(cards) >= 3:  # King in long suit
                probable_tricks += 0.4
            else:  # Unprotected king
                probable_tricks += 0.25
        
        # Long suits can generate tricks
        if len(cards) >= 4:
            probable_tricks += (len(cards) - 3) * 0.2
    
    return sure_tricks, probable_tricks, special_card_bonus

def should_bid_nil(hand, game_state):
    """
    Determine if computer should bid nil (very conservative)
    """
    player_score = game_state.get('player_score', 0)
    computer_score = game_state.get('computer_score', 0)
    player_bid = game_state.get('player_bid', 0)
    
    # Get hand strength
    sure_tricks, probable_tricks, special_bonus = analyze_hand_strength(hand)
    total_expectation = sure_tricks + probable_tricks + special_bonus
    
    # Only consider nil with very weak hands
    if total_expectation > 1.2:
        return False
    
    # Must have very few spades
    spades = [card for card in hand if card['suit'] == '‚ô†']
    if len(spades) > 2:
        return False
    
    # Must have mostly low cards in other suits
    other_suits = [card for card in hand if card['suit'] != '‚ô†']
    weak_hand = all(card['value'] <= 8 for card in other_suits)
    if not weak_hand:
        return False
    
    # Don't nil if player already bid nil
    if player_bid == 0:
        return False
    
    # Only nil when behind in score (nil is worth 100 points)
    if computer_score >= player_score:
        return False
    
    # Very conservative - only nil when desperate and hand is truly weak
    return computer_score < player_score - 30

def should_bid_blind(hand, game_state):
    """
    Determine if computer should bid blind when eligible
    Returns tuple: (should_blind, blind_bid_amount)
    """
    player_score = game_state.get('player_score', 0)
    computer_score = game_state.get('computer_score', 0)
    
    # Check eligibility
    blind_eligibility = check_blind_bidding_eligibility(player_score, computer_score)
    if not blind_eligibility['computer_eligible']:
        return False, 0
    
    deficit = blind_eligibility['computer_deficit']
    
    # Only consider blind when really desperate (120+ points behind)
    if deficit < 120:
        return False, 0
    
    # Analyze hand strength
    sure_tricks, probable_tricks, special_bonus = analyze_hand_strength(hand)
    total_expectation = sure_tricks + probable_tricks + special_bonus
    
    # Only go blind with reasonable hands (can realistically make 5-8 tricks)
    if total_expectation < 4.0 or total_expectation > 7.5:
        return False, 0
    
    # Calculate blind bid (conservative)
    blind_bid = max(5, min(8, round(total_expectation)))
    
    # More likely to go blind when further behind
    blind_probability = min(0.7, (deficit - 100) / 200)  # 70% max chance
    
    if random.random() < blind_probability:
        return True, blind_bid
    
    return False, 0

def computer_bidding_brain(computer_hand, player_bid, game_state):
    """
    Main computer bidding function with enhanced AI
    Returns tuple: (bid_amount, is_blind)
    """
    player_score = game_state.get('player_score', 0)
    computer_score = game_state.get('computer_score', 0)
    computer_bags = game_state.get('computer_bags', 0)
    
    # Check for nil opportunity first
    if should_bid_nil(computer_hand, game_state):
        return 0, False
    
    # Check for blind bidding opportunity
    should_blind, blind_amount = should_bid_blind(computer_hand, game_state)
    if should_blind:
        return blind_amount, True
    
    # Regular bidding logic
    sure_tricks, probable_tricks, special_bonus = analyze_hand_strength(computer_hand)
    base_expectation = sure_tricks + probable_tricks + special_bonus
    
    # Score-based adjustments
    if computer_score > player_score + 30:  # Ahead - be conservative
        base_expectation *= 0.92
    elif computer_score < player_score - 30:  # Behind - be slightly aggressive
        base_expectation *= 1.08
    
    # Bag avoidance when close to penalty
    if computer_bags >= 5:
        base_expectation *= 0.88
    
    # Strategic response to player's bid
    if player_bid == 0:  # Player nil - be aggressive to set them
        base_expectation += 0.4
    elif player_bid <= 2:  # Player bid low
        base_expectation += 0.2
    elif player_bid >= 7:  # Player bid high
        base_expectation -= 0.3
    
    # Convert to bid
    raw_bid = max(0, min(10, round(base_expectation)))
    
    # Enforce 2-5 preference for reasonable hands (as requested)
    if 1.8 <= base_expectation <= 6.2:
        raw_bid = max(2, min(5, raw_bid))
    
    # Avoid obvious total-10 scenarios
    if abs((raw_bid + player_bid) - 10) <= 1 and random.random() < 0.4:
        if raw_bid > 2:
            raw_bid -= 1
        elif raw_bid < 8:
            raw_bid += 1
    
    return raw_bid, False

def computer_discard_strategy(computer_hand, game_state):
    """
    Enhanced discard strategy considering special cards and parity
    Returns index of card to discard
    """
    player_parity = game_state.get('player_parity', 'even')
    computer_parity = game_state.get('computer_parity', 'odd')
    
    discard_candidates = []
    
    for i, card in enumerate(computer_hand):
        score = 0
        
        # Heavily avoid discarding special cards
        is_special, _ = is_special_card(card)
        if is_special:
            score -= 100  # Almost never discard special cards
        
        # Prefer discarding weak cards, avoid spades
        if card['suit'] == '‚ô†':
            score -= card['value'] * 3  # Really avoid discarding spades
        else:
            score += (15 - card['value'])  # Prefer discarding low cards
        
        # Light parity consideration for discard scoring
        discard_value = get_discard_value(card)
        if computer_parity == 'even' and discard_value % 2 == 1:
            score += 3  # Odd values might help create even totals
        elif computer_parity == 'odd' and discard_value % 2 == 0:
            score += 3  # Even values might help create odd totals
        
        discard_candidates.append((i, score))
    
    # Return index of card with highest discard score
    return max(discard_candidates, key=lambda x: x[1])[0]

def computer_play_strategy(game_state):
    """
    Enhanced playing strategy for computer
    This can be expanded later for more sophisticated play decisions
    """
    # For now, this just returns to the existing play logic
    # But provides a centralized place to enhance computer play strategy later
    pass

================================================================================

FILE: ./static/game.js
--------------------------------------------------------------------------------
let gameState = null;
let selectedCard = null;
let trickDisplayTimeout = null;
let lastHandNumber = null;

async function loadGameState() {
    try {
        const response = await fetch('/state');
        gameState = await response.json();
        updateUI();
    } catch (error) {
        console.error('Error loading game state:', error);
        showMessage('Error loading game', 'error');
    }
}

function updateUI() {
    if (!gameState) return;

    // Update floating game scores
    updateFloatingScores();

    // Update hand count display
    const playerHandCountEl = document.getElementById('playerHandCount');
    if (playerHandCountEl) {
        playerHandCountEl.textContent = `(${gameState.player_hand.length} cards)`;
    }

    // Show/hide bidding section and blind bidding
    const biddingSection = document.getElementById('biddingSection');
    const discardBlindSection = document.getElementById('discardBlindBiddingSection');

    if (gameState.phase === 'bidding') {
        biddingSection.style.display = 'block';
        discardBlindSection.style.display = 'none';
    } else if (gameState.phase === 'discard') {
        // Check if player is eligible for blind bidding and hasn't already bid
        if (!gameState.player_bid && !gameState.blind_bid) {
            // Check if player is down by 100+ points for blind eligibility
            const deficit = gameState.computer_score - gameState.player_score;
            if (deficit >= 100) {
                discardBlindSection.style.display = 'block';
            } else {
                discardBlindSection.style.display = 'none';
            }
        } else {
            discardBlindSection.style.display = 'none';
        }
        biddingSection.style.display = 'none';
    } else {
        biddingSection.style.display = 'none';
        discardBlindSection.style.display = 'none';
    }

    // Handle results display for completed hands
    handleResultsDisplay();

    // Update message
    showMessage(gameState.message, gameState.message.includes('WIN') ? 'success' : '');

    // Update play area
    updatePlayArea();

    // Update hands
    updatePlayerHand();
    updateComputerHand();

    // Update buttons based on game state
    updateActionButtons();

    // Update computer hand toggle button - respect debug mode
    const toggleButton = document.getElementById('toggleComputerHand');
    if (toggleButton) {
        if (gameState.debug_mode) {
            // In debug mode, show the button and update text
            toggleButton.style.display = 'inline-block';
            toggleButton.textContent = gameState.show_computer_hand ? 'Hide Cards' : 'Show Cards';
            toggleButton.style.background = '#6c757d';
        } else {
            // Not in debug mode, hide the button completely
            toggleButton.style.display = 'none';
        }
    }

    // Show discards if hand is over
    updateDiscards();

    // Check for completed trick that needs to be displayed
    if (gameState.current_trick && gameState.current_trick.length === 2 && !trickDisplayTimeout) {
        trickDisplayTimeout = setTimeout(async () => {
            try {
                await fetch('/clear_trick', { method: 'POST' });
                await loadGameState();
                trickDisplayTimeout = null;
            } catch (error) {
                console.error('Error clearing trick:', error);
                trickDisplayTimeout = null;
            }
        }, 3000);
    }

    // Check game over
    if (gameState.game_over) {
        document.getElementById('gameOver').style.display = 'block';
        document.getElementById('winnerText').textContent = gameState.message;
    } else {
        document.getElementById('gameOver').style.display = 'none';
    }

    // Track hand changes for results display
    lastHandNumber = gameState.hand_number;
}


function updateFloatingScores() {
    // Update floating game score with parity indicators
    const gameScoreEl = document.getElementById('floatingGameScore');
    if (gameScoreEl) {
        document.getElementById('floatingPlayerScore').textContent = gameState.player_score;
        document.getElementById('floatingComputerScore').textContent = gameState.computer_score;
        document.getElementById('floatingHandNumber').textContent = gameState.hand_number;

        // Update parity displays
        const playerParityText = `(${gameState.player_parity.toUpperCase()})`;
        const computerParityText = `(${gameState.computer_parity.toUpperCase()})`;

        document.getElementById('floatingPlayerParity').textContent = playerParityText;
        document.getElementById('floatingComputerParity').textContent = computerParityText;
    }

    // Update floating hand score
    const handScoreEl = document.getElementById('floatingHandScore');
    if (handScoreEl) {
        // Player side
        document.getElementById('floatingPlayerTricks').textContent = gameState.player_tricks;
        const playerBid = gameState.player_bid !== null ? gameState.player_bid : '-';
        const playerBlindText = gameState.blind_bid === gameState.player_bid ? 'B' : '';
        document.getElementById('floatingPlayerBid').textContent = `${playerBid}${playerBlindText}`;

        // Color code player bid if blind
        const playerBidEl = document.getElementById('floatingPlayerBid');
        if (playerBlindText) {
            playerBidEl.style.color = '#dc3545';
            playerBidEl.style.fontWeight = 'bold';
        } else {
            playerBidEl.style.color = '#333';
            playerBidEl.style.fontWeight = '600';
        }

        document.getElementById('floatingPlayerBags').textContent = gameState.player_bags || 0;

        // Computer side
        document.getElementById('floatingComputerTricks').textContent = gameState.computer_tricks;
        const computerBid = gameState.computer_bid !== null ? gameState.computer_bid : '-';
        const computerBlindText = gameState.computer_blind_bid === gameState.computer_bid ? 'B' : '';
        document.getElementById('floatingComputerBid').textContent = `${computerBid}${computerBlindText}`;

        // Color code computer bid if blind
        const computerBidEl = document.getElementById('floatingComputerBid');
        if (computerBlindText) {
            computerBidEl.style.color = '#dc3545';
            computerBidEl.style.fontWeight = 'bold';
        } else {
            computerBidEl.style.color = '#333';
            computerBidEl.style.fontWeight = '600';
        }

        document.getElementById('floatingComputerBags').textContent = gameState.computer_bags || 0;

        // Spades status
        document.getElementById('floatingSpadesStatus').textContent = gameState.spades_broken ? 'Broken' : 'Not Broken';
    }
}
function updateBagsDisplay(elementId, bags) {
    const bagsEl = document.getElementById(elementId);
    if (!bagsEl) return;

    bagsEl.textContent = `Bags: ${bags}/7`;

    // Color coding for mobile-friendly visibility
    if (bags >= 6) {
        bagsEl.style.color = '#d32f2f';
        bagsEl.style.fontWeight = 'bold';
        bagsEl.style.backgroundColor = '#ffebee';
        bagsEl.style.padding = '2px 6px';
        bagsEl.style.borderRadius = '4px';
    } else if (bags >= 4) {
        bagsEl.style.color = '#f57c00';
        bagsEl.style.fontWeight = 'bold';
        bagsEl.style.backgroundColor = '#fff3e0';
        bagsEl.style.padding = '2px 6px';
        bagsEl.style.borderRadius = '4px';
    } else if (bags <= -4) {
        bagsEl.style.color = '#1976d2';
        bagsEl.style.fontWeight = 'bold';
        bagsEl.style.backgroundColor = '#e3f2fd';
        bagsEl.style.padding = '2px 6px';
        bagsEl.style.borderRadius = '4px';
    } else {
        bagsEl.style.color = '#666';
        bagsEl.style.fontWeight = 'normal';
        bagsEl.style.backgroundColor = 'transparent';
        bagsEl.style.padding = '0';
    }
}

function handleResultsDisplay() {
    const resultsSection = document.getElementById('resultsSection');
    const resultsContent = document.getElementById('resultsContent');

    if (gameState.hand_over && gameState.discard_bonus_explanation) {
        // Show results section with formatted content
        resultsSection.classList.add('show');

        // Parse and format the explanation for better mobile readability
        const explanation = gameState.discard_bonus_explanation;
        const formattedExplanation = formatResultsForMobile(explanation);
        resultsContent.innerHTML = formattedExplanation;
    } else {
        resultsSection.classList.remove('show');
    }
}

function formatResultsForMobile(explanation) {
    if (!explanation || explanation === 'No discards to score') {
        return '<div class="result-line" style="color: #666; font-style: italic;">No special scoring this hand</div>';
    }

    // Split explanation by pipe separators and format each section cleanly
    const sections = explanation.split(' | ');
    let formatted = '';

    sections.forEach((section) => {
        section = section.trim();

        if (section.includes('complete!')) {
            // Skip the "Hand complete" line - already shown in header
            return;
        } else if (section.includes('vs') && (section.includes('Even') || section.includes('Odd'))) {
            // Parity assignment - make it cleaner
            const clean = section.replace(/Tom \(Even\) vs Marta \(Odd\)|Tom \(Odd\) vs Marta \(Even\)/,
                section.includes('Tom (Even)') ? 'Tom: Even, Marta: Odd' : 'Tom: Odd, Marta: Even');
            formatted += `<div class="result-line" style="font-weight: 500; color: #6c757d;">${clean}</div>`;
        } else if (section.includes('DISCARD PILE REVEALS:')) {
            // Clean up discard reveals
            const clean = section.replace('DISCARD PILE REVEALS: Discards:', 'Discard pile:');
            formatted += `<div class="result-line highlight">${clean}</div>`;
        } else if (section.includes('Tom:') && section.includes('bid')) {
            // Player scoring line
            formatted += `<div class="result-line">${section}</div>`;
        } else if (section.includes('Marta:') && section.includes('bid')) {
            // Computer scoring line  
            formatted += `<div class="result-line">${section}</div>`;
        } else if (section.includes('BAG PENALTY')) {
            // Penalty formatting
            const clean = section.replace('BAG PENALTY!', 'Bag penalty');
            formatted += `<div class="result-line penalty">${clean}</div>`;
        } else if (section.includes('NEGATIVE BAG BONUS')) {
            // Bonus formatting
            const clean = section.replace('NEGATIVE BAG BONUS!', 'Bag bonus');
            formatted += `<div class="result-line bonus">${clean}</div>`;
        } else if (section.includes('won') && section.includes('special cards')) {
            // Special card wins
            formatted += `<div class="result-line" style="color: #17a2b8;">${section}</div>`;
        } else if (section.includes('Bags:')) {
            // Bag status
            formatted += `<div class="result-line" style="color: #6c757d; font-size: 11px; text-align: center; border-top: 1px solid #e9ecef; padding-top: 6px; margin-top: 4px;">${section}</div>`;
        } else if (section.includes('Game totals:')) {
            // Game totals - make prominent but clean
            formatted += `<div class="result-line" style="font-weight: 600; text-align: center; margin-top: 6px; padding-top: 6px; border-top: 1px solid #e9ecef;">${section}</div>`;
        } else if (section.includes('Click') || section.includes('continue')) {
            // Skip instructions - handled by button
            return;
        } else if (section.length > 0) {
            // Any other content
            formatted += `<div class="result-line">${section}</div>`;
        }
    });

    return formatted;
}

function updateActionButtons() {
    const actionButton = document.getElementById('actionButton');
    const nextHandButton = document.getElementById('nextHandButton');

    if (gameState.hand_over && !gameState.game_over) {
        actionButton.style.display = 'none';
        nextHandButton.style.display = 'inline-block';
    } else if (gameState.phase === 'discard') {
        actionButton.textContent = 'Discard Selected';
        actionButton.onclick = discardCard;
        actionButton.style.display = 'inline-block';
        nextHandButton.style.display = 'none';
    } else if (gameState.phase === 'playing') {
        actionButton.textContent = 'Play Selected';
        actionButton.onclick = playCard;
        actionButton.style.display = 'inline-block';
        nextHandButton.style.display = 'none';
    } else {
        actionButton.style.display = 'none';
        nextHandButton.style.display = 'none';
    }

    // Disable action button if no card selected (mobile-friendly feedback)
    if (selectedCard === null && actionButton.style.display !== 'none') {
        actionButton.disabled = true;
        actionButton.textContent = gameState.phase === 'discard' ? 'Select Card to Discard' : 'Select Card to Play';
    } else if (actionButton.style.display !== 'none') {
        actionButton.disabled = false;
        actionButton.textContent = gameState.phase === 'discard' ? 'Discard Selected' : 'Play Selected';
    }
}

function updatePlayArea() {
    const trickDisplay = document.getElementById('trickDisplay');

    if (gameState.current_trick.length === 0) {
        trickDisplay.innerHTML = '<div style="color: #999; font-size: 14px;">Waiting for play...</div>';
    } else {
        let html = '<div class="trick-container">';

        const playerCard = gameState.current_trick.find(play => play.player === 'player');
        const computerCard = gameState.current_trick.find(play => play.player === 'computer');

        // Always show side by side - Tom left, Marta right
        if (playerCard) {
            const card = playerCard.card;
            const suitClass = getSuitClass(card.suit);
            html += `
                <div class="trick-card ${suitClass}">
                    <div class="player-name">Tom</div>
                    <div class="card-content">${card.rank}${card.suit}</div>
                </div>
            `;
        } else {
            html += '<div class="trick-card-placeholder"><div style="font-size: 10px; color: #999;">Tom</div></div>';
        }

        if (computerCard) {
            const card = computerCard.card;
            const suitClass = getSuitClass(card.suit);
            html += `
                <div class="trick-card ${suitClass}">
                    <div class="player-name">Marta</div>
                    <div class="card-content">${card.rank}${card.suit}</div>
                </div>
            `;
        } else {
            html += '<div class="trick-card-placeholder"><div style="font-size: 10px; color: #999;">Marta</div></div>';
        }

        html += '</div>';
        trickDisplay.innerHTML = html;
    }
}

function updatePlayerHand() {
    const handEl = document.getElementById('playerHand');
    handEl.innerHTML = '';

    gameState.player_hand.forEach((card, index) => {
        const cardEl = document.createElement('div');
        cardEl.className = `card ${getSuitClass(card.suit)}`;
        cardEl.textContent = `${card.rank}${card.suit}`;

        // Add touch-friendly interaction
        cardEl.onclick = () => selectCard(index);
        cardEl.ontouchstart = (e) => {
            e.preventDefault();
            selectCard(index);
        };

        if (selectedCard === index) {
            cardEl.classList.add('selected');
        }

        if (!canPlayCard(card, index)) {
            cardEl.classList.add('disabled');
        }

        handEl.appendChild(cardEl);
    });
}

function updateComputerHand() {
    const handEl = document.getElementById('computerHand');
    handEl.innerHTML = '';

    // Only show cards if debug mode is on AND show_computer_hand is true
    if (gameState.debug_mode && gameState.show_computer_hand && gameState.computer_hand) {
        // Show actual cards
        gameState.computer_hand.forEach((card, index) => {
            const cardEl = document.createElement('div');
            cardEl.className = `card ${getSuitClass(card.suit)}`;
            cardEl.textContent = `${card.rank}${card.suit}`;
            cardEl.style.cursor = 'default';
            handEl.appendChild(cardEl);
        });
    } else {
        // Show hidden cards with count
        const cardCount = gameState.computer_hand_count;
        for (let i = 0; i < cardCount; i++) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card';
            cardEl.style.background = '#666';
            cardEl.style.color = '#999';
            cardEl.textContent = '?';
            cardEl.style.cursor = 'default';
            handEl.appendChild(cardEl);
        }
    }
}

function updateDiscards() {
    const discardsSection = document.getElementById('discardsSection');

    if (gameState.hand_over && (gameState.player_discarded || gameState.computer_discarded)) {
        discardsSection.style.display = 'block';

        // Show player discard
        const playerDiscardEl = document.getElementById('playerDiscard');
        if (gameState.player_discarded) {
            const card = gameState.player_discarded;
            playerDiscardEl.innerHTML = `<div class="card ${getSuitClass(card.suit)}">${card.rank}${card.suit}</div>`;
        } else {
            playerDiscardEl.innerHTML = '<div class="card" style="opacity: 0.5;">None</div>';
        }

        // Show computer discard
        const computerDiscardEl = document.getElementById('computerDiscard');
        if (gameState.computer_discarded) {
            const card = gameState.computer_discarded;
            computerDiscardEl.innerHTML = `<div class="card ${getSuitClass(card.suit)}">${card.rank}${card.suit}</div>`;
        } else {
            computerDiscardEl.innerHTML = '<div class="card" style="opacity: 0.5;">None</div>';
        }
    } else {
        discardsSection.style.display = 'none';
    }
}

async function nextHand() {
    try {
        const response = await fetch('/next_hand', { method: 'POST' });
        if (response.ok) {
            if (trickDisplayTimeout) {
                clearTimeout(trickDisplayTimeout);
                trickDisplayTimeout = null;
            }
            selectedCard = null;
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error starting next hand:', error);
        showMessage('Error starting next hand', 'error');
    }
}

function getSuitClass(suit) {
    switch (suit) {
        case '‚ô†': return 'spade';
        case '‚ô•': return 'heart';
        case '‚ô¶': return 'diamond';
        case '‚ô£': return 'club';
        default: return '';
    }
}

function canPlayCard(card, index) {
    if (gameState.phase === 'discard') return true;
    if (gameState.turn !== 'player') return false;

    if (gameState.current_trick.length === 1) {
        const leadSuit = gameState.current_trick[0].card.suit;
        const hasSuit = gameState.player_hand.some(c => c.suit === leadSuit);
        if (hasSuit) {
            return card.suit === leadSuit;
        }
        return true;
    }

    if (gameState.current_trick.length === 0) {
        if (card.suit === '‚ô†' && !gameState.spades_broken) {
            return gameState.player_hand.every(c => c.suit === '‚ô†');
        }
        return true;
    }

    return false;
}

function selectCard(index) {
    if (!canPlayCard(gameState.player_hand[index], index)) {
        showMessage('Cannot play this card!', 'error');
        // Add haptic feedback on mobile if available
        if (navigator.vibrate) {
            navigator.vibrate(100);
        }
        return;
    }

    selectedCard = index;
    updatePlayerHand();
    updateActionButtons(); // Update button state when card is selected

    // Add subtle haptic feedback on mobile if available
    if (navigator.vibrate) {
        navigator.vibrate(50);
    }
}

async function discardCard() {
    if (selectedCard === null) {
        showMessage('Please select a card to discard', 'error');
        if (navigator.vibrate) navigator.vibrate(100);
        return;
    }

    try {
        const response = await fetch('/discard', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ index: selectedCard })
        });

        if (response.ok) {
            selectedCard = null;
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error discarding card:', error);
        showMessage('Error discarding card', 'error');
    }
}

async function playCard() {
    if (selectedCard === null) {
        showMessage('Please select a card to play', 'error');
        if (navigator.vibrate) navigator.vibrate(100);
        return;
    }

    try {
        const response = await fetch('/play', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ index: selectedCard })
        });

        if (response.ok) {
            selectedCard = null;
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error playing card:', error);
        showMessage('Error playing card', 'error');
    }
}

async function performAction() {
    if (gameState && gameState.phase === 'discard') {
        await discardCard();
    } else {
        await playCard();
    }
}

async function makeBid(bidAmount) {
    try {
        const response = await fetch('/bid', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ bid: bidAmount })
        });

        if (response.ok) {
            await loadGameState();
            // Haptic feedback for successful bid
            if (navigator.vibrate) navigator.vibrate(50);
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error making bid:', error);
        showMessage('Error making bid', 'error');
    }
}

async function makeBlindBid(bidAmount) {
    try {
        const response = await fetch('/blind_bid', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ bid: bidAmount })
        });

        if (response.ok) {
            await loadGameState();
            // Stronger haptic feedback for blind bid
            if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error making blind bid:', error);
        showMessage('Error making blind bid', 'error');
    }
}

async function toggleComputerHand() {
    try {
        const response = await fetch('/toggle_computer_hand', { method: 'POST' });
        if (response.ok) {
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error toggling computer hand:', error);
        showMessage('Error toggling computer hand', 'error');
    }
}

async function startNewGame() {
    try {
        if (trickDisplayTimeout) {
            clearTimeout(trickDisplayTimeout);
            trickDisplayTimeout = null;
        }

        await fetch('/new_game', { method: 'POST' });
        selectedCard = null;
        await loadGameState();
    } catch (error) {
        console.error('Error starting new game:', error);
        showMessage('Error starting new game', 'error');
    }
}

function showMessage(text, type = '') {
    const messageEl = document.getElementById('message');
    if (messageEl) {
        messageEl.textContent = text;
        messageEl.className = 'message ' + type;

        // Auto-scroll to message on mobile for better visibility
        if (window.innerWidth < 768) {
            messageEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }
}

// Initialize game on load
document.addEventListener('DOMContentLoaded', function () {
    loadGameState();

    // Prevent zoom on double-tap for mobile
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function (event) {
        const now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300) {
            event.preventDefault();
        }
        lastTouchEnd = now;
    }, false);
});

// Auto-refresh with mobile-friendly timing
setInterval(() => {
    if (gameState && !gameState.game_over && !trickDisplayTimeout) {
        loadGameState();
    }
}, 2500); // Slightly longer interval for mobile battery life

// Handle orientation changes on mobile
window.addEventListener('orientationchange', function () {
    setTimeout(() => {
        updatePlayArea();
    }, 100);
});

================================================================================

FILE: ./static/style.css
--------------------------------------------------------------------------------
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 0;
    margin: 0;
    padding-top: 150px;
    /* More space for floating headers */
    padding-bottom: 80px;
    /* Space for bottom new game button */
}

.container {
    max-width: 600px;
    /* Better desktop centering */
    margin: 0 auto;
    background: white;
    border-radius: 15px;
    padding: 15px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    margin-left: auto;
    margin-right: auto;
}

/* Floating score headers - positioned lower */
.floating-game-score {
    position: fixed;
    top: 20px;
    /* Moved down from 10px */
    left: 10px;
    right: 10px;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 10px;
    padding: 8px 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    z-index: 999;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 14px;
}

.floating-hand-score {
    position: fixed;
    top: 85px;
    /* Moved down from 55px */
    left: 10px;
    right: 10px;
    background: rgba(248, 249, 250, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 8px;
    padding: 6px 12px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    z-index: 998;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: #495057;
}

/* Add this to your CSS for the new parity display */
.game-score-parity {
    font-size: 8px;
    color: #666;
    margin-bottom: 2px;
    font-weight: normal;
    line-height: 1;
}

.game-score-item {
    text-align: center;
    flex: 1;
}

.game-score-label {
    font-size: 10px;
    color: #666;
    margin-bottom: 2px;
}

.game-score-value {
    font-size: 18px;
    font-weight: bold;
    color: #333;
}

.hand-score-item {
    text-align: center;
    flex: 1;
    font-size: 11px;
}

.hand-score-item .label {
    color: #6c757d;
    margin-bottom: 1px;
}

.hand-score-item .value {
    font-weight: 600;
    color: #333;
}

/* Hide the old score boards */
.game-score-board,
.score-board {
    display: none;
}

/* Simplified score display - just essential info */
.score-board {
    display: flex;
    justify-content: space-between;
    margin-bottom: 15px;
    padding: 12px 15px;
    background: #f8f9fa;
    border-radius: 8px;
    font-size: 14px;
}

.score-item {
    text-align: center;
    flex: 1;
}

.score-item:nth-child(2) {
    border-left: 1px solid #ddd;
    border-right: 1px solid #ddd;
    margin: 0 10px;
    padding: 0 10px;
}

.score-label {
    font-size: 11px;
    color: #888;
    margin-bottom: 2px;
}

.score-value {
    font-size: 20px;
    font-weight: bold;
    color: #333;
}

.bid-display,
.bags-display {
    font-size: 10px;
    color: #999;
    margin-top: 1px;
}

/* Clean results section with better line spacing */
.results-section {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 15px;
    display: none;
    font-size: 13px;
    color: #495057;
    border: 1px solid #e9ecef;
}

.results-section.show {
    display: block;
}

.results-header {
    font-weight: 600;
    color: #495057;
    margin-bottom: 8px;
    font-size: 14px;
    text-align: center;
}

.result-line {
    padding: 4px 0;
    border-bottom: 1px solid #f1f3f4;
    font-size: 12px;
    line-height: 1.3;
}

.result-line:last-child {
    border-bottom: none;
}

.result-line.highlight {
    background: #e8f5e9;
    padding: 6px 8px;
    border-radius: 4px;
    margin: 2px 0;
    border-bottom: none;
}

.result-line.penalty {
    background: #ffebee;
    color: #c62828;
    padding: 6px 8px;
    border-radius: 4px;
    margin: 2px 0;
    border-bottom: none;
}

.result-line.bonus {
    background: #e8f5e9;
    color: #2e7d32;
    padding: 6px 8px;
    border-radius: 4px;
    margin: 2px 0;
    border-bottom: none;
}

/* Minimal play area */
.play-area {
    padding: 20px 10px;
    margin-bottom: 15px;
    min-height: 150px;
    display: flex;
    justify-content: center;
    align-items: center;
}

.trick-container {
    display: flex;
    justify-content: space-around;
    align-items: center;
    width: 100%;
    gap: 20px;
    flex-wrap: wrap;
}

.trick-card {
    background: white;
    border: 2px solid #333;
    border-radius: 8px;
    padding: 15px 10px;
    width: 100px;
    height: 130px;
    text-align: center;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    flex-shrink: 0;
}

.trick-card .player-name {
    font-size: 11px;
    font-weight: 600;
    color: #666;
    margin-bottom: 5px;
}

.trick-card .card-content {
    font-size: 28px;
    font-weight: bold;
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
}

.trick-card-placeholder {
    width: 100px;
    height: 130px;
    border: 2px dashed #ccc;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: #999;
    font-size: 12px;
    flex-shrink: 0;
}

/* Trick card suit colors */
.trick-card.spade {
    color: #000;
}

.trick-card.heart {
    color: #ff0000;
}

.trick-card.diamond {
    color: #ff6200;
}

.trick-card.club {
    color: #333;
}

/* Clean, minimal message display */
.message {
    text-align: center;
    padding: 8px 12px;
    margin-bottom: 15px;
    border-radius: 6px;
    font-weight: 400;
    background: #f8f9fa;
    color: #495057;
    font-size: 13px;
    line-height: 1.3;
    border-left: 3px solid #6c757d;
}

.message.success {
    background: #f8f9fa;
    color: #28a745;
    border-left-color: #28a745;
}

.message.error {
    background: #f8f9fa;
    color: #dc3545;
    border-left-color: #dc3545;
}

/* Mobile-optimized hands */
.hand-section {
    background: #f8f9fa;
    border-radius: 12px;
    padding: 15px;
    margin-bottom: 15px;
}

.hand-title {
    font-size: 16px;
    font-weight: bold;
    margin-bottom: 12px;
    color: #333;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.cards {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
    gap: 8px;
    justify-content: center;
    margin-bottom: 15px;
}

.card {
    background: white;
    border: 2px solid #ddd;
    border-radius: 8px;
    padding: 12px 8px;
    min-width: 60px;
    min-height: 80px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 18px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}

.card:hover:not(.disabled) {
    transform: translateY(-3px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.card.selected {
    border-color: #4CAF50;
    background: #e8f5e9;
    transform: translateY(-3px);
    box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
}

.card.disabled {
    opacity: 0.4;
    cursor: not-allowed;
}

/* Card suit colors */
.card.spade {
    color: #000;
}

.card.heart {
    color: #ff0000;
}

.card.diamond {
    color: #ff6200;
}

.card.club {
    color: #333;
}

/* Better button layout for mobile */
.controls {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
}

/* Bottom New Game section */
.bottom-section {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    padding: 12px;
    box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.15);
    z-index: 999;
    text-align: center;
}

.bottom-new-game-btn {
    background: #dc3545;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.bottom-new-game-btn:hover {
    background: #c82333;
    transform: translateY(-1px);
}

button {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    padding: 12px 20px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    min-width: 80px;
}

button:hover:not(:disabled) {
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
}

button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Cleaner bidding interface */
.bidding-section {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 15px;
    text-align: center;
}

.bid-buttons {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 6px;
    margin-top: 10px;
    max-width: 350px;
    margin-left: auto;
    margin-right: auto;
}

.bid-buttons button {
    padding: 10px 4px;
    font-size: 14px;
    background: #6c757d;
    color: white;
    font-weight: 500;
    min-width: 40px;
    border-radius: 4px;
}

.bid-buttons button:hover {
    background: #5a6268;
}

/* Much simpler blind bidding - tone down the drama */
.blind-bidding-section {
    background: #fff2f2;
    border: 1px solid #e57373;
    border-radius: 6px;
    padding: 10px;
    margin-bottom: 10px;
}

.blind-header h3 {
    color: #d32f2f;
    margin-bottom: 6px;
    font-size: 14px;
    font-weight: 500;
}

.blind-header p {
    font-size: 12px;
    margin-bottom: 6px;
    color: #333;
}

.blind-warning {
    background: #ffcdd2;
    color: #d32f2f;
    padding: 6px;
    border-radius: 4px;
    font-size: 11px;
    font-weight: 500;
    margin-bottom: 8px;
}

.blind-buttons {
    grid-template-columns: repeat(3, 1fr);
    gap: 4px;
}

.blind-bid-btn {
    background: #d32f2f;
    color: white;
    font-weight: 500;
    padding: 8px 6px;
    font-size: 12px;
}

.blind-bid-btn:hover {
    background: #c62828;
}

.regular-bid-prompt {
    margin-top: 15px;
    padding-top: 15px;
    border-top: 1px solid #ccc;
}

.regular-bid-prompt p {
    font-size: 13px;
    color: #666;
    margin-bottom: 10px;
}

/* Improved discards display */
.discards-section {
    background: #e8f5e9;
    border: 2px solid #4caf50;
    border-radius: 12px;
    padding: 15px;
    margin-bottom: 15px;
}

.discards-content {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin-top: 10px;
}

.discard-item {
    text-align: center;
    background: white;
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.discard-label {
    font-size: 12px;
    font-weight: bold;
    color: #666;
    margin-bottom: 8px;
}

/* Game over styling */
.game-over {
    text-align: center;
    padding: 25px 15px;
    background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
    border-radius: 15px;
    margin-top: 15px;
}

.winner-text {
    font-size: 24px;
    font-weight: bold;
    color: #333;
    margin-bottom: 15px;
    line-height: 1.2;
}

/* Better bid and bag displays */
.bid-display {
    font-size: 11px;
    color: #666;
    margin-top: 3px;
}

.bags-display {
    font-size: 10px;
    color: #666;
    margin-top: 2px;
}

/* Mobile toggle button */
#toggleComputerHand {
    font-size: 12px;
    padding: 6px 12px;
    background: #6c757d;
    border-radius: 6px;
}

#toggleComputerHand:hover {
    background: #5a6268;
}

/* Responsive adjustments for larger screens */
@media (min-width: 768px) {
    body {
        padding-top: 160px;
    }

    .container {
        max-width: 700px;
        padding: 25px;
        margin: 0 auto;
    }

    .floating-game-score,
    .floating-hand-score {
        max-width: 700px;
        left: 50%;
        right: auto;
        transform: translateX(-50%);
    }

    .bottom-section {
        max-width: 700px;
        left: 50%;
        right: auto;
        transform: translateX(-50%);
        border-radius: 10px 10px 0 0;
    }

    .cards {
        grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
        gap: 12px;
        max-width: 600px;
        margin: 0 auto 15px auto;
    }

    .card {
        min-width: 70px;
        min-height: 90px;
        font-size: 20px;
        padding: 15px 10px;
    }

    .trick-card {
        width: 120px;
        height: 150px;
        padding: 20px 15px;
    }

    .trick-card .card-content {
        font-size: 32px;
    }

    .bid-buttons {
        grid-template-columns: repeat(11, 1fr);
        max-width: 600px;
        margin: 15px auto 0;
    }

    .blind-buttons {
        grid-template-columns: repeat(6, 1fr);
        max-width: 400px;
        margin: 0 auto;
    }
}

/* Extra small screens (phones in portrait) */
@media (max-width: 480px) {
    body {
        padding: 0;
        padding-top: 130px;
        padding-bottom: 70px;
    }

    .container {
        margin: 0 5px;
        padding: 12px;
        border-radius: 10px;
    }

    .floating-game-score,
    .floating-hand-score {
        left: 5px;
        right: 5px;
    }

    .cards {
        grid-template-columns: repeat(auto-fit, minmax(50px, 1fr));
        gap: 6px;
    }

    .card {
        min-width: 50px;
        min-height: 70px;
        font-size: 16px;
        padding: 8px 4px;
    }

    .trick-card {
        width: 90px;
        height: 120px;
        padding: 12px 8px;
    }

    .trick-card .card-content {
        font-size: 24px;
    }

    .bid-buttons {
        grid-template-columns: repeat(4, 1fr);
        gap: 6px;
    }

    .bid-buttons button {
        padding: 12px 5px;
        font-size: 14px;
        min-width: 40px;
    }

    .blind-buttons {
        grid-template-columns: repeat(2, 1fr);
    }

    .message {
        font-size: 13px;
        padding: 10px;
    }
}

/* Very small screens */
@media (max-width: 320px) {
    .cards {
        grid-template-columns: repeat(4, 1fr);
    }

    .card {
        min-width: 45px;
        min-height: 65px;
        font-size: 14px;
    }

    .bid-buttons {
        grid-template-columns: repeat(3, 1fr);
    }
}

.bottom-rules-btn {
    background: #28a745;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    margin-left: 10px;
}

.bottom-rules-btn:hover {
    background: #218838;
    transform: translateY(-1px);
}

================================================================================

FILE: ./templates/index.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Two-Player Spades</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

<body>
    <!-- Floating score headers -->
    <!-- Update the floating game score section in index.html -->
    <div class="floating-game-score" id="floatingGameScore">
        <div class="game-score-item">
            <div class="game-score-label">Tom</div>
            <div class="game-score-parity" id="floatingPlayerParity">(EVEN)</div>
            <div class="game-score-value" id="floatingPlayerScore">0</div>
        </div>
        <div class="game-score-item">
            <div class="game-score-label">Hand #<span id="floatingHandNumber">1</span></div>
        </div>
        <div class="game-score-item">
            <div class="game-score-label">Marta</div>
            <div class="game-score-parity" id="floatingComputerParity">(ODD)</div>
            <div class="game-score-value" id="floatingComputerScore">0</div>
        </div>
    </div>

    <div class="floating-hand-score" id="floatingHandScore">
        <div class="hand-score-item">
            <div class="label">Tricks</div>
            <div class="value" id="floatingPlayerTricks">0</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bid</div>
            <div class="value" id="floatingPlayerBid">-</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bags</div>
            <div class="value" id="floatingPlayerBags">0</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Spades</div>
            <div class="value" id="floatingSpadesStatus">Not Broken</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bags</div>
            <div class="value" id="floatingComputerBags">0</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bid</div>
            <div class="value" id="floatingComputerBid">-</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Tricks</div>
            <div class="value" id="floatingComputerTricks">0</div>
        </div>
    </div>

    <div class="container">
        <div class="container">
            <!-- Play area and messages at top - always visible -->
            <div class="top-interactive-area">
                <div class="play-area" id="playArea">
                    <div id="trickDisplay"></div>
                </div>

                <div class="message" id="message">Loading game...</div>

                <!-- Clean Results Section -->
                <div class="results-section" id="resultsSection">
                    <div class="results-header">Hand Summary</div>
                    <div class="results-content" id="resultsContent"></div>
                </div>

                <!-- Blind Bidding Section for Discard Phase -->
                <div class="blind-bidding-section" id="discardBlindBiddingSection" style="display: none;">
                    <div class="blind-header">
                        <h3>Blind Bidding Available</h3>
                        <p>You're down by 100+ points. Go blind BEFORE seeing your cards for <strong>DOUBLE</strong>
                            points/penalties!</p>
                        <div class="blind-warning">
                            Must bid at least 5 tricks, get double rewards or double punishment!
                        </div>
                    </div>
                    <div class="bid-buttons blind-buttons">
                        <button onclick="makeBlindBid(5)" class="blind-bid-btn">BLIND 5</button>
                        <button onclick="makeBlindBid(6)" class="blind-bid-btn">BLIND 6</button>
                        <button onclick="makeBlindBid(7)" class="blind-bid-btn">BLIND 7</button>
                        <button onclick="makeBlindBid(8)" class="blind-bid-btn">BLIND 8</button>
                        <button onclick="makeBlindBid(9)" class="blind-bid-btn">BLIND 9</button>
                        <button onclick="makeBlindBid(10)" class="blind-bid-btn">BLIND 10</button>
                    </div>
                    <div class="regular-bid-prompt">
                        <p>Or discard normally and then make a regular bid:</p>
                    </div>
                </div>

                <div class="bidding-section" id="biddingSection" style="display: none;">
                    <div class="hand-title">Make Your Bid</div>
                    <p style="text-align: center; margin-bottom: 15px; font-size: 14px;">How many tricks will you take
                        out of 10?</p>

                    <!-- Regular bidding buttons -->
                    <div class="bid-buttons">
                        <button onclick="makeBid(0)" class="regular-bid-btn">0</button>
                        <button onclick="makeBid(1)" class="regular-bid-btn">1</button>
                        <button onclick="makeBid(2)" class="regular-bid-btn">2</button>
                        <button onclick="makeBid(3)" class="regular-bid-btn">3</button>
                        <button onclick="makeBid(4)" class="regular-bid-btn">4</button>
                        <button onclick="makeBid(5)" class="regular-bid-btn">5</button>
                        <button onclick="makeBid(6)" class="regular-bid-btn">6</button>
                        <button onclick="makeBid(7)" class="regular-bid-btn">7</button>
                        <button onclick="makeBid(8)" class="regular-bid-btn">8</button>
                        <button onclick="makeBid(9)" class="regular-bid-btn">9</button>
                        <button onclick="makeBid(10)" class="regular-bid-btn">10</button>
                    </div>
                </div>
            </div>

            <!-- Hands section - can scroll if needed -->
            <div class="hands-area">

                <div class="hand-section">
                    <div class="hand-title">
                        Your Hand (Tom)
                        <span style="font-size: 12px; color: #666; font-weight: normal;" id="playerHandCount"></span>
                    </div>
                    <div class="cards" id="playerHand"></div>
                    <div class="controls">
                        <button id="actionButton" onclick="performAction()">Discard Card</button>
                        <button id="nextHandButton" onclick="nextHand()" style="display: none;">Next Hand</button>
                    </div>
                </div>

                <!-- In the Marta's Hand section, modify this part: -->
                <div class="hand-section">
                    <div class="hand-title">
                        Marta's Hand
                        <!-- Only show toggle button if debug mode is enabled -->
                        <button id="toggleComputerHand" onclick="toggleComputerHand()" style="display: none;">Show
                            Cards</button>
                    </div>
                    <div class="cards" id="computerHand"></div>
                </div>

                <div class="discards-section" id="discardsSection" style="display: none;">
                    <div class="hand-title">Discarded Cards</div>
                    <div class="discards-content">
                        <div class="discard-item">
                            <div class="discard-label">Tom</div>
                            <div id="playerDiscard"></div>
                        </div>
                        <div class="discard-item">
                            <div class="discard-label">Marta</div>
                            <div id="computerDiscard"></div>
                        </div>
                    </div>
                </div>

                <div class="game-over" id="gameOver" style="display: none;">
                    <div class="winner-text" id="winnerText"></div>
                    <button onclick="startNewGame()">Play Again</button>
                </div>
            </div>

            <!-- Bottom New Game Section -->
            <!-- Bottom New Game Section -->
            <div class="bottom-section">
                <button class="bottom-new-game-btn" onclick="startNewGame()">New Game</button>
                <button class="bottom-rules-btn"
                    onclick="window.open('https://docs.google.com/spreadsheets/d/1uxxzX09zhGm0b8R48Fi4vHvOEyrlp1AmVN-sN41voj0/edit?usp=sharing', '_blank')">Rules</button>
            </div>

            <script src="{{ url_for('static', filename='game.js') }}"></script>
</body>

</html>

================================================================================

