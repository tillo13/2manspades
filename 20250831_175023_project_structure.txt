Number of files: 10
Number of directories: 5

Directory structure:
.
static
templates
utilities
utilities/__pycache__

List of file paths by type:

CSS Files (1):
  ./static/style.css

HTML Files (1):
  ./templates/index.html

JS Files (1):
  ./static/game.js

PY Files (7):
  ./app.py
  ./gather_pythons.py
  ./gcloud_deploy.py
  ./utilities/computer_logic.py
  ./utilities/custom_rules.py
  ./utilities/gameplay_logic.py
  ./utilities/logging_utils.py

================================================================================
FILE CONTENTS
================================================================================

FILE: ./gcloud_deploy.py
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Deployment script for Two Man Spades
This script manages deployment to Google App Engine for twomanspades project.
"""

import subprocess
import json
import time
import os
import sys
import random
import string

# Configuration - TWO MAN SPADES PROJECT SPECIFIC
EXPECTED_PROJECT_ID = "twomanspades"  # Critical: This must match your project
SERVICE_NAME = "default"
VERSION_MAX = 15  # Keep 15 versions to minimize storage costs

def print_separator():
    """Print a visual separator in console output."""
    print("\n" + "="*70 + "\n")

def check_gcloud_project():
    """Verify we're using the correct GCP project - CRITICAL SAFEGUARD."""
    print_separator()
    print("ðŸ”’ VERIFYING GOOGLE CLOUD PROJECT CONFIGURATION...")
    print(f"Expected project: {EXPECTED_PROJECT_ID}")
    
    try:
        current_project = subprocess.run(
            ["gcloud", "config", "get-value", "project"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True
        ).stdout.decode().strip()
        
        print(f"Current project:  {current_project}")
        
        if current_project != EXPECTED_PROJECT_ID:
            print(f"âŒ ERROR: Current gcloud project is '{current_project}' but expected '{EXPECTED_PROJECT_ID}'")
            print(f"ðŸ”„ Attempting to switch to the correct project...")
            
            # Try to use an existing configuration first
            try:
                configs_result = subprocess.run(
                    ["gcloud", "config", "configurations", "list", "--format=value(name)"],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True
                )
                configs = configs_result.stdout.decode().strip().split('\n')
                
                if "twomanspades-config" in configs:
                    print("ðŸ“‹ Using existing twomanspades-config configuration")
                    subprocess.run(
                        ["gcloud", "config", "configurations", "activate", "twomanspades-config"],
                        check=True
                    )
                else:
                    print("âš™ï¸  Setting project directly")
                    subprocess.run(
                        ["gcloud", "config", "set", "project", EXPECTED_PROJECT_ID],
                        check=True
                    )
            except subprocess.CalledProcessError:
                print("âš™ï¸  Setting project directly")
                subprocess.run(
                    ["gcloud", "config", "set", "project", EXPECTED_PROJECT_ID],
                    check=True
                )
            
            # CRITICAL: Verify the switch was successful
            current_project = subprocess.run(
                ["gcloud", "config", "get-value", "project"],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True
            ).stdout.decode().strip()
            
            if current_project != EXPECTED_PROJECT_ID:
                print(f"âŒ CRITICAL ERROR: Failed to switch to project {EXPECTED_PROJECT_ID}")
                print("ðŸ›‘ DEPLOYMENT ABORTED to prevent deploying to wrong project!")
                print("")
                print("Please manually set the project with one of these commands:")
                print(f"  gcloud config configurations activate twomanspades-config")
                print(f"  gcloud config set project {EXPECTED_PROJECT_ID}")
                print("")
                print("Then re-run this script.")
                sys.exit(1)
            else:
                print(f"âœ… Successfully switched to project {EXPECTED_PROJECT_ID}")
        else:
            print(f"âœ… Project verification passed - correctly configured for {EXPECTED_PROJECT_ID}")
    
    except subprocess.CalledProcessError as e:
        print(f"âŒ Error checking Google Cloud project: {e}")
        print("ðŸ›‘ DEPLOYMENT ABORTED")
        sys.exit(1)

# Function to get versions of a service
def get_versions(service_name):
    """Fetch the current versions of the App Engine service."""
    print(f"ðŸ“‹ Checking existing versions for service: {service_name}...")
    try:
        result = subprocess.run(
            ["gcloud", "app", "versions", "list", 
             "--service", service_name, 
             "--format", "json", 
             "--project", EXPECTED_PROJECT_ID],  # Always specify project
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        versions = json.loads(result.stdout)
        versions.sort(key=lambda x: x["version"]["createTime"], reverse=True)
        return versions
    except subprocess.CalledProcessError as e:
        if "Service not found" in e.stderr.decode() or f"Service [{service_name}] not found" in e.stderr.decode():
            print(f"ðŸ“ Service {service_name} not found. It will be created during deployment.")
            return []
        else:
            print(f"âŒ Error getting versions: {e.stderr.decode()}")
            raise e

# Function to delete versions
def delete_old_versions(service_name, versions_to_delete):
    """Delete older versions to maintain version limit."""
    if not versions_to_delete:
        return
    
    print(f"ðŸ§¹ Cleaning up old versions. Deleting {len(versions_to_delete)} older versions...")
    
    for v in versions_to_delete:
        version_id = v["id"]
        print(f"  - Deleting version {service_name}-{version_id}")
        subprocess.run(
            ["gcloud", "app", "versions", "delete", version_id, 
             "--service", service_name, 
             "--quiet", 
             "--project", EXPECTED_PROJECT_ID],  # Always specify project
            check=True)
    
    print("âœ… Cleanup complete.")

# Function to get changed files using git diff
def get_changed_files(directory):
    """Get list of new or modified files using git diff"""
    try:
        result = subprocess.run(
            ["git", "-C", directory, "diff", "--name-only", "HEAD^", "HEAD"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        files = result.stdout.decode().strip().split("\n")
        return [os.path.join(directory, f) for f in files if f]
    except subprocess.CalledProcessError:
        print("â„¹ï¸  Error determining changed files (this is normal for first deployment).")
        return []

def list_files_to_upload():
    """List files that will be uploaded to Google Cloud Storage."""
    print("ðŸ“ Files to be uploaded:")
    
    # Fallback: manually parse .gcloudignore and list files
    ignored_patterns = set()
    if os.path.exists('.gcloudignore'):
        with open('.gcloudignore', 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    ignored_patterns.add(line.rstrip('/'))
    
    # Default ignore patterns if no .gcloudignore exists
    if not ignored_patterns:
        ignored_patterns = {
            '.git',  'logging', '__pycache__', '*.pyc', '.env', 'venv*', 
            '.vscode', '.idea', '*.md', 'gather_pythons.py', 
            '*_project_structure.txt'
        }
    
    # Walk directory and respect .gcloudignore patterns
    files_to_upload = []
    for root, dirs, files in os.walk('.'):
        # Remove ignored directories from dirs to prevent walking into them
        dirs[:] = [d for d in dirs if not any(
            d == pattern or f"{root}/{d}".startswith(f"./{pattern}")
            for pattern in ignored_patterns
        )]
        
        for file in files:
            rel_path = os.path.relpath(os.path.join(root, file), '.')
            # Skip if file matches any ignore pattern
            if not any(
                rel_path.startswith(pattern) or file.endswith(pattern.lstrip('*'))
                for pattern in ignored_patterns
            ):
                files_to_upload.append(rel_path)
    
    # Print the files
    for file in sorted(files_to_upload):
        print(f"  - {file}")
    
    print(f"\nðŸ“Š Total files to upload: {len(files_to_upload)}")

# Function to generate a valid version name
def generate_version_name():
    random_string = ''.join(random.choices(string.ascii_lowercase + string.digits, k=10))
    return f"version-{random_string}"

# Function to deploy the services
def deploy_service(service_name, yaml_path):
    """Deploy the application to Google App Engine."""
    start_time = time.time()
    current_directory = os.path.dirname(os.path.abspath(yaml_path))
    
    print_separator()
    print(f"ðŸš€ DEPLOYING TWO MAN SPADES TO GOOGLE APP ENGINE")
    print(f"ðŸ“¦ Project: {EXPECTED_PROJECT_ID}")
    print(f"âš™ï¸  Service: {service_name}")
    print(f"ðŸ“‚ Deploy from: {current_directory}")
    print(f"ðŸ“„ Using config: {yaml_path}")
    print_separator()
    
    # List changed files
    print("ðŸ“ Listing new or modified files to be uploaded:")
    changed_files = get_changed_files(current_directory)
    if changed_files:
        for file_path in changed_files:
            print(f"  ðŸ“„ Changed file: {file_path}")
    else:
        print("  â„¹ï¸  No new or modified files detected (normal for first deployment).")
    
    # Check the current versions
    try:
        versions = get_versions(service_name)
        print(f"âœ… {len(versions)} versions retrieved successfully.")
    except subprocess.CalledProcessError as e:
        versions = []
        print(f"âš ï¸  Failed to get versions. Error: {e}")
        print(f"ðŸ“ First deployment for service {service_name}. Proceeding with deployment.")
    
    print(f"ðŸ“Š You currently have {len(versions)} versions for {service_name}.")
    if versions:
        print(f"ðŸ“‹ The latest version is {versions[0]['id']} for {service_name}.")
    
    if len(versions) > VERSION_MAX:
        print(f"ðŸ§¹ More than {VERSION_MAX} versions exist for {service_name}.")
    
    # Show files that will be uploaded
    print_separator()
    list_files_to_upload()
    
    # Deploy new version
    print_separator()
    version_name = generate_version_name()
    print(f"ðŸš€ Deploying new version: {version_name}")
    try:
        result = subprocess.run([
            "gcloud", "app", "deploy", yaml_path, 
            "--quiet", 
            "--project", EXPECTED_PROJECT_ID,  # Always specify project
            "--version", version_name
        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        print("âœ… Deployment successful!")
    except subprocess.CalledProcessError as e:
        print(f"âŒ Failed to deploy new version. Error: {e.stderr.decode()}")
        return  # Early exit if deployment fails
    
    # Delete old versions if needed
    if len(versions) > VERSION_MAX:
        print_separator()
        try:
            # Get fresh list of versions after deployment
            updated_versions = get_versions(service_name)
            versions_to_delete = updated_versions[VERSION_MAX:]
            delete_old_versions(service_name, versions_to_delete)
        except subprocess.CalledProcessError as e:
            print(f"âš ï¸  Failed to delete old versions. Error: {e.stderr.decode()}")

    # Calculate and display execution time
    end_time = time.time()
    execution_time = end_time - start_time
    
    # Display the target URL
    print_separator()
    print(f"â±ï¸  Deployment completed in {execution_time:.2f} seconds.")
    print(f"ðŸŒ Your Two Man Spades game is now live at:")
    print(f"  - https://{EXPECTED_PROJECT_ID}.appspot.com")
    print_separator()

# Main deployment function
def main_deploy():
    # CRITICAL: Verify project before doing ANYTHING
    check_gcloud_project()
    
    # Deploy the service
    deploy_service(SERVICE_NAME, 'app.yaml')
    
    # Automatically tail logs
    print(f"\nðŸ“‹ Tailing logs... (Press Ctrl+C to stop)")
    try:
        subprocess.run([
            "gcloud", "app", "logs", "tail",
            "--service", SERVICE_NAME,
            "--project", EXPECTED_PROJECT_ID  # Always specify project
        ])
    except KeyboardInterrupt:
        print("\n\nâ¹ï¸  Stopped tailing logs.")
        print(f"ðŸ“‹ You can view logs anytime with: gcloud app logs tail -s {SERVICE_NAME} --project {EXPECTED_PROJECT_ID}")

if __name__ == "__main__":
    print(f"ðŸ”’ You have chosen to keep {VERSION_MAX} versions of your app.")
    main_deploy()

================================================================================

FILE: ./app.py
--------------------------------------------------------------------------------
from flask import Flask, render_template, request, session, jsonify
import sys
import os
import logging

# Add utilities directory to path if running as main
if __name__ == '__main__':
    sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from utilities.gameplay_logic import (
    init_game,
    init_new_hand,
    sort_hand,
    is_valid_play,
    determine_trick_winner,
    computer_follow,
    computer_lead,
    check_game_over
)

from utilities.custom_rules import (
    assign_even_odd_at_game_start,
    calculate_discard_score_with_winner,
    calculate_hand_scores_with_bags,
    get_player_names_with_parity,
    check_special_cards_in_discard,
    reduce_bags_safely,
    check_blind_bidding_eligibility
)

from utilities.computer_logic import (
    computer_bidding_brain,
    computer_discard_strategy
)

# Import logging utilities
from utilities.logging_utils import (
    initialize_game_logging_with_client,
    log_action,
    log_game_event,
    log_ai_decision,
    track_session_client,
    finalize_game_logging
)

app = Flask(__name__)
app.secret_key = 'your-secret-key-change-this'

DEBUG_MODE = False  # Set to False to hide Marta's cards completely

def get_display_score(base_score, bags):
    """Convert base score and bags to display score (bags in ones column)"""
    # Only modify ones digit if bags are non-negative
    if bags >= 0:
        # For negative scores, we need to handle the ones digit differently
        if base_score < 0:
            # Remove ones digit from negative number and subtract bags
            tens_and_higher = (base_score // 10) * 10
            return tens_and_higher - bags
        else:
            # For positive scores, remove ones digit and add bags
            tens_and_higher = (base_score // 10) * 10
            return tens_and_higher + bags
    else:
        # If bags are negative, show base score unchanged
        return base_score

def get_base_score_from_display(display_score, bags):
    """Convert display score back to base score (removing bags from ones column)"""
    return display_score - bags

def track_request_session():
    """Track client info for this request session"""
    if 'game' in session:
        return track_session_client(session, request)
    return None

def resolve_trick_with_delay(game, session_obj=None):
    """Resolve trick and set it up to be displayed for 3 seconds with logging"""
    if len(game['current_trick']) != 2:
        return
    
    winner = determine_trick_winner(game['current_trick'])
    
    # SAVE TRICK TO HISTORY BEFORE PROCESSING
    trick_number = len(game.get('trick_history', [])) + 1
    player_card = next((play['card'] for play in game['current_trick'] if play['player'] == 'player'), None)
    computer_card = next((play['card'] for play in game['current_trick'] if play['player'] == 'computer'), None)
    
    game.setdefault('trick_history', []).append({
        'number': trick_number,
        'player_card': player_card,
        'computer_card': computer_card,
        'winner': winner
    })
    
    # LOG TRICK COMPLETION TO CONSOLE AND JSON
    p_text = f"{player_card['rank']}{player_card['suit']}" if player_card else "?"
    c_text = f"{computer_card['rank']}{computer_card['suit']}" if computer_card else "?"
    winner_name = "Tom" if winner == 'player' else "Marta"
    print(f"TRICK {trick_number}: {p_text} vs {c_text} -> {winner_name} wins")
    
    # LOG TO JSON AS WELL
    if session_obj:
        log_game_event(
            event_type='trick_completed',
            event_data={
                'trick_number': trick_number,
                'player_card': p_text,
                'computer_card': c_text,
                'winner': winner,
                'winner_name': winner_name
            },
            session=session_obj
        )
    
    # Check for special cards in the trick and apply bag reduction IMMEDIATELY
    from utilities.custom_rules import check_special_cards_in_trick, reduce_bags_safely
    special_result = check_special_cards_in_trick(game['current_trick'], winner)
    
    if special_result['bag_reduction'] > 0:
        if winner == 'player':
            current_bags = game.get('player_bags', 0)
            game['player_bags'] = reduce_bags_safely(current_bags, special_result['bag_reduction'])
            game['player_trick_special_cards'] = game.get('player_trick_special_cards', 0) + special_result['bag_reduction']
        else:
            current_bags = game.get('computer_bags', 0)
            game['computer_bags'] = reduce_bags_safely(current_bags, special_result['bag_reduction'])
            game['computer_trick_special_cards'] = game.get('computer_trick_special_cards', 0) + special_result['bag_reduction']
        
        game['special_card_message'] = special_result['explanation']
        
        # Log special card effect
        if session_obj:
            log_game_event(
                event_type='special_card_effect',
                event_data={
                    'trick_number': trick_number,
                    'bag_reduction': special_result['bag_reduction'],
                    'beneficiary': winner_name,
                    'explanation': special_result['explanation']
                },
                session=session_obj
            )
    
    # Award trick
    if winner == 'player':
        game['player_tricks'] += 1
        base_message = 'You won the trick!'
    else:
        game['computer_tricks'] += 1
        base_message = 'Marta won the trick!'
    
    # Add special card info to message if present
    if special_result['explanation']:
        game['message'] = f"{base_message} {special_result['explanation']} Cards will clear in 3 seconds..."
    else:
        game['message'] = f"{base_message} Cards will clear in 3 seconds..."
    
    # Mark trick as completed but don't clear yet
    game['trick_completed'] = True
    game['trick_winner'] = winner

def computer_follow_with_logging(game, session_obj=None):
    """Computer plays a card when following with logging"""
    hand = game['computer_hand']
    trick = game['current_trick']
    
    if not trick or not hand:
        return
    
    # Use enhanced following strategy from computer_logic
    from utilities.computer_logic import computer_follow_strategy
    chosen_idx = computer_follow_strategy(hand, trick, game)
    
    if chosen_idx is None:
        # Fallback to original simple logic if strategy fails
        lead_card = trick[0]['card']
        lead_suit = lead_card['suit']
        lead_value = lead_card['value']
        
        # Find valid plays
        same_suit = [(i, c) for i, c in enumerate(hand) if c['suit'] == lead_suit]
        spades = [(i, c) for i, c in enumerate(hand) if c['suit'] == 'â™ ']
        
        if same_suit:
            # Must follow suit - try to win with lowest winning card
            winners = [(i, c) for i, c in same_suit if c['value'] > lead_value]
            if winners:
                chosen_idx = min(winners, key=lambda x: x[1]['value'])[0]
            else:
                # Can't win, play lowest
                chosen_idx = min(same_suit, key=lambda x: x[1]['value'])[0]
        elif lead_suit != 'â™ ' and spades:
            # Can't follow suit, can trump with spade
            chosen_idx = min(spades, key=lambda x: x[1]['value'])[0]
        else:
            # Can't follow or trump, discard lowest
            all_cards = [(i, c) for i, c in enumerate(hand)]
            chosen_idx = min(all_cards, key=lambda x: x[1]['value'])[0]
    
    # Play the chosen card
    card = hand.pop(chosen_idx)
    game['current_trick'].append({'player': 'computer', 'card': card})
    
    # LOG COMPUTER'S RESPONSE
    if session_obj:
        lead_card = game['current_trick'][0]['card'] if len(game['current_trick']) >= 1 else None
        log_action(
            action_type='card_play',
            player='computer',
            action_data={
                'card_played': f"{card['rank']}{card['suit']}",
                'trick_position': 2,
                'following_suit': card['suit'] == lead_card['suit'] if lead_card else False
            },
            session=session_obj,
            additional_context={
                'responding_to': f"{lead_card['rank']}{lead_card['suit']}" if lead_card else None,
                'hand_size_after': len(hand)
            }
        )
    
    if card['suit'] == 'â™ ':
        game['spades_broken'] = True
        if session_obj:
            log_game_event('spades_broken', {'broken_by': 'computer', 'card': f"{card['rank']}{card['suit']}"}, session_obj)

def computer_lead_with_logging(game, session_obj=None):
    """Computer plays a card when leading with logging"""
    hand = game['computer_hand']
    
    if not hand:
        return
    
    # Use enhanced leading strategy from computer_logic
    from utilities.computer_logic import computer_lead_strategy
    chosen_idx = computer_lead_strategy(hand, game['spades_broken'])
    
    if chosen_idx is None:
        # Fallback to original simple logic if strategy fails
        valid = []
        for i, card in enumerate(hand):
            if card['suit'] != 'â™ ' or game['spades_broken'] or all(c['suit'] == 'â™ ' for c in hand):
                valid.append((i, card))
        
        if valid:
            chosen = min(valid, key=lambda x: (x[1]['suit'] == 'â™ ', x[1]['value']))
            chosen_idx = chosen[0]
        else:
            return
    
    # Play the chosen card
    card = hand.pop(chosen_idx)
    game['current_trick'] = [{'player': 'computer', 'card': card}]
    game['trick_leader'] = 'computer'
    
    # LOG COMPUTER'S LEAD
    if session_obj:
        log_action(
            action_type='card_play',
            player='computer',
            action_data={
                'card_played': f"{card['rank']}{card['suit']}",
                'trick_position': 1,
                'leading': True
            },
            session=session_obj,
            additional_context={
                'hand_size_after': len(hand)
            }
        )
    
    if card['suit'] == 'â™ ':
        game['spades_broken'] = True
        if session_obj:
            log_game_event('spades_broken', {'broken_by': 'computer', 'card': f"{card['rank']}{card['suit']}"}, session_obj)

# In the index() route:
@app.route('/')
def index():
    # Check if we should force a new game (via query parameter)
    force_new = request.args.get('new', '').lower() == 'true'
    
    # Only start fresh if explicitly requested or no existing game
    if force_new or 'game' not in session:
        session.clear()
        player_parity, computer_parity, first_player = assign_even_odd_at_game_start()
        game = init_game(player_parity, computer_parity, first_player)
        # Initialize logging with client tracking
        game = initialize_game_logging_with_client(game, request)
        session['game'] = game
    
    # If there's an existing game, preserve it
    return render_template('index.html')

@app.route('/new_game', methods=['POST'])
def new_game():
    # Track client session
    client_info = track_request_session()
    
    # Finalize previous game logging if exists
    if 'game' in session:
        finalize_game_logging(session['game'])
    
    # Assign new even/odd and first player for the new game
    player_parity, computer_parity, first_player = assign_even_odd_at_game_start()
    game = init_game(player_parity, computer_parity, first_player)
    # Initialize logging with client tracking - this starts a new JSON file
    game = initialize_game_logging_with_client(game, request)
    session['game'] = game
    
    # Log the new game start
    log_game_event(
        event_type='new_game_started',
        event_data={
            'player_parity': player_parity,
            'computer_parity': computer_parity,
            'first_leader': first_player
        },
        session=session
    )
    
    return jsonify({'success': True})

@app.route('/state')
def get_state():
    if 'game' not in session:
        player_parity, computer_parity, first_player = assign_even_odd_at_game_start()
        session['game'] = init_game(player_parity, computer_parity, first_player)
    
    game = session['game']
    
    # Get player names with parity
    player_name, computer_name = get_player_names_with_parity(
        game.get('player_parity', 'even'),
        game.get('computer_parity', 'odd')
    )
    
    # Only show discard_bonus_explanation if hand is over
    show_discard_explanation = game.get('hand_over', False)
    discard_explanation = game.get('discard_bonus_explanation') if show_discard_explanation else None
    
    # Calculate display scores (base score + bags)
    player_base_score = game.get('player_score', 0)
    computer_base_score = game.get('computer_score', 0)
    player_bags = game.get('player_bags', 0)
    computer_bags = game.get('computer_bags', 0)
    
    player_display_score = get_display_score(player_base_score, player_bags)
    computer_display_score = get_display_score(computer_base_score, computer_bags)
    
    # Prepare safe state
    safe_state = {
        'player_hand': game['player_hand'],
        # Only include computer_hand_count if DEBUG_MODE is True
        'computer_hand_count': len(game['computer_hand']) if DEBUG_MODE else 0,
        'current_trick': game['current_trick'],
        'player_tricks': game['player_tricks'],
        'computer_tricks': game['computer_tricks'],
        'spades_broken': game['spades_broken'],
        'phase': game['phase'],
        'turn': game['turn'],
        'trick_leader': game.get('trick_leader'),
        'hand_over': game.get('hand_over', False),
        'game_over': game.get('game_over', False),
        'winner': game['winner'],
        'message': game['message'],
        'player_discarded': game.get('player_discarded'),
        'computer_discarded': game.get('computer_discarded'),
        'show_computer_hand': game.get('show_computer_hand', False) and DEBUG_MODE,
        'player_bid': game.get('player_bid'),
        'computer_bid': game.get('computer_bid'),
        'total_tricks': game.get('total_tricks', 10),
        'player_score': player_display_score,  # Display score with bags
        'computer_score': computer_display_score,  # Display score with bags
        'player_base_score': player_base_score,  # Keep base score for internal calculations
        'computer_base_score': computer_base_score,  # Keep base score for internal calculations
        'player_bags': player_bags,
        'computer_bags': computer_bags,
        'hand_number': game.get('hand_number', 1),
        'target_score': game.get('target_score', 300),
        'player_parity': game.get('player_parity', 'even'),
        'computer_parity': game.get('computer_parity', 'odd'),
        'player_name': player_name,
        'computer_name': computer_name,
        'discard_bonus_explanation': discard_explanation,
        'blind_bidding_available': game.get('blind_bidding_available', False),
        'blind_bid': game.get('blind_bid'),
        'computer_blind_bid': game.get('computer_blind_bid'),
        'debug_mode': DEBUG_MODE,
        'hand_results': game.get('hand_results')
    }
    
    # Include computer hand only if debug mode is on AND showing
    if DEBUG_MODE and game.get('show_computer_hand', False):
        safe_state['computer_hand'] = game['computer_hand']
    
    return jsonify(safe_state)

# Modify the toggle_computer_hand route:
@app.route('/toggle_computer_hand', methods=['POST'])
def toggle_computer_hand():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    # Don't allow toggling if debug mode is off
    if not DEBUG_MODE:
        return jsonify({'error': 'Debug mode disabled'}), 400
    
    game = session['game']
    game['show_computer_hand'] = not game.get('show_computer_hand', False)
    session.modified = True
    
    return jsonify({'success': True, 'showing': game['show_computer_hand']})

@app.route('/blind_bid', methods=['POST'])
def make_blind_bid():
    """Handle blind bidding before discard phase"""
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    # Track client session
    client_info = track_request_session()
    
    game = session['game']
    data = request.get_json()
    bid = data.get('bid')
    
    if game['phase'] != 'discard':
        return jsonify({'error': 'Can only make blind bid before discard'}), 400
    
    # Check blind bidding eligibility using base scores
    player_base_score = game.get('player_score', 0)
    computer_base_score = game.get('computer_score', 0)
    blind_eligibility = check_blind_bidding_eligibility(player_base_score, computer_base_score)
    
    if not blind_eligibility['player_eligible']:
        return jsonify({'error': 'Not eligible for blind bidding'}), 400
    
    if bid < 5 or bid > 10:
        return jsonify({'error': 'Blind bid must be between 5 and 10'}), 400
    
    # Log blind bid
    log_action(
        action_type='blind_bid',
        player='player',
        action_data={
            'bid_amount': bid,
            'deficit': blind_eligibility['player_deficit']
        },
        session=session,
        request=request
    )
    
    # Set blind bid and regular bid
    game['blind_bid'] = bid
    game['player_bid'] = bid
    
    # Computer makes its decision (might also go blind if eligible)
    computer_bid, computer_is_blind = computer_bidding_brain(
        game['computer_hand'], 
        bid, 
        game
    )
    game['computer_bid'] = computer_bid
    
    if computer_is_blind:
        game['computer_blind_bid'] = computer_bid
        log_action(
            action_type='blind_bid',
            player='computer',
            action_data={
                'bid_amount': computer_bid,
                'in_response_to_player': True
            },
            session=session
        )
    else:
        log_action(
            action_type='regular_bid',
            player='computer',
            action_data={
                'bid_amount': computer_bid,
                'in_response_to_blind': True
            },
            session=session
        )
    
    # Now proceed to discard with bids already set
    player_blind_text = " (BLIND)"
    computer_blind_text = " (BLIND)" if computer_is_blind else ""
    game['message'] = f'You bid {bid}{player_blind_text}, Marta bid {computer_bid}{computer_blind_text}. Now select a card to discard.'
    
    # Stay in discard phase but with bids set
    session.modified = True
    return jsonify({'success': True})

@app.route('/bid', methods=['POST'])
def make_bid():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    # Track client session
    client_info = track_request_session()
    
    game = session['game']
    data = request.get_json()
    bid = data.get('bid')
    
    if game['phase'] != 'bidding':
        return jsonify({'error': 'Not in bidding phase'}), 400
    
    if bid < 0 or bid > 10:
        return jsonify({'error': 'Bid must be between 0 and 10'}), 400
    
    # Log player bid
    log_action(
        action_type='regular_bid',
        player='player',
        action_data={
            'bid_amount': bid,
            'is_nil': bid == 0
        },
        session=session,
        request=request
    )
    
    # Player makes regular bid
    game['player_bid'] = bid
    
    # Check if computer has already bid (Martha-first scenario)
    if game.get('computer_bid') is None:
        # Normal scenario - computer bids after player
        computer_bid, computer_is_blind = computer_bidding_brain(
            game['computer_hand'], 
            bid, 
            game
        )
        game['computer_bid'] = computer_bid
        
        # Handle computer blind bid
        if computer_is_blind:
            game['computer_blind_bid'] = computer_bid
            log_action(
                action_type='blind_bid',
                player='computer',
                action_data={
                    'bid_amount': computer_bid,
                    'in_response_to_player': True
                },
                session=session
            )
        else:
            log_action(
                action_type='regular_bid',
                player='computer',
                action_data={
                    'bid_amount': computer_bid,
                    'in_response_to_player': True
                },
                session=session
            )
            
        computer_blind_text = " (BLIND)" if computer_is_blind else ""
        player_blind_text = " (BLIND)" if game.get('blind_bid') == bid else ""
        
        message_base = f'You bid {bid}{player_blind_text}, Martha bid {computer_bid}{computer_blind_text}.'
    else:
        # Martha already bid - just acknowledge Tom's bid
        computer_blind_text = " (BLIND)" if game.get('computer_blind_bid') else ""
        player_blind_text = " (BLIND)" if game.get('blind_bid') == bid else ""
        
        message_base = f'You bid {bid}{player_blind_text}, Martha bid {game["computer_bid"]}{computer_blind_text}.'
    
    # Start playing phase with the designated first leader
    game['phase'] = 'playing'
    first_leader = game.get('first_leader', 'player')
    game['turn'] = first_leader
    game['trick_leader'] = first_leader
    
    # Log bidding phase complete
    log_game_event(
        event_type='bidding_complete',
        event_data={
            'player_bid': game['player_bid'],
            'computer_bid': game['computer_bid'],
            'first_leader': first_leader,
            'player_blind': game.get('blind_bid') is not None,
            'computer_blind': game.get('computer_blind_bid') is not None
        },
        session=session
    )
    
    # Create message indicating who leads first
    if first_leader == 'player':
        game['message'] = f'{message_base} Your turn to lead the first trick.'
    else:
        game['message'] = f'{message_base} Martha leads the first trick.'
        # If computer leads, make the computer play immediately
        computer_lead_with_logging(game, session)
        game['turn'] = 'player'
        game['message'] = f'{message_base} Martha led. Your turn to follow.'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/discard', methods=['POST'])
def discard_card():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    # Track client session
    client_info = track_request_session()
    
    game = session['game']
    data = request.get_json()
    card_index = data.get('index')
    
    if game['phase'] != 'discard':
        return jsonify({'error': 'Not in discard phase'}), 400
    
    if card_index < 0 or card_index >= len(game['player_hand']):
        return jsonify({'error': 'Invalid card index'}), 400
    
    # Player discards
    player_card = game['player_hand'].pop(card_index)
    game['player_discarded'] = player_card
    
    # Log player discard
    log_action(
        action_type='discard',
        player='player',
        action_data={
            'card_discarded': f"{player_card['rank']}{player_card['suit']}",
            'card_index': card_index
        },
        session=session,
        additional_context={
            'hand_size_after': len(game['player_hand'])
        },
        request=request
    )
    
    # Computer discards using enhanced strategy
    idx = computer_discard_strategy(game['computer_hand'], game)
    computer_card = game['computer_hand'].pop(idx)
    game['computer_discarded'] = computer_card
    
    # Log computer discard
    log_action(
        action_type='discard',
        player='computer',
        action_data={
            'card_discarded': f"{computer_card['rank']}{computer_card['suit']}",
            'card_index': idx
        },
        session=session,
        additional_context={
            'hand_size_after': len(game['computer_hand'])
        }
    )
    
    # Calculate discard bonus points and determine winner
    discard_result = calculate_discard_score_with_winner(
        game['player_discarded'],
        game['computer_discarded'],
        game.get('player_parity', 'even'),
        game.get('computer_parity', 'odd')
    )
    
    # Store discard results for later reveal
    game['pending_discard_result'] = discard_result
    
    # Check for special cards in discards and store for later
    special_discard_result = check_special_cards_in_discard(
        game['player_discarded'],
        game['computer_discarded'],
        discard_result['winner']
    )
    
    game['pending_special_discard_result'] = special_discard_result
    
    # Log discard results
    log_game_event(
        event_type='discard_scoring',
        event_data={
            'player_card': f"{player_card['rank']}{player_card['suit']}",
            'computer_card': f"{computer_card['rank']}{computer_card['suit']}",
            'winner': discard_result['winner'],
            'bonus_points': discard_result['player_bonus'] + discard_result['computer_bonus'],
            'is_double': discard_result['is_double'],
            'explanation': discard_result['explanation']
        },
        session=session
    )
    
    # Check if bids were already made (blind bidding scenario)
    if game.get('player_bid') is not None:
        # Bids already set, go straight to playing
        game['phase'] = 'playing'
        first_leader = game.get('first_leader', 'player')
        game['turn'] = first_leader
        game['trick_leader'] = first_leader
        
        player_blind_text = " (BLIND)" if game.get('blind_bid') else ""
        computer_blind_text = " (BLIND)" if game.get('computer_blind_bid') else ""
        
        if first_leader == 'player':
            game['message'] = f'Cards discarded. You bid {game["player_bid"]}{player_blind_text}, Martha bid {game["computer_bid"]}{computer_blind_text}. Your turn to lead the first trick.'
        else:
            game['message'] = f'Cards discarded. You bid {game["player_bid"]}{player_blind_text}, Martha bid {game["computer_bid"]}{computer_blind_text}. Martha leads the first trick.'
            # If computer leads, make the computer play immediately
            computer_lead_with_logging(game, session)
            game['turn'] = 'player'
            game['message'] = f'Cards discarded. You bid {game["player_bid"]}{player_blind_text}, Martha bid {game["computer_bid"]}{computer_blind_text}. Martha led. Your turn to follow.'
    else:
        # Normal flow - determine bidding order
        player_base_score = game.get('player_score', 0)
        computer_base_score = game.get('computer_score', 0)
        blind_eligibility = check_blind_bidding_eligibility(player_base_score, computer_base_score)
        
        # Determine who bids first based on game conditions
        should_martha_bid_first = determine_martha_bids_first(game)
        
        if should_martha_bid_first:
            # Martha bids first
            computer_bid, computer_is_blind = computer_bidding_brain(
                game['computer_hand'], 
                None,  # No player bid yet since Martha goes first
                game
            )
            game['computer_bid'] = computer_bid
            
            if computer_is_blind:
                game['computer_blind_bid'] = computer_bid
                log_action(
                    action_type='blind_bid',
                    player='computer',
                    action_data={
                        'bid_amount': computer_bid,
                        'martha_bids_first': True
                    },
                    session=session
                )
            else:
                log_action(
                    action_type='regular_bid',
                    player='computer',
                    action_data={
                        'bid_amount': computer_bid,
                        'martha_bids_first': True
                    },
                    session=session
                )
            
            # Start bidding phase with Martha's bid already made
            game['phase'] = 'bidding'
            game['turn'] = 'player'
            
            computer_blind_text = " (BLIND)" if computer_is_blind else ""
            game['message'] = f'Cards discarded. Martha bid {computer_bid}{computer_blind_text} tricks. Now make your bid: How many tricks will you take? (0-10)'
        else:
            # Tom bids first (normal flow)
            if blind_eligibility['player_eligible']:
                game['blind_bidding_available'] = True
                game['message'] = f'Cards discarded. You are down by {blind_eligibility["player_deficit"]} points - would you like to go BLIND? (5-10 tricks, double points/penalties) Or make a regular bid? (0-10)'
            else:
                game['blind_bidding_available'] = False
                game['message'] = f'Cards discarded. Now make your bid: How many tricks will you take? (0-10)'
            
            # Start bidding phase
            game['phase'] = 'bidding'
            game['turn'] = 'player'
    
    session.modified = True
    return jsonify({'success': True})


def determine_martha_bids_first(game):
    """
    Determine if Martha should bid first based on game conditions.
    You can customize this logic based on your game rules.
    """
    player_base_score = game.get('player_score', 0)
    computer_base_score = game.get('computer_score', 0)
    hand_number = game.get('hand_number', 1)
    
    # Example conditions for Martha to bid first:
    # 1. Martha is significantly behind (100+ points)
    # 2. Alternating pattern based on hand number
    # 3. Random chance
    # 4. Based on who won the discard pile
    
    # Condition 1: Martha bids first when she's behind by 75+ points
    if computer_base_score <= player_base_score - 75:
        return True
    
    # Condition 2: Martha bids first on even hand numbers when scores are close
    score_diff = abs(player_base_score - computer_base_score)
    if score_diff <= 50 and hand_number % 2 == 0:
        return True
    
    # Condition 3: Martha bids first if she won the discard pile
    pending_discard = game.get('pending_discard_result')
    if pending_discard and pending_discard.get('winner') == 'computer':
        return True
    
    # Default: Tom bids first
    return False

@app.route('/play', methods=['POST'])
def play_card():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    # Track client session
    client_info = track_request_session()
    
    game = session['game']
    data = request.get_json()
    card_index = data.get('index')
    
    if game['phase'] != 'playing':
        return jsonify({'error': 'Not in playing phase'}), 400
    
    if game['turn'] != 'player':
        return jsonify({'error': 'Not your turn'}), 400
    
    if card_index < 0 or card_index >= len(game['player_hand']):
        return jsonify({'error': 'Invalid card index'}), 400
    
    card = game['player_hand'][card_index]
    
    # Validate the play
    if not is_valid_play(card, game['player_hand'], game['current_trick'], game['spades_broken']):
        return jsonify({'error': 'Invalid play - must follow suit if possible'}), 400
    
    # LOG THE PLAYER'S CARD PLAY
    log_action(
        action_type='card_play',
        player='player', 
        action_data={
            'card_played': f"{card['rank']}{card['suit']}",
            'card_index': card_index,
            'trick_position': len(game['current_trick']) + 1,
            'leading': len(game['current_trick']) == 0
        },
        session=session,
        additional_context={
            'hand_size_before': len(game['player_hand']),
            'spades_broken_before': game['spades_broken']
        },
        request=request
    )
    
    # Play the card
    game['player_hand'].pop(card_index)
    game['current_trick'].append({'player': 'player', 'card': card})
    
    if card['suit'] == 'â™ ':
        game['spades_broken'] = True
        log_game_event('spades_broken', {'broken_by': 'player', 'card': f"{card['rank']}{card['suit']}"}, session)
    
    # Determine next action based on trick state
    if len(game['current_trick']) == 1:
        # Player just led, computer needs to follow
        game['trick_leader'] = 'player'
        game['turn'] = 'computer'
        computer_follow_with_logging(game, session)
        # After computer follows, resolve the trick with delay
        resolve_trick_with_delay(game, session)
    elif len(game['current_trick']) == 2:
        # This shouldn't happen in normal flow, but handle it
        resolve_trick_with_delay(game, session)
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/clear_trick', methods=['POST'])
def clear_trick():
    """Called by frontend after displaying trick for 3 seconds"""
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    game = session['game']
    
    # CHANGE THIS: Don't error if trick is already cleared
    if not game.get('trick_completed'):
        return jsonify({'success': True, 'message': 'No trick to clear'}), 200  # Changed to 200
    
    
    winner = game.get('trick_winner')
    
    # Clear the trick
    game['current_trick'] = []
    game['trick_completed'] = False
    game['trick_winner'] = None
    
    # Check for hand over
    if len(game['player_hand']) == 0:
        game['hand_over'] = True
        
        # Log hand completion
        log_game_event(
            event_type='hand_completed',
            event_data={
                'hand_number': game['hand_number'],
                'player_tricks': game['player_tricks'],
                'computer_tricks': game['computer_tricks'],
                'player_bid': game.get('player_bid', 0),
                'computer_bid': game.get('computer_bid', 0)
            },
            session=session
        )
        
        # Apply stored discard results at the end of the hand
        if 'pending_discard_result' in game:
            discard_result = game['pending_discard_result']
            game['player_score'] += discard_result['player_bonus']
            game['computer_score'] += discard_result['computer_bonus']
            
            # Apply special card effects from discards
            if 'pending_special_discard_result' in game:
                special_discard_result = game['pending_special_discard_result']
                
                if special_discard_result['player_bag_reduction'] > 0:
                    game['player_bags'] = reduce_bags_safely(
                        game.get('player_bags', 0), 
                        special_discard_result['player_bag_reduction']
                    )
                
                if special_discard_result['computer_bag_reduction'] > 0:
                    game['computer_bags'] = reduce_bags_safely(
                        game.get('computer_bags', 0), 
                        special_discard_result['computer_bag_reduction']
                    )
                
                # Store explanation for the final message
                game['discard_bonus_explanation'] = discard_result['explanation']
                if special_discard_result['explanation']:
                    game['discard_bonus_explanation'] += " | " + special_discard_result['explanation']
            else:
                game['discard_bonus_explanation'] = discard_result['explanation']
            
            # Clean up pending results
            del game['pending_discard_result']
            if 'pending_special_discard_result' in game:
                del game['pending_special_discard_result']
        
        # Calculate scoring with bags system
        scoring_result = calculate_hand_scores_with_bags(game)
        
        # Create structured hand results for cleaner display
        trick_history = game.get('trick_history', [])
        
        # Calculate display scores for hand results
        player_display_score = get_display_score(game['player_score'], game.get('player_bags', 0))
        computer_display_score = get_display_score(game['computer_score'], game.get('computer_bags', 0))
        
        hand_results = {
            'hand_number': game['hand_number'],
            'parity': {
                'player': game.get('player_parity', 'even').title(),
                'computer': game.get('computer_parity', 'odd').title()
            },
            'discard_info': game.get('discard_bonus_explanation', ''),
            'scoring': scoring_result['explanation'],
            'trick_history': [
                {
                    'number': trick['number'],
                    'player_card': f"{trick['player_card']['rank']}{trick['player_card']['suit']}" if trick['player_card'] else "?",
                    'computer_card': f"{trick['computer_card']['rank']}{trick['computer_card']['suit']}" if trick['computer_card'] else "?",
                    'winner': "Tom" if trick['winner'] == 'player' else "Marta"
                }
                for trick in trick_history
            ],
            'totals': {
                'player_score': player_display_score,  # Display score with bags
                'computer_score': computer_display_score  # Display score with bags
            }
        }
        
        # Store structured results for frontend
        game['hand_results'] = hand_results
        
        # Log final scoring
        log_game_event(
            event_type='hand_scoring',
            event_data={
                'scoring_explanation': scoring_result['explanation'],
                'final_scores': {
                    'player_score': player_display_score,
                    'computer_score': computer_display_score
                },
                'hand_results': hand_results
            },
            session=session
        )
        
        # Simple message for basic display
        game['message'] = f"Hand #{game['hand_number']} complete! Click 'Next Hand' to continue"
        
        # Check if game is over using base scores for comparison
        game_over = check_game_over(game)
        if game_over:
            log_game_event(
                event_type='game_completed',
                event_data={
                    'winner': game['winner'],
                    'final_message': game['message'],
                    'hands_played': game['hand_number']
                },
                session=session
            )
        
    elif winner == 'computer':
        # Computer won last trick, so computer leads
        computer_lead_with_logging(game, session)
        game['turn'] = 'player'
        game['message'] = 'Marta led. Your turn to follow.'
    else:
        # Player won last trick, player leads next
        game['turn'] = 'player'
        game['message'] = 'You won the trick! Your turn to lead.'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/next_hand', methods=['POST'])
def next_hand():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    # Track client session
    client_info = track_request_session()
    
    game = session['game']
    
    if not game.get('hand_over', False) or game.get('game_over', False):
        return jsonify({'error': 'Cannot start next hand'}), 400
    
    # Log new hand start
    log_game_event(
        event_type='new_hand_started',
        event_data={
            'previous_hand': game['hand_number'],
            'new_hand': game['hand_number'] + 1
        },
        session=session
    )
    
    # Increment hand number and start new hand
    game['hand_number'] += 1
    init_new_hand(game)
    
    session.modified = True
    return jsonify({'success': True})


if __name__ == '__main__':
    import subprocess
    import webbrowser
    import time
    import socket
    
    def kill_process_on_port(port):
        """Kill any process using the specified port"""
        try:
            # macOS/Linux approach
            result = subprocess.run(['lsof', '-ti:' + str(port)], capture_output=True, text=True)
            if result.stdout.strip():
                pids = result.stdout.strip().split('\n')
                for pid in pids:
                    if pid.strip():
                        subprocess.run(['kill', '-9', pid.strip()], capture_output=True)
                        print(f"Killed process {pid.strip()} on port {port}")
                time.sleep(1)
                return True
        except FileNotFoundError:
            try:
                # Windows approach
                result = subprocess.run(['netstat', '-ano'], capture_output=True, text=True)
                for line in result.stdout.split('\n'):
                    if f':{port}' in line and 'LISTENING' in line:
                        parts = line.split()
                        if parts:
                            pid = parts[-1]
                            subprocess.run(['taskkill', '/F', '/PID', pid], capture_output=True)
                            print(f"Killed process {pid} on port {port}")
                time.sleep(1)
                return True
            except:
                pass
        except Exception as e:
            print(f"Could not kill processes on port {port}: {e}")
        return False
    
    def is_port_available(port):
        """Check if a port is available"""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        result = sock.connect_ex(('localhost', port))
        sock.close()
        return result != 0
    
    def find_available_port(start_port=5000, max_attempts=10):
        """Find an available port, killing processes if needed"""
        for port in range(start_port, start_port + max_attempts):
            if is_port_available(port):
                print(f"Port {port} is available")
                return port
            else:
                print(f"Port {port} is in use, attempting to kill process...")
                if kill_process_on_port(port):
                    # Check again after killing
                    time.sleep(0.5)
                    if is_port_available(port):
                        print(f"Successfully freed port {port}")
                        return port
                    else:
                        print(f"Port {port} still in use after kill attempt")
                else:
                    print(f"Could not kill process on port {port}")
        
        raise RuntimeError(f"Could not find an available port in range {start_port}-{start_port + max_attempts - 1}")
    
    # Find and secure a port
    try:
        port = find_available_port(5000, 10)
    except RuntimeError as e:
        print(f"Error: {e}")
        print("Please manually kill processes or restart your computer")
        exit(1)
    
    def open_browser():
        time.sleep(1.5)
        url = f'http://localhost:{port}'
        
        chrome_paths = [
            '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',
            'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe',
            'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
            '/usr/bin/google-chrome',
            '/usr/bin/chromium-browser',
        ]
        
        opened = False
        for chrome_path in chrome_paths:
            if os.path.exists(chrome_path):
                try:
                    subprocess.Popen([chrome_path, url])
                    print(f"Opened Chrome at {url}")
                    opened = True
                    break
                except:
                    pass
        
        # If Chrome wasn't found, use default browser
        if not opened:
            webbrowser.open(url)
            print(f"Opened default browser at {url}")
    
    # Start browser opening in a separate thread
    from threading import Thread
    browser_thread = Thread(target=open_browser)
    browser_thread.daemon = True
    browser_thread.start()
    
    print(f"Starting Flask app on port {port}...")
    print(f"The browser should open automatically in a moment...")
    print(f"If not, navigate to http://localhost:{port}")
    
    # Run Flask app
    app.run(debug=True, port=port, use_reloader=False)

================================================================================

FILE: ./gather_pythons.py
--------------------------------------------------------------------------------
import os
from datetime import datetime

# Configuration
# Set file types to include
FILE_EXTENSIONS = [
    '.py',    # Python files (always included)
    '.html',  # HTML files
    '.js',    # JavaScript files
    '.css',   # CSS files
    '.json',  # JSON configuration files
]

# Flag to control directory depth
ONLY_ROOT_DIRECTORY = False  # Set to True to only search in root directory

# Filename patterns to exclude (new)
EXCLUDED_FILENAME_PATTERNS = [
    'copy',   # Any file with 'copy' in the name
    'backup', # Any file with 'backup' in the name
    'temp',   # Any file with 'temp' in the name
        'archives',   # Any file with 'temp' in the name
]

# Directories to completely exclude from both scanning and output
EXCLUDED_DIRECTORIES = [
    "assets",
    "tests",
    "previous_versions",
    "projects",
    "tools",
    "revisions_app",
    "venv_de",
    ".git",
    "archives"

]

def gather_files(root_dir, excluded_directories, file_extensions, excluded_patterns, only_root=False):
    """
    Gathers files with specified extensions within the root directory and its subdirectories,
    excluding specified directories and filename patterns.

    Parameters:
        root_dir (str): The root directory to search for files.
        excluded_directories (list): List of directory names to exclude.
        file_extensions (list): List of file extensions to include.
        excluded_patterns (list): List of filename patterns to exclude.
        only_root (bool): If True, only search in the root directory (no subdirectories).

    Returns:
        tuple: (files_data, included_directories)
    """
    files_data = []
    included_directories = set()

    if only_root:
        # Only process files in the root directory
        relative_path = "."
        included_directories.add(relative_path)
        
        try:
            filenames = os.listdir(root_dir)
            for filename in filenames:
                file_path = os.path.join(root_dir, filename)
                
                # Skip directories
                if os.path.isdir(file_path):
                    continue
                
                # Skip files with excluded patterns in the filename
                if any(pattern.lower() in filename.lower() for pattern in excluded_patterns):
                    continue
                    
                # Only include files with the specified extensions
                if any(filename.endswith(ext) for ext in file_extensions):
                    try:
                        with open(file_path, 'r', encoding='utf-8') as file:
                            file_contents = file.read()
                        files_data.append((file_path, file_contents))
                    except UnicodeDecodeError:
                        print(f"Could not read file {file_path} due to encoding error. Skipping.")
                    except Exception as e:
                        print(f"Error with file {file_path}: {e}")
        except Exception as e:
            print(f"Error accessing root directory: {e}")
    else:
        # Original recursive behavior
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Get the relative path
            relative_path = os.path.relpath(dirpath, root_dir)
            
            # Skip excluded directories - check if any part of the path matches exclusion patterns
            should_exclude = False
            for excluded_dir in excluded_directories:
                # Check both exact match and path-based matches
                if excluded_dir == relative_path or excluded_dir in relative_path.replace('\\', '/'):
                    should_exclude = True
                    break
                    
            if should_exclude:
                continue

            # Add directory to our structure
            included_directories.add(relative_path)
            
            # Process files
            for filename in filenames:
                file_path = os.path.join(dirpath, filename)
                
                # Skip files with excluded patterns in the filename
                if any(pattern.lower() in filename.lower() for pattern in excluded_patterns):
                    continue
                    
                # Only include files with the specified extensions
                if any(filename.endswith(ext) for ext in file_extensions):
                    try:
                        with open(file_path, 'r', encoding='utf-8') as file:
                            file_contents = file.read()
                        files_data.append((file_path, file_contents))
                    except UnicodeDecodeError:
                        print(f"Could not read file {file_path} due to encoding error. Skipping.")
                    except Exception as e:
                        print(f"Error with file {file_path}: {e}")

    return files_data, sorted(included_directories)

def write_to_file(output_filepath, files_data, included_directories):
    """
    Writes the gathered data to a file with project information and file contents.
    """
    with open(output_filepath, 'w', encoding='utf-8') as file:
        # Write statistics
        file.write(f"Number of files: {len(files_data)}\n")
        file.write(f"Number of directories: {len(included_directories)}\n\n")
        
        # Write directory structure
        file.write("Directory structure:\n")
        for directory in included_directories:
            file.write(f"{directory}\n")
        file.write("\n")
        
        # Group and list files by extension
        extension_groups = {}
        for filepath, _ in files_data:
            ext = os.path.splitext(filepath)[1].lower()
            if ext not in extension_groups:
                extension_groups[ext] = []
            extension_groups[ext].append(filepath)
        
        file.write("List of file paths by type:\n")
        for ext, filepaths in sorted(extension_groups.items()):
            file.write(f"\n{ext.upper()[1:]} Files ({len(filepaths)}):\n")
            for filepath in sorted(filepaths):
                file.write(f"  {filepath}\n")
        file.write("\n")
        
        # Write file contents
        file.write("="*80 + "\n")
        file.write("FILE CONTENTS\n")
        file.write("="*80 + "\n\n")
        
        for filepath, file_contents in files_data:
            file.write(f"FILE: {filepath}\n")
            file.write("-"*80 + "\n")
            file.write(f"{file_contents}\n\n")
            file.write("="*80 + "\n\n")

def scan_project_structure():
    """
    Main function to scan the project structure and write the results to a file.
    """
    root_dir = "."  # Current directory
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_filepath = f"{timestamp}_project_structure.txt"
    
    print(f"Starting to scan project structure at {root_dir}...")
    print(f"Including file types: {', '.join(FILE_EXTENSIONS)}")
    print(f"Excluding file patterns: {', '.join(EXCLUDED_FILENAME_PATTERNS)}")
    
    if ONLY_ROOT_DIRECTORY:
        print("Scanning ONLY root directory (subdirectories will be skipped)")
    else:
        print(f"Excluding directories: {', '.join(EXCLUDED_DIRECTORIES)}")
    
    # Gather files and directory information
    files_data, included_directories = gather_files(
        root_dir, 
        EXCLUDED_DIRECTORIES, 
        FILE_EXTENSIONS,
        EXCLUDED_FILENAME_PATTERNS,
        only_root=ONLY_ROOT_DIRECTORY
    )
    
    print(f"Found {len(files_data)} files across {len(included_directories)} directories.")
    if not ONLY_ROOT_DIRECTORY:
        print(f"Excluded directories won't appear in the output file.")
    
    # Write the output file
    write_to_file(
        output_filepath, 
        files_data, 
        included_directories
    )
    
    print(f"Project structure has been written to {output_filepath}")
    print(f"File size: {os.path.getsize(output_filepath) / (1024*1024):.2f} MB")

if __name__ == "__main__":
    scan_project_structure()

================================================================================

FILE: ./utilities/gameplay_logic.py
--------------------------------------------------------------------------------
import random

def create_deck():
    """Create a standard 52-card deck"""
    suits = ['â™ ', 'â™¥', 'â™¦', 'â™£']
    ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
    deck = []
    for suit in suits:
        for rank in ranks:
            deck.append({'rank': rank, 'suit': suit, 'value': get_card_value(rank)})
    return deck

def get_card_value(rank):
    """Get numerical value of a card rank"""
    if rank == 'A':
        return 14
    elif rank == 'K':
        return 13
    elif rank == 'Q':
        return 12
    elif rank == 'J':
        return 11
    else:
        return int(rank)

def sort_hand(hand):
    """Sort hand by suit (clubs, diamonds, hearts, spades) then by value"""
    suit_order = {'â™£': 0, 'â™¦': 1, 'â™¥': 2, 'â™ ': 3}
    return sorted(hand, key=lambda x: (suit_order[x['suit']], x['value']))

def init_game(player_parity='even', computer_parity='odd', first_leader='player'):
    """Initialize a new game"""
    deck = create_deck()
    random.shuffle(deck)
    
    return {
        'player_hand': sort_hand(deck[:11]),
        'computer_hand': sort_hand(deck[11:22]),
        'current_trick': [],
        'player_tricks': 0,
        'computer_tricks': 0,
        'spades_broken': False,
        'phase': 'discard',
        'turn': 'player',  # Both players can discard simultaneously
        'trick_leader': None,
        'hand_over': False,
        'game_over': False,
        'winner': None,
        'message': 'Select a card to discard',
        'player_discarded': None,
        'computer_discarded': None,
        'show_computer_hand': False,
        'trick_display_timer': None,
        'player_bid': None,
        'computer_bid': None,
        'total_tricks': 10,
        'player_score': 0,
        'computer_score': 0,
        'player_bags': 0,
        'computer_bags': 0,
        'player_trick_special_cards': 0,
        'computer_trick_special_cards': 0,
        'hand_number': 1,
        'target_score': 300,
        'player_parity': player_parity,
        'computer_parity': computer_parity,
        'first_leader': first_leader,  # Who leads the first trick of each hand
        'discard_bonus_explanation': None,
        'pending_discard_result': None,
        'pending_special_discard_result': None,
        'blind_bidding_available': False,
        'blind_bid': None,
        'computer_blind_bid': None,
        'blind_multiplier': 2,
        'trick_history': []  # Track all tricks played this hand
    }

def init_new_hand(game):
    """Start a new hand while preserving scores, bags, and parity assignments"""
    deck = create_deck()
    random.shuffle(deck)
    
    # Alternate who leads the first trick each hand
    current_first_leader = game.get('first_leader', 'player')
    next_first_leader = 'computer' if current_first_leader == 'player' else 'player'
    
    game.update({
        'player_hand': sort_hand(deck[:11]),
        'computer_hand': sort_hand(deck[11:22]),
        'current_trick': [],
        'player_tricks': 0,
        'computer_tricks': 0,
        'spades_broken': False,
        'phase': 'discard',
        'turn': 'player',  # Always player can discard first (simultaneous)
        'trick_leader': None,
        'hand_over': False,
        'message': f'Hand #{game["hand_number"]} - Select a card to discard',
        'player_discarded': None,
        'computer_discarded': None,
        'show_computer_hand': False,
        'trick_display_timer': None,
        'player_bid': None,
        'computer_bid': None,
        'total_tricks': 10,
        'discard_bonus_explanation': None,
        'player_trick_special_cards': 0,
        'computer_trick_special_cards': 0,
        'pending_discard_result': None,
        'pending_special_discard_result': None,
        'blind_bidding_available': False,
        'blind_bid': None,
        'computer_blind_bid': None,
        'first_leader': next_first_leader,  # Alternate who leads first trick
        'trick_history': []  # Reset trick history for new hand
    })

def computer_bidding_brain(computer_hand, player_bid, game_state=None):
    """
    Computer bidding function - now delegates to computer_logic module
    """
    if game_state is None:
        # Fallback for backward compatibility
        game_state = {'player_score': 0, 'computer_score': 0, 'computer_bags': 0}
    
    from .computer_logic import computer_bidding_brain as enhanced_brain
    return enhanced_brain(computer_hand, player_bid, game_state)

def computer_discard_strategy(computer_hand, game_state=None):
    """
    Computer discard strategy - now delegates to computer_logic module
    """
    if game_state is None:
        # Fallback to simple strategy for backward compatibility
        computer_discards = []
        for i, card in enumerate(computer_hand):
            if card['suit'] != 'â™ ':
                computer_discards.append((i, card['value']))
        
        if computer_discards:
            return min(computer_discards, key=lambda x: x[1])[0]
        else:
            return 0
    
    from .computer_logic import computer_discard_strategy as enhanced_discard
    return enhanced_discard(computer_hand, game_state)

def is_valid_play(card, hand, trick, spades_broken):
    """Check if a card play is valid according to Spades rules"""
    if len(trick) == 0:
        # Leading
        if card['suit'] == 'â™ ' and not spades_broken:
            # Can only lead spades if no other suits
            for c in hand:
                if c['suit'] != 'â™ ':
                    return False
        return True
    else:
        # Following
        lead_suit = trick[0]['card']['suit']
        # Must follow suit if possible
        has_suit = any(c['suit'] == lead_suit for c in hand)
        if has_suit:
            return card['suit'] == lead_suit
        return True

def determine_trick_winner(trick):
    """
    Determine who won a completed trick
    Returns the player who won ('player' or 'computer')
    """
    if len(trick) != 2:
        return None
    
    first = trick[0]
    second = trick[1]
    
    if first['card']['suit'] == second['card']['suit']:
        # Same suit, higher value wins
        if first['card']['value'] > second['card']['value']:
            return first['player']
        else:
            return second['player']
    elif first['card']['suit'] == 'â™ ':
        # First player trumped
        return first['player']
    elif second['card']['suit'] == 'â™ ':
        # Second player trumped  
        return second['player']
    else:
        # Different suits, no trump - first player (leader) wins
        return first['player']

def resolve_trick_with_delay(game):
    """Resolve trick and set it up to be displayed for 3 seconds"""
    if len(game['current_trick']) != 2:
        return
    
    winner = determine_trick_winner(game['current_trick'])
    
    # SAVE TRICK TO HISTORY BEFORE PROCESSING
    trick_number = len(game.get('trick_history', [])) + 1
    player_card = next((play['card'] for play in game['current_trick'] if play['player'] == 'player'), None)
    computer_card = next((play['card'] for play in game['current_trick'] if play['player'] == 'computer'), None)
    
    game.setdefault('trick_history', []).append({
        'number': trick_number,
        'player_card': player_card,
        'computer_card': computer_card,
        'winner': winner
    })
    
    # LOG EACH TRICK TO CONSOLE
    p_text = f"{player_card['rank']}{player_card['suit']}" if player_card else "?"
    c_text = f"{computer_card['rank']}{computer_card['suit']}" if computer_card else "?"
    winner_name = "Tom" if winner == 'player' else "Marta"
    print(f"TRICK {trick_number}: {p_text} vs {c_text} -> {winner_name} wins")
    
    
    # Check for special cards in the trick and apply bag reduction IMMEDIATELY
    from utilities.custom_rules import check_special_cards_in_trick, reduce_bags_safely
    special_result = check_special_cards_in_trick(game['current_trick'], winner)
    
    if special_result['bag_reduction'] > 0:
        if winner == 'player':
            current_bags = game.get('player_bags', 0)
            game['player_bags'] = reduce_bags_safely(current_bags, special_result['bag_reduction'])
            game['player_trick_special_cards'] = game.get('player_trick_special_cards', 0) + special_result['bag_reduction']
        else:
            current_bags = game.get('computer_bags', 0)
            game['computer_bags'] = reduce_bags_safely(current_bags, special_result['bag_reduction'])
            game['computer_trick_special_cards'] = game.get('computer_trick_special_cards', 0) + special_result['bag_reduction']
        
        game['special_card_message'] = special_result['explanation']
    
    # Award trick
    if winner == 'player':
        game['player_tricks'] += 1
        base_message = 'You won the trick!'
    else:
        game['computer_tricks'] += 1
        base_message = 'Marta won the trick!'
    
    # Add special card info to message if present
    if special_result['explanation']:
        game['message'] = f"{base_message} {special_result['explanation']} Cards will clear in 3 seconds..."
    else:
        game['message'] = f"{base_message} Cards will clear in 3 seconds..."
    
    # Mark trick as completed but don't clear yet
    game['trick_completed'] = True
    game['trick_winner'] = winner

def computer_follow(game):
    """Computer plays a card when following - now uses bag avoidance strategy"""
    hand = game['computer_hand']
    trick = game['current_trick']
    
    if not trick or not hand:
        return
    
    # Use enhanced following strategy from computer_logic
    from .computer_logic import computer_follow_strategy
    chosen_idx = computer_follow_strategy(hand, trick, game)
    
    if chosen_idx is None:
        # Fallback to original simple logic if strategy fails
        lead_card = trick[0]['card']
        lead_suit = lead_card['suit']
        lead_value = lead_card['value']
        
        # Find valid plays
        same_suit = [(i, c) for i, c in enumerate(hand) if c['suit'] == lead_suit]
        spades = [(i, c) for i, c in enumerate(hand) if c['suit'] == 'â™ ']
        
        if same_suit:
            # Must follow suit - try to win with lowest winning card
            winners = [(i, c) for i, c in same_suit if c['value'] > lead_value]
            if winners:
                chosen_idx = min(winners, key=lambda x: x[1]['value'])[0]
            else:
                # Can't win, play lowest
                chosen_idx = min(same_suit, key=lambda x: x[1]['value'])[0]
        elif lead_suit != 'â™ ' and spades:
            # Can't follow suit, can trump with spade
            chosen_idx = min(spades, key=lambda x: x[1]['value'])[0]
        else:
            # Can't follow or trump, discard lowest
            all_cards = [(i, c) for i, c in enumerate(hand)]
            chosen_idx = min(all_cards, key=lambda x: x[1]['value'])[0]
    
    # Play the chosen card
    card = hand.pop(chosen_idx)
    game['current_trick'].append({'player': 'computer', 'card': card})
    
    if card['suit'] == 'â™ ':
        game['spades_broken'] = True

def computer_lead(game):
    """Computer plays a card when leading - now uses enhanced strategy"""
    hand = game['computer_hand']
    
    if not hand:
        return
    
    # Use enhanced leading strategy from computer_logic
    from .computer_logic import computer_lead_strategy
    chosen_idx = computer_lead_strategy(hand, game['spades_broken'])
    
    if chosen_idx is None:
        # Fallback to original simple logic if strategy fails
        valid = []
        for i, card in enumerate(hand):
            if card['suit'] != 'â™ ' or game['spades_broken'] or all(c['suit'] == 'â™ ' for c in hand):
                valid.append((i, card))
        
        if valid:
            chosen = min(valid, key=lambda x: (x[1]['suit'] == 'â™ ', x[1]['value']))
            chosen_idx = chosen[0]
        else:
            return
    
    # Play the chosen card
    card = hand.pop(chosen_idx)
    game['current_trick'] = [{'player': 'computer', 'card': card}]
    game['trick_leader'] = 'computer'
    
    if card['suit'] == 'â™ ':
        game['spades_broken'] = True

def check_game_over(game):
    """
    Check if the game is over (someone reached target score OR down by 300+ points)
    Updates game state with winner information if game is over
    Uses proper tie-breaking logic considering base scores and bags
    """
    player_base_score = game['player_score']
    computer_base_score = game['computer_score']
    player_bags = game.get('player_bags', 0)
    computer_bags = game.get('computer_bags', 0)
    target_score = game['target_score']
    
    # Calculate display scores inline (no import needed)
    def calc_display_score(base_score, bags):
        if bags >= 0:
            if base_score < 0:
                tens_and_higher = (base_score // 10) * 10
                return tens_and_higher - bags
            else:
                tens_and_higher = (base_score // 10) * 10
                return tens_and_higher + bags
        else:
            return base_score
    
    player_display_score = calc_display_score(player_base_score, player_bags)
    computer_display_score = calc_display_score(computer_base_score, computer_bags)
    
    # Check for 300-point deficit rule (mercy rule) using display scores
    if player_display_score - computer_display_score >= 300:
        game['game_over'] = True
        game['winner'] = 'player'
        game['message'] = f"GAME OVER! You WIN by mercy rule {player_display_score} to {computer_display_score}! (300+ point lead)"
        return True
    elif computer_display_score - player_display_score >= 300:
        game['game_over'] = True
        game['winner'] = 'computer'
        game['message'] = f"GAME OVER! Marta WINS by mercy rule {computer_display_score} to {player_display_score}! (300+ point lead)"
        return True
    
    # Check for regular target score (300 points) using display scores
    if player_display_score >= target_score or computer_display_score >= target_score:
        game['game_over'] = True
        
        if player_display_score > computer_display_score:
            game['winner'] = 'player'
            game['message'] = f"GAME OVER! You WIN {player_display_score} to {computer_display_score}!"
        elif computer_display_score > player_display_score:
            game['winner'] = 'computer'
            game['message'] = f"GAME OVER! Marta WINS {computer_display_score} to {player_display_score}!"
        else:
            # Tie-breaking logic
            if player_base_score > computer_base_score:
                game['winner'] = 'player'
                game['message'] = f"GAME OVER! You WIN {player_display_score} to {computer_display_score} (tie-breaker)!"
            elif computer_base_score > player_base_score:
                game['winner'] = 'computer'
                game['message'] = f"GAME OVER! Marta WINS {computer_display_score} to {player_display_score} (tie-breaker)!"
            else:
                # Bags tie-breaker - negative bags lose
                if player_bags < 0 and computer_bags >= 0:
                    game['winner'] = 'computer'
                    game['message'] = f"GAME OVER! Marta WINS {computer_display_score} to {player_display_score} (negative bags lose)!"
                elif computer_bags < 0 and player_bags >= 0:
                    game['winner'] = 'player'
                    game['message'] = f"GAME OVER! You WIN {player_display_score} to {computer_display_score} (negative bags lose)!"
                elif player_bags < computer_bags:
                    game['winner'] = 'player'
                    game['message'] = f"GAME OVER! You WIN {player_display_score} to {computer_display_score} (fewer bags)!"
                elif computer_bags < player_bags:
                    game['winner'] = 'computer' 
                    game['message'] = f"GAME OVER! Marta WINS {computer_display_score} to {player_display_score} (fewer bags)!"
                else:
                    game['winner'] = 'tie'
                    game['message'] = f"GAME OVER! TIE at {player_display_score} points each!"
        
        return True
    
    return False

================================================================================

FILE: ./utilities/custom_rules.py
--------------------------------------------------------------------------------
import random

def get_discard_value(card):
    """
    Get the numerical value of a card for discard scoring.
    J=11, Q=12, K=13, A=1, numbers are face value
    """
    rank = card['rank']
    if rank == 'A':
        return 1
    elif rank == 'J':
        return 11
    elif rank == 'Q':
        return 12
    elif rank == 'K':
        return 13
    else:
        return int(rank)

def assign_even_odd_at_game_start():
    """
    Randomly assign even/odd to players at the start of a new game.
    Also determines who leads the first trick - if player is odd, they lead first.
    Returns tuple: (player_parity, computer_parity, first_leader)
    """
    coin_flip = random.choice(['even', 'odd'])
    if coin_flip == 'even':
        player_parity = 'even'
        computer_parity = 'odd'
        first_leader = 'computer'  # Computer (odd) leads first trick
    else:
        player_parity = 'odd'
        computer_parity = 'even'
        first_leader = 'player'   # Player (odd) leads first trick
    
    return (player_parity, computer_parity, first_leader)

def is_special_card(card):
    """
    Check if a card is one of the special bag-reducing cards.
    Returns tuple: (is_special, bags_to_remove)
    """
    if card['rank'] == '7' and card['suit'] == 'â™¦':
        return True, 2  # 7 of diamonds removes 2 bags
    elif card['rank'] == '10' and card['suit'] == 'â™£':
        return True, 1  # 10 of clubs removes 1 bag
    else:
        return False, 0

def check_blind_bidding_eligibility(player_score, computer_score, target_score=300):
    """
    Check if a player is eligible for blind bidding (down by 100+ points).
    
    Returns:
        dict: {
            'player_eligible': bool,
            'computer_eligible': bool,
            'player_deficit': int,
            'computer_deficit': int
        }
    """
    player_deficit = computer_score - player_score
    computer_deficit = player_score - computer_score
    
    return {
        'player_eligible': player_deficit >= 100,
        'computer_eligible': computer_deficit >= 100,
        'player_deficit': max(0, player_deficit),
        'computer_deficit': max(0, computer_deficit)
    }

def apply_blind_scoring(base_points, blind_bid, actual_tricks):
    """
    Apply blind bidding scoring rules.
    
    Args:
        base_points: Normal points that would be awarded
        blind_bid: The blind bid amount (5-10)
        actual_tricks: Actual tricks taken
        
    Returns:
        int: Modified points (doubled if successful, doubled penalty if failed)
    """
    if actual_tricks >= blind_bid:
        # Successful blind bid: double the points
        return base_points * 2
    else:
        # Failed blind bid: double the penalty
        return base_points * 2  # base_points will already be negative for failed bids

def check_special_cards_in_discard(player_discard, computer_discard, discard_winner):
    """
    Check for special cards in the discard pile and apply bag reduction to the winner.
    """
    total_reduction = 0
    special_cards_found = []
    
    # Check both discarded cards for special cards
    for card, discarder in [(player_discard, 'Tom'), (computer_discard, 'Marta')]:
        if card:
            is_special, reduction = is_special_card(card)
            if is_special:
                total_reduction += reduction
                card_name = f"{card['rank']}{card['suit']}"
                special_cards_found.append(f"{card_name} (-{reduction} bags)")
    
    # Apply all reductions to the winner of the discard pile
    player_reduction = 0
    computer_reduction = 0
    
    if total_reduction > 0:
        if discard_winner == 'player':
            player_reduction = total_reduction
        else:
            computer_reduction = total_reduction
    
    # Create explanation
    explanation = ""
    if special_cards_found:
        winner_name = "Tom" if discard_winner == 'player' else "Marta"
        cards_text = ", ".join(special_cards_found)
        explanation = f"{winner_name} won discard pile with special cards: {cards_text}"
    
    return {
        'player_bag_reduction': player_reduction,
        'computer_bag_reduction': computer_reduction,
        'explanation': explanation
    }

def check_special_cards_in_trick(trick, winner):
    """
    Check for special cards in a completed trick and apply bag reduction to winner.
    """
    total_reduction = 0
    special_cards_found = []
    
    for play in trick:
        card = play['card']
        is_special, reduction = is_special_card(card)
        if is_special:
            total_reduction += reduction
            card_name = f"{card['rank']}{card['suit']}"
            special_cards_found.append(f"{card_name} (-{reduction} bags)")
    
    explanation = ""
    if special_cards_found:
        winner_name = "Tom" if winner == 'player' else "Marta"
        cards_text = ", ".join(special_cards_found)
        explanation = f"{winner_name} won trick with special cards: {cards_text}"
    
    return {
        'bag_reduction': total_reduction,
        'explanation': explanation
    }

def calculate_discard_score_with_winner(player_discard, computer_discard, player_parity, computer_parity):
    """Calculate the bonus points from discarded cards and determine winner."""
    if not player_discard or not computer_discard:
        return {
            'player_bonus': 0,
            'computer_bonus': 0, 
            'total': 0,
            'is_double': False,
            'winner': None,
            'explanation': 'No discards to score'
        }
    
    # Calculate total value
    player_value = get_discard_value(player_discard)
    computer_value = get_discard_value(computer_discard)
    total = player_value + computer_value
    
    # Check for doubles (same suit OR same rank)
    is_double = (player_discard['suit'] == computer_discard['suit'] or 
                 player_discard['rank'] == computer_discard['rank'])
    
    # Determine base points (10 for normal, 20 for doubles)
    base_points = 20 if is_double else 10
    
    # Award points based on parity and determine winner
    player_bonus = 0
    computer_bonus = 0
    winner = None
    
    is_total_even = (total % 2 == 0)
    
    if is_total_even and player_parity == 'even':
        player_bonus = base_points
        winner = 'player'
    elif not is_total_even and player_parity == 'odd':
        player_bonus = base_points
        winner = 'player'
    elif is_total_even and computer_parity == 'even':
        computer_bonus = base_points
        winner = 'computer'
    elif not is_total_even and computer_parity == 'odd':
        computer_bonus = base_points
        winner = 'computer'
    
    # Create explanation
    double_text = ""
    if is_double:
        if player_discard['suit'] == computer_discard['suit']:
            double_text = f" (DOUBLE: Both {player_discard['suit']} suit!)"
        else:
            double_text = f" (DOUBLE: Both {player_discard['rank']}s!)"
    
    parity_text = "even" if is_total_even else "odd"
    
    explanation = f"Discards: {player_discard['rank']}{player_discard['suit']} ({player_value}) + {computer_discard['rank']}{computer_discard['suit']} ({computer_value}) = {total} ({parity_text}){double_text}"
    
    if player_bonus > 0:
        explanation += f" â†’ Tom gets {player_bonus} pts!"
    elif computer_bonus > 0:
        explanation += f" â†’ Marta gets {computer_bonus} pts!"
    else:
        explanation += " â†’ No bonus points this hand."
    
    return {
        'player_bonus': player_bonus,
        'computer_bonus': computer_bonus,
        'total': total,
        'is_double': is_double,
        'winner': winner,
        'explanation': explanation
    }

def apply_bags_penalty(score, bags):
    """Apply bags penalty system."""
    penalty_applied = False
    bonus_applied = False
    
    while bags >= 7:
        score -= 100
        bags -= 7
        penalty_applied = True
    
    while bags <= -5:
        score += 100
        bags += 5
        bonus_applied = True
    
    return score, bags, penalty_applied, bonus_applied

def reduce_bags_safely(current_bags, reduction):
    """Reduce bags by the specified amount. Bags can go negative."""
    return current_bags - reduction


def calculate_hand_scores_with_bags(game):
    """
    Calculate hand scoring including bags system, nil bids, and blind bidding for both players.
    """
    player_bid = game.get('player_bid', 0)
    computer_bid = game.get('computer_bid', 0)
    player_actual = game.get('player_tricks', 0)
    computer_actual = game.get('computer_tricks', 0)
    
    # Check blind bids for both players
    is_player_blind = game.get('blind_bid') == player_bid and game.get('blind_bid') is not None
    is_computer_blind = game.get('computer_blind_bid') == computer_bid and game.get('computer_blind_bid') is not None
    
    # Get current bags
    current_player_bags = game.get('player_bags', 0)
    current_computer_bags = game.get('computer_bags', 0)
    
    # Calculate player points
    if player_bid == 0:
        if player_actual == 0:
            player_hand_points = 200  # Changed from 100 to 200
            player_bags_added = 0
        else:
            player_hand_points = -200  # Changed from -100 to -200
            player_bags_added = player_actual
    elif player_actual >= player_bid:
        player_hand_points = (player_bid * 10)
        player_bags_added = player_actual - player_bid
        if is_player_blind:
            player_hand_points = apply_blind_scoring(player_hand_points, player_bid, player_actual)
    else:
        player_hand_points = -(player_bid * 10)
        player_bags_added = 0
        if is_player_blind:
            player_hand_points = apply_blind_scoring(player_hand_points, player_bid, player_actual)
    
    # Calculate computer points (now with blind support!)
    if computer_bid == 0:
        if computer_actual == 0:
            computer_hand_points = 200  # Changed from 100 to 200
            computer_bags_added = 0
        else:
            computer_hand_points = -200  # Changed from -100 to -200
            computer_bags_added = computer_actual
    elif computer_actual >= computer_bid:
        computer_hand_points = (computer_bid * 10)
        computer_bags_added = computer_actual - computer_bid
        if is_computer_blind:
            computer_hand_points = apply_blind_scoring(computer_hand_points, computer_bid, computer_actual)
    else:
        computer_hand_points = -(computer_bid * 10)
        computer_bags_added = 0
        if is_computer_blind:
            computer_hand_points = apply_blind_scoring(computer_hand_points, computer_bid, computer_actual)
    
    # Update bag counts
    new_player_bags = current_player_bags + player_bags_added
    new_computer_bags = current_computer_bags + computer_bags_added
    
    # Apply bag penalties/bonuses
    player_score = game.get('player_score', 0) + player_hand_points
    computer_score = game.get('computer_score', 0) + computer_hand_points
    
    player_score, final_player_bags, player_penalty, player_bonus = apply_bags_penalty(player_score, new_player_bags)
    computer_score, final_computer_bags, computer_penalty, computer_bonus = apply_bags_penalty(computer_score, new_computer_bags)
    
    # Update game state
    game['player_bags'] = final_player_bags
    game['computer_bags'] = final_computer_bags
    game['player_score'] = player_score
    game['computer_score'] = computer_score
    
    # Get special card tracking for summary
    player_trick_special_cards = game.get('player_trick_special_cards', 0)
    computer_trick_special_cards = game.get('computer_trick_special_cards', 0)
    
    # Reset special card tracking for next hand
    game['player_trick_special_cards'] = 0
    game['computer_trick_special_cards'] = 0
    
    # Create explanation with blind bid support
    explanation_parts = []
    
    # Player explanation
    if player_bid == 0:
        if player_actual == 0:
            explanation_parts.append(f"Tom: NIL SUCCESS! 0 bid, 0 tricks (+200 pts)")  # Changed from +100
        else:
            explanation_parts.append(f"Tom: NIL FAILED! 0 bid, {player_actual} tricks (-200 pts, +{player_bags_added} bags)")  # Changed from -100
    elif is_player_blind:
        if player_actual >= player_bid:
            explanation_parts.append(f"Tom: BLIND {player_bid} SUCCESS! {player_actual} tricks (DOUBLE POINTS: +{player_hand_points} pts)")
        else:
            explanation_parts.append(f"Tom: BLIND {player_bid} FAILED! {player_actual} tricks (DOUBLE PENALTY: {player_hand_points} pts)")
        if player_bags_added > 0:
            explanation_parts[-1] += f", +{player_bags_added} bags"
    elif player_bags_added > 0:
        explanation_parts.append(f"Tom: {player_bid} bid, {player_actual} tricks (+{player_bags_added} bags)")
    else:
        explanation_parts.append(f"Tom: {player_bid} bid, {player_actual} tricks")
    
    # Computer explanation with blind support
    if computer_bid == 0:
        if computer_actual == 0:
            explanation_parts.append(f"Marta: NIL SUCCESS! 0 bid, 0 tricks (+200 pts)")  # Changed from +100
        else:
            explanation_parts.append(f"Marta: NIL FAILED! 0 bid, {computer_actual} tricks (-200 pts, +{computer_bags_added} bags)")  # Changed from -100
    elif is_computer_blind:
        if computer_actual >= computer_bid:
            explanation_parts.append(f"Marta: BLIND {computer_bid} SUCCESS! {computer_actual} tricks (DOUBLE POINTS: +{computer_hand_points} pts)")
        else:
            explanation_parts.append(f"Marta: BLIND {computer_bid} FAILED! {computer_actual} tricks (DOUBLE PENALTY: {computer_hand_points} pts)")
        if computer_bags_added > 0:
            explanation_parts[-1] += f", +{computer_bags_added} bags"
    elif computer_bags_added > 0:
        explanation_parts.append(f"Marta: {computer_bid} bid, {computer_actual} tricks (+{computer_bags_added} bags)")
    else:
        explanation_parts.append(f"Marta: {computer_bid} bid, {computer_actual} tricks")
    
    # Show special card effects from tricks
    if player_trick_special_cards > 0:
        explanation_parts.append(f"Tom won special cards: -{player_trick_special_cards} bags")
    if computer_trick_special_cards > 0:
        explanation_parts.append(f"Marta won special cards: -{computer_trick_special_cards} bags")
    
    # Show penalties and bonuses
    if player_penalty:
        penalty_count = (current_player_bags + player_bags_added) // 7
        explanation_parts.append(f"Tom: BAG PENALTY! -{penalty_count * 100} pts")
    
    if player_bonus:
        bonus_count = abs((current_player_bags + player_bags_added) // -5)
        explanation_parts.append(f"Tom: NEGATIVE BAG BONUS! +{bonus_count * 100} pts")
        
    if computer_penalty:
        penalty_count = (current_computer_bags + computer_bags_added) // 7
        explanation_parts.append(f"Marta: BAG PENALTY! -{penalty_count * 100} pts")
    
    if computer_bonus:
        bonus_count = abs((current_computer_bags + computer_bags_added) // -5)
        explanation_parts.append(f"Marta: NEGATIVE BAG BONUS! +{bonus_count * 100} pts")
    
    # Show current bag counts
    if final_player_bags != 0 or final_computer_bags != 0:
        explanation_parts.append(f"Bags: Tom {final_player_bags}/7, Marta {final_computer_bags}/7")
    
    return {
        'player_hand_points': player_hand_points,
        'computer_hand_points': computer_hand_points,
        'player_bags_added': player_bags_added,
        'computer_bags_added': computer_bags_added,
        'player_penalty': player_penalty,
        'computer_penalty': computer_penalty,
        'player_bonus': player_bonus,
        'computer_bonus': computer_bonus,
        'explanation': " | ".join(explanation_parts)
    }

def get_player_names_with_parity(player_parity, computer_parity):
    """
    Get display names that include the parity assignment.
    """
    player_name = f"Tom ({player_parity.title()})"
    computer_name = f"Marta ({computer_parity.title()})"
    
    return (player_name, computer_name)

================================================================================

FILE: ./utilities/computer_logic.py
--------------------------------------------------------------------------------
"""
Computer AI logic for Two-Man Spades
Handles all computer decision making including bidding, discarding, and play strategy
"""
import random
from .custom_rules import (
    get_discard_value, 
    is_special_card, 
    check_blind_bidding_eligibility,
    apply_blind_scoring
)

# =============================================================================
# GLOBAL AI DIFFICULTY SETTINGS
# =============================================================================

# Discard Strategy Settings
SINGLETON_SPECIAL_PRIORITY = 1000    # How much to prioritize discarding singleton 7â™¦/10â™£
VOID_CREATION_PRIORITY = 500         # How much to value creating voids
SPECIAL_CARD_PROTECTION = -100       # Penalty for discarding protected special cards
SPADE_DISCARD_PENALTY = 3           # Multiplier for avoiding spade discards
PARITY_CONSIDERATION = 1            # Small bonus for parity-favorable discards

# Bidding Strategy Settings  
BID_ACCURACY_BOOST = 0.8            # How much to boost base expectations (higher = more aggressive)
NIL_RISK_TOLERANCE = 0.8            # Threshold for nil bidding (lower = more nil attempts)
BLIND_DESPERATION_THRESHOLD = 120   # Points behind before considering blind bids
SCORE_BASED_ADJUSTMENT = 0.05       # How much score differential affects bidding
NIL_STRICTNESS = 0.8                # Lower = more likely to nil (minimum expectation for non-nil)

# Playing Strategy Settings
BAG_AVOIDANCE_STRENGTH = 0.92       # Multiplier when trying to avoid bags (lower = more avoidance)
SPECIAL_CARD_FOLLOWING_PROTECTION = True  # Whether to avoid playing special cards when following
LEAD_SAFETY_CONSIDERATION = True     # Whether to avoid leading into dangerous suits

# Meta-Strategy Settings
OPPONENT_MODELING = False            # Whether to try predicting opponent plays (future feature)
RISK_TAKING_PERSONALITY = 0.5       # 0.0 = very conservative, 1.0 = very aggressive
DEFAULT_BLIND_BID = 5

# =============================================================================
# HAND ANALYSIS FUNCTIONS
# =============================================================================

def analyze_hand_strength(hand):
    """
    Analyze hand strength and return expected trick count
    Returns tuple: (sure_tricks, probable_tricks, special_card_bonus)
    """
    sure_tricks = 0
    probable_tricks = 0
    special_card_bonus = 0
    
    # Count special cards for strategic value
    for card in hand:
        is_special, bag_reduction = is_special_card(card)
        if is_special:
            special_card_bonus += 0.2  # Special cards provide strategic value
    
    # Separate spades from other suits
    spades = [card for card in hand if card['suit'] == 'â™ ']
    other_suits = [card for card in hand if card['suit'] != 'â™ ']
    
    # Group other suits
    suits = {'â™¥': [], 'â™¦': [], 'â™£': []}
    for card in other_suits:
        suits[card['suit']].append(card)
    
    # ENHANCED SPADES ANALYSIS
    spade_values = sorted([card['value'] for card in spades], reverse=True)
    spade_count = len(spades)
    
    # Apply spade count expectations
    if spade_count >= 5:
        sure_tricks += 3.0  # Expect 5 tricks from 5+ spades
        probable_tricks += 2.0
    elif spade_count == 4:
        sure_tricks += 2.0  # Expect 3 tricks from 4 spades  
        probable_tricks += 1.0
    elif spade_count == 3:
        sure_tricks += 1.5  # Expect 2 tricks from 3 spades
        probable_tricks += 0.5
    elif spade_count == 2:
        sure_tricks += 0.8  # Modest expectation from 2 spades
        probable_tricks += 0.4
    elif spade_count == 1:
        sure_tricks += 0.3  # Low expectation from 1 spade
    
    # High spades get additional value on top of count-based expectations
    ace_spades = sum(1 for v in spade_values if v == 14)
    king_spades = sum(1 for v in spade_values if v == 13)
    queen_spades = sum(1 for v in spade_values if v == 12)
    
    if ace_spades > 0:
        sure_tricks += 0.3 * ace_spades  # Ace of spades is nearly guaranteed
    if king_spades > 0:
        sure_tricks += 0.2 * king_spades  # King of spades very likely
    if queen_spades > 0:
        probable_tricks += 0.2 * queen_spades  # Queen adds some value
    
    # ENHANCED OTHER SUITS ANALYSIS
    aces_other_suits = 0
    kings_other_suits = 0
    
    for suit, cards in suits.items():
        if not cards:
            continue
            
        values = sorted([card['value'] for card in cards], reverse=True)
        
        # Count high cards for overall hand strength
        aces_in_suit = sum(1 for v in values if v == 14)
        kings_in_suit = sum(1 for v in values if v == 13)
        
        aces_other_suits += aces_in_suit
        kings_other_suits += kings_in_suit
        
        # Aces in other suits (can be trumped but still strong)
        if 14 in values:
            sure_tricks += 0.8 * aces_in_suit  # High but not guaranteed
        
        # Protected kings (with ace)
        if 13 in values and 14 in values:
            sure_tricks += 0.6 * kings_in_suit  # Protected kings are strong
        elif 13 in values:
            if len(cards) >= 3:  # King in long suit has protection
                probable_tricks += 0.5 * kings_in_suit
            else:  # Unprotected king
                probable_tricks += 0.3 * kings_in_suit
        
        # Long suits can generate tricks through length
        if len(cards) >= 4:
            probable_tricks += (len(cards) - 3) * 0.25
    
    # MULTIPLE HIGH CARDS BONUS
    total_high_cards = aces_other_suits + kings_other_suits + ace_spades + king_spades
    
    if total_high_cards >= 4:
        sure_tricks += 0.5  # Multiple high cards create synergy
        probable_tricks += 0.3
    elif total_high_cards >= 3:
        sure_tricks += 0.3
        probable_tricks += 0.2
    elif total_high_cards >= 2:
        probable_tricks += 0.2
    
    # VOID SUITS (can trump)
    void_suits = sum(1 for cards in suits.values() if len(cards) == 0)
    if void_suits > 0 and spade_count >= 2:
        probable_tricks += void_suits * 0.4  # Void + spades = trumping opportunities
    
    return sure_tricks, probable_tricks, special_card_bonus

def analyze_suit_distribution(hand):
    """Analyze suit distribution and identify singleton/void opportunities"""
    suits = {'â™¥': [], 'â™¦': [], 'â™£': [], 'â™ ': []}
    
    for card in hand:
        suits[card['suit']].append(card)
    
    distribution = {}
    for suit, cards in suits.items():
        distribution[suit] = {
            'count': len(cards),
            'cards': cards,
            'is_void': len(cards) == 0,
            'is_singleton': len(cards) == 1
        }
    
    return distribution

# =============================================================================
# DISCARD STRATEGY
# =============================================================================

def computer_discard_strategy(computer_hand, game_state):
    """
    Enhanced discard strategy prioritizing singleton special cards and void creation
    Returns index of card to discard
    """
    player_parity = game_state.get('player_parity', 'even')
    computer_parity = game_state.get('computer_parity', 'odd')
    
    # Analyze suit distribution
    suit_distribution = analyze_suit_distribution(computer_hand)
    
    discard_candidates = []
    
    for i, card in enumerate(computer_hand):
        score = 0
        suit_info = suit_distribution[card['suit']]
        
        # PRIORITY 1: Singleton special cards - MUST discard these
        if suit_info['is_singleton'] and card['suit'] != 'â™ ':
            is_special, _ = is_special_card(card)
            if is_special:
                score += SINGLETON_SPECIAL_PRIORITY
                discard_candidates.append((i, score))
                continue  # Don't apply other penalties to singleton specials
        
        # PRIORITY 2: Void creation (singleton non-specials in non-spade suits)
        elif suit_info['is_singleton'] and card['suit'] != 'â™ ':
            spade_count = suit_distribution['â™ ']['count']
            # More spades = void is more valuable
            void_value = (spade_count * VOID_CREATION_PRIORITY) // 10
            if spade_count >= 4:  # Strong spade holding
                void_value += (VOID_CREATION_PRIORITY // 4)
            void_value -= card['value']  # Prefer discarding low cards
            score += void_value
        
        # PRIORITY 3: Normal special card protection (protected specials)
        else:
            is_special, _ = is_special_card(card)
            if is_special:
                score += SPECIAL_CARD_PROTECTION  # Negative score
        
        # PRIORITY 4: Avoid discarding spades
        if card['suit'] == 'â™ ':
            score -= card['value'] * SPADE_DISCARD_PENALTY
        else:
            # Prefer discarding low cards from other suits
            score += (15 - card['value'])
        
        # PRIORITY 5: Light parity consideration
        discard_value = get_discard_value(card)
        if computer_parity == 'even' and discard_value % 2 == 1:
            score += PARITY_CONSIDERATION
        elif computer_parity == 'odd' and discard_value % 2 == 0:
            score += PARITY_CONSIDERATION
        
        discard_candidates.append((i, score))
    
    # Return index of card with highest discard score
    return max(discard_candidates, key=lambda x: x[1])[0]

# =============================================================================
# BIDDING STRATEGY
# =============================================================================

def should_bid_nil(hand, game_state):
    """
    Determine if computer should bid nil (using configurable strictness)
    """
    player_score = game_state.get('player_score', 0)
    computer_score = game_state.get('computer_score', 0)
    player_bid = game_state.get('player_bid', 0)
    
    # Get hand strength
    sure_tricks, probable_tricks, special_bonus = analyze_hand_strength(hand)
    total_expectation = sure_tricks + probable_tricks + special_bonus
    
    # Use configurable nil threshold
    if total_expectation > NIL_STRICTNESS:
        return False
    
    # Must have very few spades and they must be low
    spades = [card for card in hand if card['suit'] == 'â™ ']
    if len(spades) > 3:  # At most 3 spades
        return False
    
    # No high spades allowed
    for spade in spades:
        if spade['value'] >= 11:  # No J, Q, K, A of spades
            return False
    
    # Must have at least 2 twos for safety
    twos = [card for card in hand if card['rank'] == '2']
    if len(twos) < 2:
        return False
    
    # Must have mostly very low cards (2-7) in other suits
    other_suits = [card for card in hand if card['suit'] != 'â™ ']
    low_cards = [card for card in other_suits if card['value'] <= 7]
    
    if len(low_cards) < len(other_suits) - 1:
        return False
    
    # No aces or kings in other suits
    high_other_suits = [card for card in other_suits if card['value'] >= 13]
    if len(high_other_suits) > 0:
        return False
    
    # Don't nil if player already bid nil
    if player_bid == 0:
        return False
    
    # Only nil when significantly behind
    if computer_score >= player_score - 50:
        return False
    
    # Conservative probability - only when truly desperate
    return computer_score < player_score - 80

def should_bid_blind(hand, game_state):
    """
    Determine if computer should bid blind when eligible
    Returns tuple: (should_blind, blind_bid_amount)
    """
    player_score = game_state.get('player_score', 0)
    computer_score = game_state.get('computer_score', 0)
    
    # Check eligibility
    blind_eligibility = check_blind_bidding_eligibility(player_score, computer_score)
    if not blind_eligibility['computer_eligible']:
        return False, 0
    
    # If down by 100+, just go blind 5 (simplest aggressive strategy)
    return True, DEFAULT_BLIND_BID

def computer_bidding_brain(computer_hand, player_bid, game_state):
    """
    Main computer bidding function with configurable AI settings
    Returns tuple: (bid_amount, is_blind)
    """
    player_score = game_state.get('player_score', 0)
    computer_score = game_state.get('computer_score', 0)
    computer_bags = game_state.get('computer_bags', 0)
    
    # Check for nil opportunity first
    if should_bid_nil(computer_hand, game_state):
        return 0, False
    
    # Check for blind bidding opportunity
    should_blind, blind_amount = should_bid_blind(computer_hand, game_state)
    if should_blind:
        return blind_amount, True
    
    # Regular bidding logic
    sure_tricks, probable_tricks, special_bonus = analyze_hand_strength(computer_hand)
    base_expectation = sure_tricks + probable_tricks + special_bonus
    
    # Apply configurable accuracy boost
    base_expectation += BID_ACCURACY_BOOST
    
    # Score-based adjustments (using configurable multiplier)
    score_diff = computer_score - player_score
    if score_diff > 30:  # Ahead - be slightly conservative
        base_expectation *= (1 - SCORE_BASED_ADJUSTMENT)
    elif score_diff < -30:  # Behind - be slightly aggressive
        base_expectation *= (1 + SCORE_BASED_ADJUSTMENT)
    
    # Bag avoidance when close to penalty
    if computer_bags >= 5:
        base_expectation *= BAG_AVOIDANCE_STRENGTH
    
    # Strategic response to player's bid
    if player_bid is not None:
        if player_bid == 0:  # Player nil - be aggressive to set them
            base_expectation += 0.3
        elif player_bid <= 2:  # Player bid low
            base_expectation += 0.15
        elif player_bid >= 7:  # Player bid high
            base_expectation -= 0.2
    
    # Convert to bid
    raw_bid = max(0, min(10, round(base_expectation)))
    
    # Bid range preferences
    if 2.5 <= base_expectation <= 5.5:
        if raw_bid < 3:
            raw_bid = 3  # Minimum reasonable bid is 3
        elif raw_bid == 5 and random.random() < 0.4:
            raw_bid = 4  # Sometimes prefer 4 over 5
    
    # Avoid obvious total-10 scenarios
    if player_bid is not None and abs((raw_bid + player_bid) - 10) <= 1 and random.random() < 0.3:
        if raw_bid > 3:
            raw_bid -= 1
        elif raw_bid < 7:
            raw_bid += 1
    
    # Final bounds check
    raw_bid = max(1, min(10, raw_bid))
    
    return raw_bid, False

# =============================================================================
# PLAYING STRATEGY
# =============================================================================

def computer_lead_strategy(computer_hand, spades_broken):
    """
    Enhanced leading strategy - avoid leading into special cards when possible
    Returns index of best card to lead, or None if no valid leads
    """
    if not computer_hand:
        return None
    
    # Find all valid leads
    valid_leads = []
    for i, card in enumerate(computer_hand):
        if card['suit'] != 'â™ ' or spades_broken or all(c['suit'] == 'â™ ' for c in computer_hand):
            valid_leads.append((i, card))
    
    if not valid_leads:
        return None
    
    # Categorize leads by danger level (if safety consideration is enabled)
    if LEAD_SAFETY_CONSIDERATION:
        safe_leads = []
        risky_leads = []
        dangerous_leads = []
        
        for i, card in valid_leads:
            suit = card['suit']
            rank = card['rank']
            
            # Check if leading this suit could give opponent special cards
            if suit == 'â™£':
                # Leading clubs could set up 10â™£ for opponent
                if rank in ['J', 'Q', 'K', 'A']:
                    dangerous_leads.append((i, card))
                elif rank in ['8', '9', '10']:
                    risky_leads.append((i, card))
                else:
                    safe_leads.append((i, card))
            elif suit == 'â™¦':
                # Leading diamonds could set up 7â™¦ for opponent  
                if rank in ['J', 'Q', 'K', 'A']:
                    dangerous_leads.append((i, card))
                elif rank in ['6', '7', '8']:
                    risky_leads.append((i, card))
                else:
                    safe_leads.append((i, card))
            else:
                # Hearts and spades are generally safer
                safe_leads.append((i, card))
        
        # Choose lead in order of preference: safe > risky > dangerous
        if safe_leads:
            chosen = min(safe_leads, key=lambda x: x[1]['value'])
        elif risky_leads:
            chosen = min(risky_leads, key=lambda x: x[1]['value'])
        else:
            chosen = min(dangerous_leads, key=lambda x: x[1]['value'])
    else:
        # Simple strategy - just lead lowest valid card
        chosen = min(valid_leads, key=lambda x: x[1]['value'])
    
    return chosen[0]

def computer_follow_strategy(computer_hand, current_trick, game_state):
    """
    Enhanced strategy for when computer must follow suit - includes bag avoidance and special card protection
    Returns index of best card to play
    """
    if not current_trick or not computer_hand:
        return None
    
    computer_bid = game_state.get('computer_bid', 0)
    computer_tricks = game_state.get('computer_tricks', 0)
    
    # Check if computer has already made their bid
    bid_already_made = computer_tricks >= computer_bid and computer_bid > 0
    
    lead_card = current_trick[0]['card']
    lead_suit = lead_card['suit']
    lead_value = lead_card['value']
    
    # Find valid plays and categorize by special card status
    same_suit = []
    same_suit_special = []
    spades = []
    spades_special = []
    other = []
    other_special = []
    
    for i, card in enumerate(computer_hand):
        is_special, _ = is_special_card(card)
        
        if card['suit'] == lead_suit:
            if is_special:
                same_suit_special.append((i, card))
            else:
                same_suit.append((i, card))
        elif card['suit'] == 'â™ ':
            if is_special:
                spades_special.append((i, card))
            else:
                spades.append((i, card))
        else:
            if is_special:
                other_special.append((i, card))
            else:
                other.append((i, card))
    
    # Combine same suit cards (prioritize non-special if protection is enabled)
    if SPECIAL_CARD_FOLLOWING_PROTECTION:
        all_same_suit = same_suit + same_suit_special
        all_spades = spades + spades_special
        all_other = other + other_special
    else:
        all_same_suit = same_suit_special + same_suit
        all_spades = spades_special + spades
        all_other = other_special + other
    
    if all_same_suit:
        # Must follow suit
        winners = [(i, c) for i, c in all_same_suit if c['value'] > lead_value]
        losers = [(i, c) for i, c in all_same_suit if c['value'] <= lead_value]
        
        if SPECIAL_CARD_FOLLOWING_PROTECTION:
            # Separate special cards from regular cards in each category
            winners_regular = [(i, c) for i, c in winners if not is_special_card(c)[0]]
            winners_special = [(i, c) for i, c in winners if is_special_card(c)[0]]
            losers_regular = [(i, c) for i, c in losers if not is_special_card(c)[0]]
            losers_special = [(i, c) for i, c in losers if is_special_card(c)[0]]
            
            if bid_already_made:
                # Try to avoid winning (avoid bags), protect special cards
                if losers_regular:
                    return max(losers_regular, key=lambda x: x[1]['value'])[0]
                elif losers_special:
                    return max(losers_special, key=lambda x: x[1]['value'])[0]
                elif winners_regular:
                    return min(winners_regular, key=lambda x: x[1]['value'])[0]
                else:
                    return min(winners_special, key=lambda x: x[1]['value'])[0]
            else:
                # Still need tricks - try to win, avoid wasting special cards
                if winners_regular:
                    return min(winners_regular, key=lambda x: x[1]['value'])[0]
                elif winners_special:
                    return min(winners_special, key=lambda x: x[1]['value'])[0]
                elif losers_regular:
                    return min(losers_regular, key=lambda x: x[1]['value'])[0]
                else:
                    return min(losers_special, key=lambda x: x[1]['value'])[0]
        else:
            # Simple strategy without special card protection
            if bid_already_made:
                if losers:
                    return max(losers, key=lambda x: x[1]['value'])[0]
                else:
                    return min(winners, key=lambda x: x[1]['value'])[0]
            else:
                if winners:
                    return min(winners, key=lambda x: x[1]['value'])[0]
                else:
                    return min(losers, key=lambda x: x[1]['value'])[0]
                
    elif lead_suit != 'â™ ' and all_spades:
        # Can trump with spade
        if bid_already_made:
            # Try to avoid trumping unless forced
            if all_other:
                if SPECIAL_CARD_FOLLOWING_PROTECTION:
                    non_special_other = [x for x in all_other if not is_special_card(x[1])[0]]
                    if non_special_other:
                        return min(non_special_other, key=lambda x: x[1]['value'])[0]
                    else:
                        return min(all_other, key=lambda x: x[1]['value'])[0]
                else:
                    return min(all_other, key=lambda x: x[1]['value'])[0]
            else:
                # Must trump
                if SPECIAL_CARD_FOLLOWING_PROTECTION:
                    non_special_spades = [x for x in all_spades if not is_special_card(x[1])[0]]
                    if non_special_spades:
                        return min(non_special_spades, key=lambda x: x[1]['value'])[0]
                    else:
                        return min(all_spades, key=lambda x: x[1]['value'])[0]
                else:
                    return min(all_spades, key=lambda x: x[1]['value'])[0]
        else:
            # Still need tricks - trump but protect special cards if possible
            if SPECIAL_CARD_FOLLOWING_PROTECTION:
                non_special_spades = [x for x in all_spades if not is_special_card(x[1])[0]]
                if non_special_spades:
                    return min(non_special_spades, key=lambda x: x[1]['value'])[0]
                else:
                    return min(all_spades, key=lambda x: x[1]['value'])[0]
            else:
                return min(all_spades, key=lambda x: x[1]['value'])[0]
    else:
        # Can't follow or trump - discard lowest
        if SPECIAL_CARD_FOLLOWING_PROTECTION:
            non_special_other = [x for x in all_other if not is_special_card(x[1])[0]]
            if non_special_other:
                return min(non_special_other, key=lambda x: x[1]['value'])[0]
            else:
                all_cards = [(i, c) for i, c in enumerate(computer_hand)]
                return min(all_cards, key=lambda x: x[1]['value'])[0]
        else:
            all_cards = [(i, c) for i, c in enumerate(computer_hand)]
            return min(all_cards, key=lambda x: x[1]['value'])[0]

# =============================================================================
# DIFFICULTY ADJUSTMENT FUNCTIONS (Future Enhancement)
# =============================================================================

def set_difficulty_easy():
    """Set all AI parameters for easy difficulty"""
    global SINGLETON_SPECIAL_PRIORITY, VOID_CREATION_PRIORITY, BID_ACCURACY_BOOST
    global NIL_RISK_TOLERANCE, SPECIAL_CARD_FOLLOWING_PROTECTION
    
    # Make poor decisions
    SINGLETON_SPECIAL_PRIORITY = 50  # Sometimes keeps singleton specials
    VOID_CREATION_PRIORITY = 100     # Doesn't prioritize voids much
    BID_ACCURACY_BOOST = 0.2         # Under-bids frequently
    NIL_RISK_TOLERANCE = 1.5         # Rarely goes nil
    SPECIAL_CARD_FOLLOWING_PROTECTION = False  # Doesn't protect specials

def set_difficulty_hard():
    """Set all AI parameters for hard difficulty"""
    global SINGLETON_SPECIAL_PRIORITY, VOID_CREATION_PRIORITY, BID_ACCURACY_BOOST
    global NIL_RISK_TOLERANCE, SPECIAL_CARD_FOLLOWING_PROTECTION
    
    # Optimal play
    SINGLETON_SPECIAL_PRIORITY = 1000
    VOID_CREATION_PRIORITY = 500
    BID_ACCURACY_BOOST = 0.8
    NIL_RISK_TOLERANCE = 0.8
    SPECIAL_CARD_FOLLOWING_PROTECTION = True

def set_difficulty_custom(settings_dict):
    """Set AI parameters from a dictionary"""
    globals().update(settings_dict)

================================================================================

FILE: ./utilities/logging_utils.py
--------------------------------------------------------------------------------
"""
Streamlined logging utilities for Two-Man Spades - WRITE-ONLY approach
Logs everything for historical analysis but NEVER reads/loads existing files during normal operation
All logging is append-only for performance - reading is only available via explicit debug endpoints
"""
import time
import uuid
import json
import os
import platform
from datetime import datetime

# =============================================================================
# GLOBAL LOGGING CONFIGURATION
# =============================================================================

# Environment detection
IS_LOCAL_DEVELOPMENT = os.environ.get('GAE_ENV') != 'standard'
IS_PRODUCTION = not IS_LOCAL_DEVELOPMENT

LOGGING_ENABLED = True
LOG_TO_CONSOLE = True
LOG_TO_FILE = IS_LOCAL_DEVELOPMENT
LOG_GAME_ACTIONS = True
LOG_AI_DECISIONS = True
LOG_AI_ANALYSIS = True
LOG_GAME_EVENTS = True
CONSOLE_LOG_LEVEL = 'ALL'  # 'ALL', 'ACTIONS_ONLY', 'AI_ONLY', 'EVENTS_ONLY', 'OFF'
LOGS_DIRECTORY = 'logging' if IS_LOCAL_DEVELOPMENT else None
CURRENT_LOG_FILE = None

# Production logging placeholder
PRODUCTION_LOG_PLACEHOLDER = "[PRODUCTION] Log entry saved to pending database implementation"

# =============================================================================
# CLIENT IP TRACKING FUNCTIONS
# =============================================================================

def get_client_ip(request):
    """Get the client's IP address, handling proxies and load balancers."""
    forwarded_ips = [
        'X-Forwarded-For',
        'X-Real-IP',
        'X-Appengine-Remote-Addr',
        'CF-Connecting-IP',
        'X-Client-IP',
    ]
    
    for header in forwarded_ips:
        ip = request.headers.get(header)
        if ip:
            ip = ip.split(',')[0].strip()
            if ip and ip != 'unknown':
                return ip
    
    return request.environ.get('REMOTE_ADDR', 'unknown')

def get_client_info(request):
    """Get comprehensive client information for logging."""
    client_ip = get_client_ip(request)
    
    return {
        'ip_address': client_ip,
        'user_agent': request.headers.get('User-Agent', 'unknown'),
        'referer': request.headers.get('Referer', 'none'),
        'method': request.method,
        'endpoint': request.endpoint,
        'is_local': client_ip.startswith('127.') or client_ip.startswith('192.168.') or client_ip == 'localhost'
    }

def track_session_client(session, request):
    """Track client info in session for persistent identification."""
    client_info = get_client_info(request)
    
    session_client = {
        'ip_address': client_info['ip_address'],
        'first_seen': session.get('client_first_seen', time.time()),
        'last_seen': time.time(),
        'session_actions': session.get('client_actions', 0) + 1
    }
    
    session['client_info'] = session_client
    session['client_actions'] = session_client['session_actions'] 
    session['client_first_seen'] = session_client['first_seen']
    session.modified = True
    
    return session_client

def get_session_client_summary(session):
    """Get summary of client activity for this session."""
    client_info = session.get('client_info', {})
    
    if client_info:
        session_duration = time.time() - session.get('client_first_seen', time.time())
        return {
            'ip_address': client_info.get('ip_address', 'unknown'),
            'actions_this_session': session.get('client_actions', 0),
            'session_duration_minutes': round(session_duration / 60, 1),
            'first_seen': datetime.fromtimestamp(session.get('client_first_seen', 0)).strftime('%H:%M:%S')
        }
    
    return None

# =============================================================================
# FILE MANAGEMENT FUNCTIONS - WRITE ONLY
# =============================================================================

def _ensure_logs_directory():
    """Ensure the logging directory exists - only in local development, no scanning"""
    if not IS_LOCAL_DEVELOPMENT:
        return
        
    if LOGS_DIRECTORY and not os.path.exists(LOGS_DIRECTORY):
        os.makedirs(LOGS_DIRECTORY)

def _generate_log_filename(game_id, timestamp=None):
    """Generate a unique log filename for a game - only used in local development"""
    if not IS_LOCAL_DEVELOPMENT:
        return None
        
    if timestamp is None:
        timestamp = datetime.now()
    
    date_str = timestamp.strftime("%Y%m%d")
    time_str = timestamp.strftime("%H%M%S")
    short_game_id = game_id[:8] if game_id else "unknown"
    
    return f"game_log_{date_str}_{time_str}_{short_game_id}.json"

def _start_new_log_file(game_id):
    """Start a new log file for a game - WRITE ONLY, no existing file checking"""
    global CURRENT_LOG_FILE
    
    if not IS_LOCAL_DEVELOPMENT:
        return
    
    if not LOG_TO_FILE:
        return
    
    _ensure_logs_directory()  # Only creates if missing, no scanning
    
    filename = _generate_log_filename(game_id)
    CURRENT_LOG_FILE = os.path.join(LOGS_DIRECTORY, filename)
    
    # Initialize with game metadata
    initial_entry = {
        'log_type': 'game_metadata',
        'data': {
            'game_id': game_id,
            'log_file_created': datetime.now().isoformat(),
            'log_version': '2.0',
            'game_type': 'two_man_spades',
            'environment': 'local_development'
        }
    }
    
    try:
        # Write initial entry - no reading of existing files
        with open(CURRENT_LOG_FILE, 'w') as f:
            json.dump([initial_entry], f, indent=2, default=str)
        
        if LOG_TO_CONSOLE:
            print(f"Started new game log: {filename}")
        
    except Exception as e:
        if LOG_TO_CONSOLE:
            print(f"Warning: Could not create new log file: {e}")
        CURRENT_LOG_FILE = None

def _write_to_current_log_file(log_entry):
    """Write log entry to current game's log file - APPEND ONLY"""
    if not IS_LOCAL_DEVELOPMENT or not LOG_TO_FILE or not CURRENT_LOG_FILE:
        return
    
    try:
        # APPEND-ONLY approach - read existing, append new, write back
        logs = []
        if os.path.exists(CURRENT_LOG_FILE):
            try:
                with open(CURRENT_LOG_FILE, 'r') as f:
                    logs = json.load(f)
            except (json.JSONDecodeError, IOError):
                logs = []  # Start fresh if file is corrupted
        
        logs.append(log_entry)
        
        with open(CURRENT_LOG_FILE, 'w') as f:
            json.dump(logs, f, indent=2, default=str)
            
    except Exception as e:
        if LOG_TO_CONSOLE:
            print(f"Warning: Could not write to log file: {e}")

def _finalize_current_log_file(final_game_state):
    """Add final game metadata and close current log file"""
    if not IS_LOCAL_DEVELOPMENT or not CURRENT_LOG_FILE:
        return
        
    finalization_entry = {
        'log_type': 'game_finalization',
        'data': {
            'game_completed_at': datetime.now().isoformat(),
            'final_scores': {
                'player_score': final_game_state.get('player_score', 0),
                'computer_score': final_game_state.get('computer_score', 0)
            },
            'winner': final_game_state.get('winner'),
            'hands_played': final_game_state.get('hand_number', 1),
            'environment': 'local_development'
        }
    }
    
    _write_to_current_log_file(finalization_entry)
    
    if LOG_TO_CONSOLE:
        print(f"Finalized game log: {os.path.basename(CURRENT_LOG_FILE)}")

# =============================================================================
# GAME INITIALIZATION - STREAMLINED
# =============================================================================

def initialize_game_logging(game):
    """Initialize logging structures and start new log file for a new game - NO FILE SCANNING"""
    game_id = str(uuid.uuid4())
    hand_id = str(uuid.uuid4())
    
    game.update({
        'game_id': game_id,
        'current_hand_id': hand_id,
        'game_started_at': time.time(),
        'action_sequence': 0
    })
    
    # Start new log file - NO scanning of existing files
    _start_new_log_file(game_id)
    
    # Log game initialization
    _write_to_current_log_file({
        'log_type': 'game_init',
        'data': {
            'game_id': game_id,
            'started_at': time.time(),
            'player_parity': game.get('player_parity'),
            'computer_parity': game.get('computer_parity'),
            'first_leader': game.get('first_leader')
        }
    })
    
    return game

def initialize_game_logging_with_client(game, request=None):
    """Enhanced game initialization with client tracking - NO FILE SCANNING"""
    game = initialize_game_logging(game)
    
    if request:
        client_info = get_client_info(request)
        game['client_info'] = client_info
        
        # Console output only
        if LOG_TO_CONSOLE:
            print(f"NEW GAME STARTED by {client_info['ip_address']}")
            print(f"   Game ID: {game.get('game_id', 'unknown')[:8]}...")
    
    return game

def finalize_game_logging(game):
    """Called when a game ends to finalize the log file"""
    _finalize_current_log_file(game)

def start_new_hand_logging(game):
    """Generate new hand ID and log hand start"""
    hand_id = str(uuid.uuid4())
    game['current_hand_id'] = hand_id

# =============================================================================
# CORE LOGGING FUNCTIONS - WRITE ONLY
# =============================================================================

def log_action(action_type, player, action_data, session=None, additional_context=None, request=None):
    """Central logging function for all player/system game actions with optional client tracking"""
    if not LOGGING_ENABLED or not LOG_GAME_ACTIONS:
        return
    
    client_info = get_client_info(request) if request else None
    action_record = _build_action_record(action_type, player, action_data, session, additional_context)
    
    if client_info:
        action_record['client_info'] = client_info
    
    _write_to_current_log_file({
        'log_type': 'action',
        'data': action_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'ACTIONS_ONLY']:
        _print_action_log(action_record)

def log_ai_decision(decision_type, decision_data, analysis=None, reasoning=None, session=None):
    """Central logging function for AI decision-making process"""
    if not LOGGING_ENABLED or not LOG_AI_DECISIONS:
        return
    
    decision_record = _build_ai_decision_record(decision_type, decision_data, analysis, reasoning)
    
    _write_to_current_log_file({
        'log_type': 'ai_decision',
        'data': decision_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'AI_ONLY']:
        _print_ai_decision_log(decision_record)

def log_game_event(event_type, event_data, session=None):
    """Central logging function for major game events"""
    if not LOGGING_ENABLED or not LOG_GAME_EVENTS:
        return
    
    event_record = _build_event_record(event_type, event_data, session)
    
    _write_to_current_log_file({
        'log_type': 'game_event',
        'data': event_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'EVENTS_ONLY']:
        _print_event_log(event_record)

def log_ai_analysis(analysis_type, analysis_data, session=None):
    """Log detailed AI analysis with structured data"""
    if not LOGGING_ENABLED or not LOG_AI_ANALYSIS:
        return
    
    analysis_record = {
        'timestamp': time.time(),
        'analysis_type': analysis_type,
        'analysis_data': analysis_data
    }
    
    _write_to_current_log_file({
        'log_type': 'ai_analysis',
        'data': analysis_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'AI_ONLY']:
        _print_ai_analysis_log(analysis_record)

def log_ai_strategy(strategy_type, strategy_data, session=None):
    """Log AI strategy decisions and evaluations"""
    if not LOGGING_ENABLED or not LOG_AI_ANALYSIS:
        return
    
    strategy_record = {
        'timestamp': time.time(),
        'strategy_type': strategy_type,
        'strategy_data': strategy_data
    }
    
    _write_to_current_log_file({
        'log_type': 'ai_strategy',
        'data': strategy_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'AI_ONLY']:
        _print_ai_strategy_log(strategy_record)

def log_ai_evaluation(evaluation_type, candidates, chosen_candidate, session=None):
    """Log AI evaluation of multiple options"""
    if not LOGGING_ENABLED or not LOG_AI_ANALYSIS:
        return
    
    evaluation_record = {
        'timestamp': time.time(),
        'evaluation_type': evaluation_type,
        'candidates_evaluated': len(candidates),
        'all_candidates': candidates,
        'chosen_candidate': chosen_candidate,
        'confidence': _calculate_evaluation_confidence(candidates, chosen_candidate)
    }
    
    _write_to_current_log_file({
        'log_type': 'ai_evaluation',
        'data': evaluation_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'AI_ONLY']:
        _print_ai_evaluation_log(evaluation_record)

# =============================================================================
# INTERNAL HELPER FUNCTIONS
# =============================================================================

def _build_action_record(action_type, player, action_data, session, additional_context):
    """Build standardized action record"""
    game = session['game'] if session and 'game' in session else {}
    
    game['action_sequence'] = game.get('action_sequence', 0) + 1
    
    return {
        'sequence': game['action_sequence'],
        'timestamp': time.time(),
        'game_id': game.get('game_id'),
        'hand_id': game.get('current_hand_id'),
        'action_type': action_type,
        'player': player,
        'hand_number': game.get('hand_number', 1),
        'phase': game.get('phase', 'unknown'),
        'action_data': action_data,
        'game_context': {
            'player_score': game.get('player_score', 0),
            'computer_score': game.get('computer_score', 0),
            'player_tricks': game.get('player_tricks', 0),
            'computer_tricks': game.get('computer_tricks', 0),
            'player_bags': game.get('player_bags', 0),
            'computer_bags': game.get('computer_bags', 0),
            'spades_broken': game.get('spades_broken', False),
            'turn': game.get('turn'),
            'trick_leader': game.get('trick_leader')
        },
        'additional_context': additional_context
    }

def _build_ai_decision_record(decision_type, decision_data, analysis, reasoning):
    """Build standardized AI decision record"""
    return {
        'timestamp': time.time(),
        'decision_type': decision_type,
        'decision_data': decision_data,
        'analysis': analysis,
        'reasoning': reasoning,
        'confidence': _calculate_confidence(decision_type, decision_data, analysis)
    }

def _build_event_record(event_type, event_data, session):
    """Build standardized event record"""
    game = session['game'] if session and 'game' in session else {}
    
    return {
        'timestamp': time.time(),
        'game_id': game.get('game_id'),
        'hand_id': game.get('current_hand_id'),
        'event_type': event_type,
        'hand_number': game.get('hand_number', 1),
        'event_data': event_data
    }

def _calculate_confidence(decision_type, decision_data, analysis):
    """Calculate confidence score for AI decisions"""
    if not analysis:
        return 0.5
    
    if decision_type == 'bid':
        expected_tricks = analysis.get('base_expectation', 0)
        bid_amount = decision_data.get('bid_amount', 0)
        diff = abs(expected_tricks - bid_amount)
        return max(0.0, min(1.0, 1.0 - (diff / 5.0)))
    
    elif decision_type == 'discard_choice':
        chosen_score = decision_data.get('final_score', 0)
        if chosen_score >= 1000:
            return 1.0
        elif chosen_score >= 500:
            return 0.9
        else:
            return 0.6
    
    return 0.5

def _calculate_evaluation_confidence(candidates, chosen_candidate):
    """Calculate confidence for AI evaluations"""
    if not candidates or len(candidates) < 2:
        return 1.0
    
    if isinstance(chosen_candidate, dict) and 'score' in chosen_candidate:
        try:
            scores = [c.get('score', 0) for c in candidates if isinstance(c, dict)]
            if scores and len(scores) >= 2:
                best_score = max(scores)
                second_best = sorted(scores, reverse=True)[1]
                if best_score > 0:
                    confidence = min(1.0, (best_score - second_best) / best_score)
                    return max(0.1, confidence)
        except:
            pass
    
    return max(0.3, 1.0 - (len(candidates) * 0.1))

# =============================================================================
# CONSOLE OUTPUT FUNCTIONS
# =============================================================================

def _print_action_log(action_record):
    """Print action log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(action_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"=== ACTION #{action_record['sequence']}: {action_record['action_type'].upper()} by {action_record['player'].upper()} ===")
    print(f"Hand #{action_record['hand_number']} | Phase: {action_record['phase']} | Time: {timestamp_str}")
    print(f"Data: {action_record['action_data']}")
    
    ctx = action_record['game_context']
    print(f"Context: Score {ctx['player_score']}-{ctx['computer_score']} | Tricks {ctx['player_tricks']}-{ctx['computer_tricks']} | Bags {ctx['player_bags']}-{ctx['computer_bags']}")
    
    if action_record.get('additional_context'):
        print(f"Extra: {action_record['additional_context']}")
    
    print("=" * 60)

def _print_ai_decision_log(decision_record):
    """Print AI decision log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(decision_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"AI DECISION: {decision_record['decision_type'].upper()}")
    print(f"Time: {timestamp_str} | Confidence: {decision_record['confidence']:.2f}")
    print(f"Decision: {decision_record['decision_data']}")
    
    if decision_record.get('analysis'):
        print(f"Analysis: {decision_record['analysis']}")
    
    if decision_record.get('reasoning'):
        print(f"Reasoning: {decision_record['reasoning']}")
    
    print("=" * 58)

def _print_event_log(event_record):
    """Print game event log to console with formatting"""
    print(f"GAME EVENT: {event_record['event_type'].upper()}")
    print(f"Hand #{event_record['hand_number']} | Data: {event_record['event_data']}")
    print("*" * 40)

def _print_ai_analysis_log(analysis_record):
    """Print AI analysis log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(analysis_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"AI ANALYSIS: {analysis_record['analysis_type'].upper()}")
    print(f"Time: {timestamp_str}")
    
    for key, value in analysis_record['analysis_data'].items():
        if isinstance(value, (int, float)):
            print(f"  {key}: {value:.2f}")
        else:
            print(f"  {key}: {value}")
    
    print("-" * 40)

def _print_ai_strategy_log(strategy_record):
    """Print AI strategy log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(strategy_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"AI STRATEGY: {strategy_record['strategy_type'].upper()}")
    print(f"Time: {timestamp_str}")
    print(f"Strategy: {strategy_record['strategy_data']}")
    print("-" * 40)

def _print_ai_evaluation_log(evaluation_record):
    """Print AI evaluation log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(evaluation_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"AI EVALUATION: {evaluation_record['evaluation_type'].upper()}")
    print(f"Time: {timestamp_str} | Confidence: {evaluation_record['confidence']:.2f}")
    print(f"Evaluated {evaluation_record['candidates_evaluated']} options")
    print(f"Chosen: {evaluation_record['chosen_candidate']}")
    
    top_candidates = evaluation_record['all_candidates'][:3]
    for i, candidate in enumerate(top_candidates):
        print(f"  #{i+1}: {candidate}")
    
    if len(evaluation_record['all_candidates']) > 3:
        print(f"  ... and {len(evaluation_record['all_candidates']) - 3} more")
    
    print("-" * 40)

# =============================================================================
# DEBUG ENDPOINTS - FILE READING ONLY ON DEMAND
# =============================================================================

def get_environment_info():
    """Get information about the current environment - NO FILE READING"""
    return {
        'is_local_development': IS_LOCAL_DEVELOPMENT,
        'is_production': IS_PRODUCTION,
        'file_logging_enabled': LOG_TO_FILE,
        'console_logging_enabled': LOG_TO_CONSOLE,
        'gae_env': os.environ.get('GAE_ENV', 'Not set'),
        'platform': platform.system(),
        'logs_directory': LOGS_DIRECTORY,
        'current_log_file': os.path.basename(CURRENT_LOG_FILE) if CURRENT_LOG_FILE else None
    }

def get_logging_summary():
    """Get summary of current session only - NO FILE READING"""
    return {
        'current_log_file': os.path.basename(CURRENT_LOG_FILE) if CURRENT_LOG_FILE else None,
        'logging_enabled': LOGGING_ENABLED,
        'environment': 'local_development' if IS_LOCAL_DEVELOPMENT else 'production',
        'file_logging_available': IS_LOCAL_DEVELOPMENT,
        'message': 'Historical log analysis available via explicit debug endpoints only'
    }

# The following functions are only called by explicit debug routes, never during normal gameplay

def list_game_logs():
    """List all available game log files - ONLY for debug endpoints"""
    if not IS_LOCAL_DEVELOPMENT or not os.path.exists(LOGS_DIRECTORY):
        return []
    
    log_files = []
    for filename in os.listdir(LOGS_DIRECTORY):
        if filename.startswith('game_log_') and filename.endswith('.json'):
            filepath = os.path.join(LOGS_DIRECTORY, filename)
            try:
                parts = filename.replace('game_log_', '').replace('.json', '').split('_')
                if len(parts) >= 3:
                    stat = os.stat(filepath)
                    log_files.append({
                        'filename': filename,
                        'date': parts[0],
                        'time': parts[1],
                        'game_id': parts[2],
                        'size_bytes': stat.st_size,
                        'modified': datetime.fromtimestamp(stat.st_mtime).isoformat()
                    })
            except Exception:
                pass
    
    return sorted(log_files, key=lambda x: x['modified'], reverse=True)

def get_game_log_summary(filename):
    """Get summary of a specific game log file - ONLY for debug endpoints"""
    if not IS_LOCAL_DEVELOPMENT:
        return {'error': 'File logging not available in production'}
    
    filepath = os.path.join(LOGS_DIRECTORY, filename)
    if not os.path.exists(filepath):
        return {'error': f'Log file not found: {filename}'}
    
    try:
        with open(filepath, 'r') as f:
            logs = json.load(f)
        
        log_counts = {}
        for entry in logs:
            log_type = entry.get('log_type', 'unknown')
            log_counts[log_type] = log_counts.get(log_type, 0) + 1
        
        return {
            'filename': filename,
            'total_entries': len(logs),
            'log_type_counts': log_counts,
            'file_size_kb': round(os.path.getsize(filepath) / 1024, 2)
        }
        
    except Exception as e:
        return {'error': f'Could not analyze log file: {e}'}

# =============================================================================
# CONTROL FUNCTIONS
# =============================================================================

def enable_logging():
    """Enable all logging"""
    global LOGGING_ENABLED
    LOGGING_ENABLED = True
    if LOG_TO_CONSOLE:
        print("Logging ENABLED")

def disable_logging():
    """Disable all logging"""
    global LOGGING_ENABLED
    LOGGING_ENABLED = False
    if LOG_TO_CONSOLE:
        print("Logging DISABLED")

def set_console_log_level(level):
    """Set console logging level"""
    global CONSOLE_LOG_LEVEL
    valid_levels = ['ALL', 'ACTIONS_ONLY', 'AI_ONLY', 'EVENTS_ONLY', 'OFF']
    if level in valid_levels:
        CONSOLE_LOG_LEVEL = level
        if LOG_TO_CONSOLE:
            print(f"Console log level set to: {level}")
    else:
        if LOG_TO_CONSOLE:
            print(f"Invalid log level. Valid options: {valid_levels}")

def toggle_console_logging():
    """Toggle console logging on/off"""
    global LOG_TO_CONSOLE
    LOG_TO_CONSOLE = not LOG_TO_CONSOLE
    print(f"Console logging: {'ON' if LOG_TO_CONSOLE else 'OFF'}")

================================================================================

FILE: ./static/game.js
--------------------------------------------------------------------------------
let gameState = null;
let selectedCard = null;
let trickDisplayTimeout = null;
let lastHandNumber = null;

// New variables for bidding confirmation
let selectedBid = null;
let confirmingBid = false;

// New global variable for scroll preservation
let trickHistoryScrollPosition = 0;

async function loadGameState() {
    try {
        const response = await fetch('/state');
        gameState = await response.json();
        updateUI();
    } catch (error) {
        console.error('Error loading game state:', error);
        showMessage('Error loading game', 'error');
    }
}

function updateUI() {
    if (!gameState) return;

    // Preserve trick history scroll position before updating
    preserveTrickHistoryScroll();

    // Update floating game scores
    updateFloatingScores();

    // Update hand count display
    const playerHandCountEl = document.getElementById('playerHandCount');
    if (playerHandCountEl) {
        playerHandCountEl.textContent = `(${gameState.player_hand.length} cards)`;
    }

    // Show/hide bidding section and blind bidding
    const biddingSection = document.getElementById('biddingSection');
    const discardBlindSection = document.getElementById('discardBlindBiddingSection');

    if (gameState.phase === 'bidding') {
        biddingSection.style.display = 'block';
        discardBlindSection.style.display = 'none';
        // Only reset bidding state if we're entering bidding phase for the first time
        if (!biddingSection.classList.contains('active')) {
            biddingSection.classList.add('active');
            resetBiddingState();
        }
    } else if (gameState.phase === 'discard') {
        // Check if player is eligible for blind bidding and hasn't already bid
        if (!gameState.player_bid && !gameState.blind_bid) {
            // Check if player is down by 100+ points for blind eligibility
            const deficit = gameState.computer_score - gameState.player_score;
            if (deficit >= 100) {
                discardBlindSection.style.display = 'block';
            } else {
                discardBlindSection.style.display = 'none';
            }
        } else {
            discardBlindSection.style.display = 'none';
        }
        biddingSection.style.display = 'none';
    } else {
        biddingSection.style.display = 'none';
        discardBlindSection.style.display = 'none';
        // Remove active class when leaving bidding phase
        biddingSection.classList.remove('active');
    }

    // Handle results display for completed hands
    handleResultsDisplay();

    // Update message with Martha-first bidding support
    let messageToShow = gameState.message;

    // Special case: Martha bid first during bidding phase
    if (gameState.phase === 'bidding' && gameState.computer_bid !== null && gameState.player_bid === null) {
        const computerBlindText = gameState.computer_blind_bid ? " (BLIND)" : "";
        messageToShow = `Martha bid ${gameState.computer_bid}${computerBlindText} tricks. Now make your bid: How many tricks will you take? (0-10)`;
    }

    // AVOID showing detailed results if structured results are shown
    if (gameState.hand_over && gameState.hand_results) {
        // If we have structured results, show only a simple message
        messageToShow = `Hand #${gameState.hand_number} complete! Click 'Next Hand' to continue`;
    }

    showMessage(messageToShow, messageToShow.includes('WIN') ? 'success' : '');

    // Update play area
    updatePlayArea();

    // Update hands
    updatePlayerHand();
    updateComputerHand();

    // Update buttons based on game state
    updateActionButtons();

    // Update bidding buttons if in bidding phase
    if (gameState.phase === 'bidding') {
        updateBidButtons();
    }

    // Update computer hand toggle button - respect debug mode
    const toggleButton = document.getElementById('toggleComputerHand');
    if (toggleButton) {
        if (gameState.debug_mode) {
            // In debug mode, show the button and update text
            toggleButton.style.display = 'inline-block';
            toggleButton.textContent = gameState.show_computer_hand ? 'Hide Cards' : 'Show Cards';
            toggleButton.style.background = '#6c757d';
        } else {
            // Not in debug mode, hide the button completely
            toggleButton.style.display = 'none';
        }
    }

    // Show discards if hand is over
    updateDiscards();

    // Check for completed trick that needs to be displayed
    if (gameState.current_trick && gameState.current_trick.length === 2 && !trickDisplayTimeout) {
        trickDisplayTimeout = setTimeout(async () => {
            try {
                await fetch('/clear_trick', { method: 'POST' });
                await loadGameState();
                trickDisplayTimeout = null;
            } catch (error) {
                console.error('Error clearing trick:', error);
                trickDisplayTimeout = null;
            }
        }, 3000);
    }

    // Check game over
    if (gameState.game_over) {
        document.getElementById('gameOver').style.display = 'block';
        document.getElementById('winnerText').textContent = gameState.message;
    } else {
        document.getElementById('gameOver').style.display = 'none';
    }

    // Track hand changes for results display
    lastHandNumber = gameState.hand_number;

    // Restore trick history scroll position after DOM updates
    restoreTrickHistoryScroll();
}

// New bidding confirmation functions
function selectBid(bidAmount) {
    if (confirmingBid) return; // Prevent double-taps during confirmation

    selectedBid = bidAmount;
    confirmingBid = true;

    // Update button states to show selection
    updateBidButtons();

    // Update the bidding prompt to show confirmation
    const biddingPrompt = document.querySelector('.bidding-prompt');
    if (biddingPrompt) {
        const bidText = bidAmount === 0 ? 'NIL (0 tricks)' : `${bidAmount} tricks`;
        biddingPrompt.innerHTML = `
            You selected: <strong>${bidText}</strong><br>
            <small style="color: #666;">Confirm this bid or select a different amount</small>
        `;
    }

    // Haptic feedback for selection
    if (navigator.vibrate) navigator.vibrate(50);
}

function confirmSelectedBid() {
    if (selectedBid === null || !confirmingBid) return;

    // Make the actual bid
    makeBid(selectedBid);

    // Reset confirmation state
    resetBiddingState();
}

function cancelBidSelection() {
    resetBiddingState();

    const biddingPrompt = document.querySelector('.bidding-prompt');
    if (biddingPrompt) {
        biddingPrompt.innerHTML = `How many tricks will you take out of 10?<br>
            <small style="color: #666;">Tap a number to select, then confirm your bid</small>`;
    }
}

function resetBiddingState() {
    selectedBid = null;
    confirmingBid = false;
    updateBidButtons();
}

function updateBidButtons() {
    const bidButtons = document.querySelectorAll('.bid-btn');
    const confirmButton = document.getElementById('confirmBidButton');
    const cancelButton = document.getElementById('cancelBidButton');

    if (confirmingBid && selectedBid !== null) {
        // Show selected state
        bidButtons.forEach(btn => {
            const bidValue = parseInt(btn.getAttribute('data-bid'));
            if (bidValue === selectedBid) {
                btn.classList.add('selected');
                btn.style.backgroundColor = '#28a745';
                btn.style.color = 'white';
                btn.style.border = '2px solid #1e7e34';
            } else {
                btn.classList.remove('selected');
                btn.style.backgroundColor = '';
                btn.style.color = '';
                btn.style.border = '';
                btn.style.opacity = '0.6';
            }
        });

        // Show confirm/cancel buttons
        if (confirmButton) confirmButton.style.display = 'inline-block';
        if (cancelButton) cancelButton.style.display = 'inline-block';
    } else {
        // Reset all buttons to normal state
        bidButtons.forEach(btn => {
            btn.classList.remove('selected');
            btn.style.backgroundColor = '';
            btn.style.color = '';
            btn.style.border = '';
            btn.style.opacity = '';
        });

        // Hide confirm/cancel buttons
        if (confirmButton) confirmButton.style.display = 'none';
        if (cancelButton) cancelButton.style.display = 'none';
    }
}

// Scroll position preservation functions
function preserveTrickHistoryScroll() {
    const trickHistory = document.querySelector('.trick-history');
    if (trickHistory) {
        trickHistoryScrollPosition = trickHistory.scrollTop;
    }
}

function restoreTrickHistoryScroll() {
    const trickHistory = document.querySelector('.trick-history');
    if (trickHistory && trickHistoryScrollPosition > 0) {
        // Use setTimeout to ensure DOM has updated
        setTimeout(() => {
            trickHistory.scrollTop = trickHistoryScrollPosition;
        }, 10);
    }
}

// Reset scroll position when starting new hand
function resetTrickHistoryScroll() {
    trickHistoryScrollPosition = 0;
}

function updateFloatingScores() {
    // Update floating game score with parity indicators
    const gameScoreEl = document.getElementById('floatingGameScore');
    if (gameScoreEl) {
        document.getElementById('floatingPlayerScore').textContent = gameState.player_score;
        document.getElementById('floatingComputerScore').textContent = gameState.computer_score;
        document.getElementById('floatingHandNumber').textContent = gameState.hand_number;

        // Update parity displays
        const playerParityText = `(${gameState.player_parity.toUpperCase()})`;
        const computerParityText = `(${gameState.computer_parity.toUpperCase()})`;

        document.getElementById('floatingPlayerParity').textContent = playerParityText;
        document.getElementById('floatingComputerParity').textContent = computerParityText;
    }

    // Update floating hand score
    const handScoreEl = document.getElementById('floatingHandScore');
    if (handScoreEl) {
        // Player side
        document.getElementById('floatingPlayerTricks').textContent = gameState.player_tricks;
        const playerBid = gameState.player_bid !== null ? gameState.player_bid : '-';
        const playerBlindText = gameState.blind_bid === gameState.player_bid ? 'B' : '';
        document.getElementById('floatingPlayerBid').textContent = `${playerBid}${playerBlindText}`;

        // Color code player bid if blind
        const playerBidEl = document.getElementById('floatingPlayerBid');
        if (playerBlindText) {
            playerBidEl.style.color = '#dc3545';
            playerBidEl.style.fontWeight = 'bold';
        } else {
            playerBidEl.style.color = '#333';
            playerBidEl.style.fontWeight = '600';
        }

        document.getElementById('floatingPlayerBags').textContent = gameState.player_bags || 0;

        // Computer side
        document.getElementById('floatingComputerTricks').textContent = gameState.computer_tricks;
        const computerBid = gameState.computer_bid !== null ? gameState.computer_bid : '-';
        const computerBlindText = gameState.computer_blind_bid === gameState.computer_bid ? 'B' : '';
        document.getElementById('floatingComputerBid').textContent = `${computerBid}${computerBlindText}`;

        // Color code computer bid if blind OR if Martha bid first
        const computerBidEl = document.getElementById('floatingComputerBid');
        const marthaWentFirst = gameState.phase === 'bidding' &&
            gameState.computer_bid !== null &&
            gameState.player_bid === null;

        if (computerBlindText) {
            // Blind bid styling
            computerBidEl.style.color = '#dc3545';
            computerBidEl.style.fontWeight = 'bold';
            computerBidEl.style.backgroundColor = '';
            computerBidEl.style.border = '';
            computerBidEl.style.borderRadius = '';
            computerBidEl.style.padding = '';
        } else if (marthaWentFirst) {
            // Martha went first - highlight her bid
            computerBidEl.style.color = '#1976d2';
            computerBidEl.style.fontWeight = 'bold';
            computerBidEl.style.backgroundColor = '#e3f2fd';
            computerBidEl.style.border = '2px solid #1976d2';
            computerBidEl.style.borderRadius = '4px';
            computerBidEl.style.padding = '2px 4px';
        } else {
            // Normal styling
            computerBidEl.style.color = '#333';
            computerBidEl.style.fontWeight = '600';
            computerBidEl.style.backgroundColor = '';
            computerBidEl.style.border = '';
            computerBidEl.style.borderRadius = '';
            computerBidEl.style.padding = '';
        }

        document.getElementById('floatingComputerBags').textContent = gameState.computer_bags || 0;

        // Spades status
        document.getElementById('floatingSpadesStatus').textContent = gameState.spades_broken ? 'Broken' : 'Not Broken';
    }
}

function updateBagsDisplay(elementId, bags) {
    const bagsEl = document.getElementById(elementId);
    if (!bagsEl) return;

    bagsEl.textContent = `Bags: ${bags}/7`;

    // Color coding for mobile-friendly visibility
    if (bags >= 6) {
        bagsEl.style.color = '#d32f2f';
        bagsEl.style.fontWeight = 'bold';
        bagsEl.style.backgroundColor = '#ffebee';
        bagsEl.style.padding = '2px 6px';
        bagsEl.style.borderRadius = '4px';
    } else if (bags >= 4) {
        bagsEl.style.color = '#f57c00';
        bagsEl.style.fontWeight = 'bold';
        bagsEl.style.backgroundColor = '#fff3e0';
        bagsEl.style.padding = '2px 6px';
        bagsEl.style.borderRadius = '4px';
    } else if (bags <= -4) {
        bagsEl.style.color = '#1976d2';
        bagsEl.style.fontWeight = 'bold';
        bagsEl.style.backgroundColor = '#e3f2fd';
        bagsEl.style.padding = '2px 6px';
        bagsEl.style.borderRadius = '4px';
    } else {
        bagsEl.style.color = '#666';
        bagsEl.style.fontWeight = 'normal';
        bagsEl.style.backgroundColor = 'transparent';
        bagsEl.style.padding = '0';
    }
}

// Clean structured results display
function handleResultsDisplay() {
    const resultsSection = document.getElementById('resultsSection');
    const resultsContent = document.getElementById('resultsContent');

    if (gameState.hand_over && gameState.hand_results) {
        // Show results section with clean structured content
        resultsSection.classList.add('show');
        resultsContent.innerHTML = formatCleanResults(gameState.hand_results);
    } else {
        // Don't show results if no structured data available
        resultsSection.classList.remove('show');
    }
}

// Clean formatting function
function formatCleanResults(results) {
    let html = '';

    // Parity Assignment
    html += `
        <div class="result-section">
            <div class="result-header">Players</div>
            <div class="result-content">Tom (${results.parity.player}) vs Marta (${results.parity.computer})</div>
        </div>
    `;

    // Discard Information
    if (results.discard_info && results.discard_info !== 'No discards to score') {
        html += `
            <div class="result-section">
                <div class="result-header">Discard Pile</div>
                <div class="result-content highlight">${results.discard_info}</div>
            </div>
        `;
    }

    // Scoring Breakdown
    html += `
        <div class="result-section">
            <div class="result-header">Scoring</div>
            <div class="result-content">${formatScoring(results.scoring)}</div>
        </div>
    `;

    // Trick History
    if (results.trick_history && results.trick_history.length > 0) {
        html += `
            <div class="result-section">
                <div class="result-header">Trick History</div>
                <div class="trick-history">
        `;

        results.trick_history.forEach(trick => {
            html += `
                <div class="trick-line">
                    <span class="trick-number">T${trick.number}:</span>
                    <span class="trick-cards">${trick.player_card} vs ${trick.computer_card}</span>
                    <span class="trick-winner">â†’ ${trick.winner}</span>
                </div>
            `;
        });

        html += `
                </div>
            </div>
        `;
    }

    // Game Totals
    html += `
        <div class="result-section">
            <div class="result-header">Game Totals</div>
            <div class="result-content totals">
                <span>Tom: ${results.totals.player_score}</span>
                <span>Marta: ${results.totals.computer_score}</span>
            </div>
        </div>
    `;

    return html;
}

function formatScoring(scoringText) {
    // Split by " | " and format each piece nicely
    const parts = scoringText.split(' | ');
    return parts.map(part => {
        part = part.trim();

        if (part.includes('BAG PENALTY')) {
            return `<div class="penalty-line">${part.replace('BAG PENALTY!', 'Bag Penalty')}</div>`;
        } else if (part.includes('NEGATIVE BAG BONUS')) {
            return `<div class="bonus-line">${part.replace('NEGATIVE BAG BONUS!', 'Bag Bonus')}</div>`;
        } else if (part.includes('special cards')) {
            return `<div class="special-line">${part}</div>`;
        } else if (part.includes('Bags:')) {
            return `<div class="bags-line">${part}</div>`;
        } else {
            return `<div class="score-line">${part}</div>`;
        }
    }).join('');
}

// Legacy formatting function - keeping for fallback compatibility
function formatResultsForMobile(explanation) {
    if (!explanation || explanation === 'No discards to score') {
        return '<div class="result-line" style="color: #666; font-style: italic;">No special scoring this hand</div>';
    }

    // Split explanation by pipe separators and format each section cleanly
    const sections = explanation.split(' | ');
    let formatted = '';

    sections.forEach((section) => {
        section = section.trim();

        if (section.includes('complete!')) {
            // Skip the "Hand complete" line - already shown in header
            return;
        } else if (section.includes('vs') && (section.includes('Even') || section.includes('Odd'))) {
            // Parity assignment - make it cleaner
            const clean = section.replace(/Tom \(Even\) vs Marta \(Odd\)|Tom \(Odd\) vs Marta \(Even\)/,
                section.includes('Tom (Even)') ? 'Tom: Even, Marta: Odd' : 'Tom: Odd, Marta: Even');
            formatted += `<div class="result-line" style="font-weight: 500; color: #6c757d;">${clean}</div>`;
        } else if (section.includes('DISCARD PILE REVEALS:')) {
            // Clean up discard reveals
            const clean = section.replace('DISCARD PILE REVEALS: Discards:', 'Discard pile:');
            formatted += `<div class="result-line highlight">${clean}</div>`;
        } else if (section.includes('Tom:') && section.includes('bid')) {
            // Player scoring line
            formatted += `<div class="result-line">${section}</div>`;
        } else if (section.includes('Marta:') && section.includes('bid')) {
            // Computer scoring line  
            formatted += `<div class="result-line">${section}</div>`;
        } else if (section.includes('BAG PENALTY')) {
            // Penalty formatting
            const clean = section.replace('BAG PENALTY!', 'Bag penalty');
            formatted += `<div class="result-line penalty">${clean}</div>`;
        } else if (section.includes('NEGATIVE BAG BONUS')) {
            // Bonus formatting
            const clean = section.replace('NEGATIVE BAG BONUS!', 'Bag bonus');
            formatted += `<div class="result-line bonus">${clean}</div>`;
        } else if (section.includes('won') && section.includes('special cards')) {
            // Special card wins
            formatted += `<div class="result-line" style="color: #17a2b8;">${section}</div>`;
        } else if (section.includes('Bags:')) {
            // Bag status
            formatted += `<div class="result-line" style="color: #6c757d; font-size: 11px; text-align: center; border-top: 1px solid #e9ecef; padding-top: 6px; margin-top: 4px;">${section}</div>`;
        } else if (section.includes('Game totals:')) {
            // Game totals - make prominent but clean
            formatted += `<div class="result-line" style="font-weight: 600; text-align: center; margin-top: 6px; padding-top: 6px; border-top: 1px solid #e9ecef;">${section}</div>`;
        } else if (section.includes('TRICK HISTORY:')) {
            // Format trick history nicely
            const clean = section.replace('TRICK HISTORY: ', '');
            const tricks = clean.split(' | ');
            let historyHtml = '<div class="result-line" style="font-weight: 500; margin-top: 8px; color: #495057;">Trick History:</div>';
            tricks.forEach(trick => {
                historyHtml += `<div class="result-line" style="font-size: 11px; color: #495057; padding-left: 8px; font-family: monospace;">${trick}</div>`;
            });
            formatted += historyHtml;
        } else if (section.includes('Click') || section.includes('continue')) {
            // Skip instructions - handled by button
            return;
        } else if (section.length > 0) {
            // Any other content
            formatted += `<div class="result-line">${section}</div>`;
        }
    });

    return formatted;
}

function updateActionButtons() {
    const actionButton = document.getElementById('actionButton');
    const nextHandSection = document.getElementById('nextHandSection');

    if (gameState.hand_over && !gameState.game_over) {
        actionButton.style.display = 'none';
        nextHandSection.style.display = 'block';
    } else {
        nextHandSection.style.display = 'none';

        if (gameState.phase === 'discard') {
            // Hide discard button if player is blind eligible and no bid made yet
            const deficit = gameState.computer_score - gameState.player_score;
            const isBlindEligible = deficit >= 100;
            const noBidMadeYet = !gameState.player_bid && !gameState.blind_bid;

            if (isBlindEligible && noBidMadeYet) {
                actionButton.style.display = 'none';
            } else {
                actionButton.textContent = 'Discard Selected';
                actionButton.onclick = discardCard;
                actionButton.style.display = 'inline-block';
            }
        } else if (gameState.phase === 'playing') {
            actionButton.textContent = 'Play Selected';
            actionButton.onclick = playCard;
            actionButton.style.display = 'inline-block';
        } else {
            actionButton.style.display = 'none';
        }
    }

    if (selectedCard === null && actionButton.style.display !== 'none') {
        actionButton.disabled = true;
        actionButton.textContent = gameState.phase === 'discard' ? 'Select Card to Discard' : 'Select Card to Play';
    } else if (actionButton.style.display !== 'none') {
        actionButton.disabled = false;
        actionButton.textContent = gameState.phase === 'discard' ? 'Discard Selected' : 'Play Selected';
    }
}

function updatePlayArea() {
    const trickDisplay = document.getElementById('trickDisplay');

    if (gameState.current_trick.length === 0) {
        trickDisplay.innerHTML = '<div style="color: #999; font-size: 14px;">Waiting for play...</div>';
    } else {
        let html = '<div class="trick-container">';

        const playerCard = gameState.current_trick.find(play => play.player === 'player');
        const computerCard = gameState.current_trick.find(play => play.player === 'computer');

        // Always show side by side - Tom left, Marta right
        if (playerCard) {
            const card = playerCard.card;
            const suitClass = getSuitClass(card.suit);
            html += `
                <div class="trick-card ${suitClass}">
                    <div class="player-name">Tom</div>
                    <div class="card-content">${card.rank}${card.suit}</div>
                </div>
            `;
        } else {
            html += '<div class="trick-card-placeholder"><div style="font-size: 10px; color: #999;">Tom</div></div>';
        }

        if (computerCard) {
            const card = computerCard.card;
            const suitClass = getSuitClass(card.suit);
            html += `
                <div class="trick-card ${suitClass}">
                    <div class="player-name">Marta</div>
                    <div class="card-content">${card.rank}${card.suit}</div>
                </div>
            `;
        } else {
            html += '<div class="trick-card-placeholder"><div style="font-size: 10px; color: #999;">Marta</div></div>';
        }

        html += '</div>';
        trickDisplay.innerHTML = html;
    }
}

function updatePlayerHand() {
    const handEl = document.getElementById('playerHand');
    const playerHandSection = document.getElementById('playerHandSection');
    handEl.innerHTML = '';

    // Hide entire hand section when hand is complete
    if (gameState.hand_over && gameState.player_hand.length === 0) {
        playerHandSection.style.display = 'none';
        return;
    } else {
        playerHandSection.style.display = 'block';
    }

    // Hide cards if in discard phase, no bid made yet, and player is down by 100+ points
    const deficit = gameState.computer_score - gameState.player_score;
    const isBlindEligible = deficit >= 100;
    const noBidMadeYet = !gameState.player_bid && !gameState.blind_bid;

    if (gameState.phase === 'discard' && isBlindEligible && noBidMadeYet) {
        handEl.innerHTML = '<div style="text-align: center; color: #666; font-style: italic; padding: 20px; border: 2px dashed #ccc; border-radius: 8px;">Cards hidden - make blind bid decision first!</div>';
        return;
    }

    gameState.player_hand.forEach((card, index) => {
        const cardEl = document.createElement('div');
        cardEl.className = `card ${getSuitClass(card.suit)}`;
        cardEl.textContent = `${card.rank}${card.suit}`;

        cardEl.onclick = () => selectCard(index);
        cardEl.ontouchstart = (e) => {
            e.preventDefault();
            selectCard(index);
        };

        if (selectedCard === index) {
            cardEl.classList.add('selected');
        }

        if (!canPlayCard(card, index)) {
            cardEl.classList.add('disabled');
        }

        handEl.appendChild(cardEl);
    });
}

function updateComputerHand() {
    const handEl = document.getElementById('computerHand');
    const computerHandSection = handEl.closest('.hand-section');

    // Hide entire computer hand section if debug mode is off
    if (!gameState.debug_mode) {
        computerHandSection.style.display = 'none';
        return;
    }

    // Show computer hand section if debug mode is on
    computerHandSection.style.display = 'block';
    handEl.innerHTML = '';

    // Only show cards if debug mode is on AND show_computer_hand is true
    if (gameState.debug_mode && gameState.show_computer_hand && gameState.computer_hand) {
        // Show actual cards
        gameState.computer_hand.forEach((card, index) => {
            const cardEl = document.createElement('div');
            cardEl.className = `card ${getSuitClass(card.suit)}`;
            cardEl.textContent = `${card.rank}${card.suit}`;
            cardEl.style.cursor = 'default';
            handEl.appendChild(cardEl);
        });
    } else {
        // Show hidden cards with count (only in debug mode)
        const cardCount = gameState.computer_hand_count || 0;
        for (let i = 0; i < cardCount; i++) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card';
            cardEl.style.background = '#666';
            cardEl.style.color = '#999';
            cardEl.textContent = '?';
            cardEl.style.cursor = 'default';
            handEl.appendChild(cardEl);
        }
    }
}

function updateDiscards() {
    const discardsSection = document.getElementById('discardsSection');

    if (gameState.hand_over && (gameState.player_discarded || gameState.computer_discarded)) {
        discardsSection.style.display = 'block';

        // Show player discard
        const playerDiscardEl = document.getElementById('playerDiscard');
        if (gameState.player_discarded) {
            const card = gameState.player_discarded;
            playerDiscardEl.innerHTML = `<div class="card ${getSuitClass(card.suit)}">${card.rank}${card.suit}</div>`;
        } else {
            playerDiscardEl.innerHTML = '<div class="card" style="opacity: 0.5;">None</div>';
        }

        // Show computer discard
        const computerDiscardEl = document.getElementById('computerDiscard');
        if (gameState.computer_discarded) {
            const card = gameState.computer_discarded;
            computerDiscardEl.innerHTML = `<div class="card ${getSuitClass(card.suit)}">${card.rank}${card.suit}</div>`;
        } else {
            computerDiscardEl.innerHTML = '<div class="card" style="opacity: 0.5;">None</div>';
        }
    } else {
        discardsSection.style.display = 'none';
    }
}

async function nextHand() {
    try {
        const response = await fetch('/next_hand', { method: 'POST' });
        if (response.ok) {
            if (trickDisplayTimeout) {
                clearTimeout(trickDisplayTimeout);
                trickDisplayTimeout = null;
            }
            selectedCard = null;
            resetBiddingState();
            resetTrickHistoryScroll();
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error starting next hand:', error);
        showMessage('Error starting next hand', 'error');
    }
}

function getSuitClass(suit) {
    switch (suit) {
        case 'â™ ': return 'spade';
        case 'â™¥': return 'heart';
        case 'â™¦': return 'diamond';
        case 'â™£': return 'club';
        default: return '';
    }
}

function canPlayCard(card, index) {
    if (gameState.phase === 'discard') return true;
    if (gameState.turn !== 'player') return false;

    if (gameState.current_trick.length === 1) {
        const leadSuit = gameState.current_trick[0].card.suit;
        const hasSuit = gameState.player_hand.some(c => c.suit === leadSuit);
        if (hasSuit) {
            return card.suit === leadSuit;
        }
        return true;
    }

    if (gameState.current_trick.length === 0) {
        if (card.suit === 'â™ ' && !gameState.spades_broken) {
            return gameState.player_hand.every(c => c.suit === 'â™ ');
        }
        return true;
    }

    return false;
}

function selectCard(index) {
    if (!canPlayCard(gameState.player_hand[index], index)) {
        showMessage('Cannot play this card!', 'error');
        if (navigator.vibrate) {
            navigator.vibrate(100);
        }
        return;
    }

    selectedCard = index;
    updatePlayerHand();
    updateActionButtons();

    if (navigator.vibrate) {
        navigator.vibrate(50);
    }
}

async function discardCard() {
    if (selectedCard === null) {
        showMessage('Please select a card to discard', 'error');
        if (navigator.vibrate) navigator.vibrate(100);
        return;
    }

    try {
        const response = await fetch('/discard', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ index: selectedCard })
        });

        if (response.ok) {
            selectedCard = null;
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error discarding card:', error);
        showMessage('Error discarding card', 'error');
    }
}

async function playCard() {
    if (selectedCard === null) {
        showMessage('Please select a card to play', 'error');
        if (navigator.vibrate) navigator.vibrate(100);
        return;
    }

    try {
        const response = await fetch('/play', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ index: selectedCard })
        });

        if (response.ok) {
            selectedCard = null;
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error playing card:', error);
        showMessage('Error playing card', 'error');
    }
}

async function performAction() {
    if (gameState && gameState.phase === 'discard') {
        await discardCard();
    } else {
        await playCard();
    }
}

async function makeBid(bidAmount) {
    try {
        const response = await fetch('/bid', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ bid: bidAmount })
        });

        if (response.ok) {
            await loadGameState();
            if (navigator.vibrate) navigator.vibrate(50);
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error making bid:', error);
        showMessage('Error making bid', 'error');
    }
}

async function makeBlindBid(bidAmount) {
    try {
        const response = await fetch('/blind_bid', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ bid: bidAmount })
        });

        if (response.ok) {
            await loadGameState();
            if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error making blind bid:', error);
        showMessage('Error making blind bid', 'error');
    }
}

async function toggleComputerHand() {
    try {
        const response = await fetch('/toggle_computer_hand', { method: 'POST' });
        if (response.ok) {
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error toggling computer hand:', error);
        showMessage('Error toggling computer hand', 'error');
    }
}

async function startNewGame() {
    try {
        if (trickDisplayTimeout) {
            clearTimeout(trickDisplayTimeout);
            trickDisplayTimeout = null;
        }

        await fetch('/new_game', { method: 'POST' });
        selectedCard = null;
        resetBiddingState();
        resetTrickHistoryScroll();
        await loadGameState();
    } catch (error) {
        console.error('Error starting new game:', error);
        showMessage('Error starting new game', 'error');
    }
}

async function startNewGameWithRedirect() {
    window.location.href = '/?new=true';
}

// Fixed showMessage function - no auto-scroll behavior
function showMessage(text, type = '') {
    const messageEl = document.getElementById('message');
    if (messageEl) {
        messageEl.textContent = text;
        messageEl.className = 'message ' + type;
        // Removed all auto-scroll behavior - let users control their own scrolling
    }
}

// Initialize game on load
document.addEventListener('DOMContentLoaded', function () {
    loadGameState();

    // Prevent zoom on double-tap for mobile
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function (event) {
        const now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300) {
            event.preventDefault();
        }
        lastTouchEnd = now;
    }, false);
});

// Auto-refresh with mobile-friendly timing
setInterval(() => {
    if (gameState && !gameState.game_over && !trickDisplayTimeout) {
        loadGameState();
    }
}, 2500);

// Handle orientation changes on mobile
window.addEventListener('orientationchange', function () {
    setTimeout(() => {
        updatePlayArea();
    }, 100);
});

================================================================================

FILE: ./static/style.css
--------------------------------------------------------------------------------
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 140px 0 40px 0;
    /* Increased top padding */
}

.container {
    max-width: 650px;
    margin: 0 auto;
    background: white;
    border-radius: 15px;
    padding: 15px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
}

/* Floating headers with better spacing */
.floating-game-score {
    position: fixed;
    top: 10px;
    left: 8px;
    right: 8px;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 10px;
    padding: 10px 15px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    z-index: 999;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 14px;
}

.floating-hand-score {
    position: fixed;
    top: 80px;
    /* Increased from 70px to prevent overlap */
    left: 8px;
    right: 8px;
    background: rgba(248, 249, 250, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 8px;
    padding: 8px 15px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    z-index: 998;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: #495057;
}

.game-score-item {
    text-align: center;
    flex: 1;
}

.game-score-label {
    font-size: 11px;
    color: #666;
    margin-bottom: 2px;
}

.game-score-value {
    font-size: 20px;
    font-weight: bold;
    color: #333;
}

.game-score-parity {
    font-size: 9px;
    color: #666;
    margin-bottom: 2px;
    font-weight: normal;
    line-height: 1;
}

.hand-score-item {
    text-align: center;
    flex: 1;
    font-size: 12px;
}

.hand-score-item .label {
    color: #6c757d;
    margin-bottom: 2px;
}

.hand-score-item .value {
    font-weight: 600;
    color: #333;
}

/* Top interactive area */
.top-interactive-area {
    /* No additional styling needed */
}

/* Play area */
.play-area {
    padding: 20px 8px;
    margin-bottom: 12px;
    min-height: 140px;
    display: flex;
    justify-content: center;
    align-items: center;
}

.trick-container {
    display: flex;
    justify-content: space-around;
    align-items: center;
    width: 100%;
    gap: 20px;
    flex-wrap: wrap;
}

.trick-card {
    background: white;
    border: 2px solid #333;
    border-radius: 10px;
    padding: 16px 12px;
    width: 120px;
    height: 140px;
    text-align: center;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    flex-shrink: 0;
}

.trick-card .player-name {
    font-size: 13px;
    font-weight: 600;
    color: #666;
    margin-bottom: 6px;
}

.trick-card .card-content {
    font-size: 32px;
    font-weight: bold;
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
}

.trick-card-placeholder {
    width: 120px;
    height: 140px;
    border: 2px dashed #ccc;
    border-radius: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: #999;
    font-size: 14px;
    flex-shrink: 0;
}

/* Trick card colors */
.trick-card.spade {
    color: #000;
}

.trick-card.heart {
    color: #ff0000;
}

.trick-card.diamond {
    color: #ff6200;
}

.trick-card.club {
    color: #333;
}

/* Game over */
.game-over {
    text-align: center;
    padding: 20px 15px;
    background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
    border-radius: 10px;
    margin-bottom: 15px;
    border: 3px solid #ff9800;
    box-shadow: 0 6px 20px rgba(255, 152, 0, 0.3);
    animation: gameOverPulse 2s ease-in-out infinite alternate;
}

.winner-text {
    font-size: 22px;
    font-weight: bold;
    color: #d84315;
    margin-bottom: 15px;
    line-height: 1.2;
    text-shadow: 1px 1px 2px rgba(216, 67, 21, 0.2);
}

.game-over button {
    background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
    color: white;
    border: none;
    padding: 15px 25px;
    border-radius: 8px;
    font-size: 18px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
}

.game-over button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(76, 175, 80, 0.4);
    background: linear-gradient(135deg, #45a049 0%, #4caf50 100%);
}

/* Animation for game over box */
@keyframes gameOverPulse {
    0% {
        transform: scale(1);
        box-shadow: 0 6px 20px rgba(255, 152, 0, 0.3);
    }

    100% {
        transform: scale(1.02);
        box-shadow: 0 8px 25px rgba(255, 152, 0, 0.4);
    }
}

/* Message */
.message {
    text-align: center;
    padding: 10px 12px;
    margin-bottom: 20px;
    border-radius: 6px;
    font-weight: 400;
    background: #f8f9fa;
    color: #495057;
    font-size: 14px;
    line-height: 1.3;
    border-left: 4px solid #6c757d;
}

.message.success {
    color: #28a745;
    border-left-color: #28a745;
}

.message.error {
    color: #dc3545;
    border-left-color: #dc3545;
}

/* Next Hand button section */
.next-hand-section {
    margin-bottom: 20px;
    text-align: center;
}

.next-hand-btn {
    background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%) !important;
    color: white !important;
    border: none !important;
    padding: 16px 20px !important;
    border-radius: 10px !important;
    font-size: 18px !important;
    font-weight: bold !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    width: 100% !important;
    max-width: 400px !important;
    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3) !important;
}

.next-hand-btn:hover {
    background: linear-gradient(135deg, #45a049 0%, #4CAF50 100%) !important;
    transform: translateY(-2px) !important;
    box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4) !important;
}

/* Results section */
.results-section {
    background: #f8f9fa;
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 20px;
    display: none;
    font-size: 13px;
    color: #495057;
    border: 1px solid #e9ecef;
}

.results-section.show {
    display: block;
}

.results-header {
    font-weight: 600;
    color: #495057;
    margin-bottom: 10px;
    font-size: 16px;
    text-align: center;
    padding-bottom: 6px;
    border-bottom: 2px solid #e9ecef;
}

.results-content {
    /* Placeholder for dynamic content */
}

.result-section {
    margin-bottom: 10px;
    border-bottom: 1px solid #e9ecef;
    padding-bottom: 6px;
}

.result-section:last-child {
    border-bottom: none;
    margin-bottom: 0;
}

.result-header {
    font-size: 12px;
    font-weight: 600;
    color: #6c757d;
    margin-bottom: 4px;
    text-transform: uppercase;
}

.result-content {
    font-size: 13px;
    color: #495057;
    line-height: 1.3;
}

.result-content.highlight {
    background: #e8f5e9;
    padding: 6px 8px;
    border-radius: 4px;
    color: #2e7d32;
}

.result-content.totals {
    display: flex;
    justify-content: space-between;
    font-weight: 600;
    background: #f8f9fa;
    padding: 6px 8px;
    border-radius: 4px;
}

/* Trick history */
.trick-history {
    font-family: monospace;
    font-size: 11px;
    max-height: 150px;
    overflow-y: auto;
    background: #f8f9fa;
    padding: 8px;
    border-radius: 4px;
    border: 1px solid #e9ecef;
}

.trick-line {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 2px 0;
    border-bottom: 1px solid #e9ecef;
    flex-direction: column;
    align-items: flex-start;
}

.trick-line:last-child {
    border-bottom: none;
}

.trick-number {
    color: #6c757d;
    font-weight: 600;
    width: 100%;
}

.trick-cards {
    width: 100%;
    color: #495057;
    margin: 2px 0;
}

.trick-winner {
    color: #28a745;
    font-weight: 600;
    width: 100%;
    font-size: 10px;
}

/* Discarded cards section */
.discards-section {
    background: #e8f5e9;
    border: 2px solid #4caf50;
    border-radius: 10px;
    padding: 12px;
    margin-bottom: 20px;
}

.discards-content {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-top: 6px;
}

.discard-item {
    text-align: center;
    background: white;
    padding: 10px;
    border-radius: 6px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
}

.discard-label {
    font-size: 12px;
    font-weight: bold;
    color: #666;
    margin-bottom: 6px;
}

/* Hands area */
.hands-area {
    /* No specific styling needed */
}

/* Hand sections */
.hand-section {
    background: #f8f9fa;
    border-radius: 10px;
    padding: 12px;
    margin-bottom: 15px;
}

.hand-title {
    font-size: 16px;
    font-weight: bold;
    margin-bottom: 8px;
    color: #333;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.cards {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
    gap: 8px;
    justify-content: center;
    margin-bottom: 12px;
    max-width: 620px;
    margin-left: auto;
    margin-right: auto;
}

.card {
    background: white;
    border: 2px solid #ddd;
    border-radius: 8px;
    padding: 14px 8px;
    min-width: 70px;
    min-height: 90px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 18px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
}

.card:hover:not(.disabled) {
    transform: translateY(-3px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.card.selected {
    border-color: #4CAF50;
    background: #e8f5e9;
    transform: translateY(-3px);
    box-shadow: 0 4px 10px rgba(76, 175, 80, 0.4);
}

.card.disabled {
    opacity: 0.4;
    cursor: not-allowed;
}

/* Card colors */
.card.spade {
    color: #000;
}

.card.heart {
    color: #ff0000;
}

.card.diamond {
    color: #ff6200;
}

.card.club {
    color: #333;
}

/* Controls */
.controls {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
}

/* Buttons */
button {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    padding: 12px 18px;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    min-width: 80px;
}

button:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
}

button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Bidding section */
.bidding-section {
    background: #f8f9fa;
    border: 2px solid #dee2e6;
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 12px;
    text-align: center;
}

.bidding-title {
    font-size: 18px;
    font-weight: bold;
    color: #333;
    margin-bottom: 8px;
}

.bidding-prompt {
    font-size: 14px;
    color: #666;
    margin-bottom: 12px;
    line-height: 1.3;
}

.bid-buttons {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 8px;
    margin-top: 10px;
    max-width: 320px;
    margin-left: auto;
    margin-right: auto;
}

.bid-buttons button {
    padding: 12px 6px;
    font-size: 14px;
    background: #6c757d;
    color: white;
    font-weight: 600;
    min-width: 40px;
    border-radius: 6px;
    min-height: 50px;
}

.bid-buttons button:hover {
    background: #5a6268;
    transform: translateY(-2px);
}

.bid-btn {
    /* Inherits from button styles above */
}

/* Confirmation buttons styling */
.bid-confirmation-buttons {
    margin-top: 15px;
    text-align: center;
}

#confirmBidButton {
    background: #28a745 !important;
    color: white !important;
    border: none !important;
    padding: 14px 28px !important;
    border-radius: 8px !important;
    font-size: 16px !important;
    font-weight: bold !important;
    margin-right: 12px !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3) !important;
}

#confirmBidButton:hover {
    background: #218838 !important;
    transform: translateY(-2px) !important;
    box-shadow: 0 6px 16px rgba(40, 167, 69, 0.4) !important;
}

#cancelBidButton {
    background: #6c757d !important;
    color: white !important;
    border: none !important;
    padding: 14px 28px !important;
    border-radius: 8px !important;
    font-size: 16px !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
}

#cancelBidButton:hover {
    background: #5a6268 !important;
    transform: translateY(-2px) !important;
}

/* Selected bid button styling */
.bid-btn.selected {
    background: #28a745 !important;
    color: white !important;
    border: 3px solid #1e7e34 !important;
    transform: scale(1.05) !important;
    box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4) !important;
}

/* Blind bidding section */
.blind-bidding-section {
    background: #fff2f2;
    border: 2px solid #e57373;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;
}

.blind-header h3 {
    color: #d32f2f;
    margin-bottom: 6px;
    font-size: 16px;
    font-weight: 600;
}

.blind-header p {
    font-size: 12px;
    margin-bottom: 6px;
    color: #333;
    line-height: 1.3;
}

.blind-warning {
    background: #ffcdd2;
    color: #d32f2f;
    padding: 8px;
    border-radius: 4px;
    font-size: 11px;
    font-weight: 500;
    margin-bottom: 8px;
}

.blind-buttons {
    grid-template-columns: repeat(2, 1fr);
    gap: 6px;
    max-width: 280px;
    display: grid;
    margin-left: auto;
    margin-right: auto;
}

.blind-bid-btn {
    background: #d32f2f;
    color: white;
    font-weight: 600;
    padding: 12px 6px;
    font-size: 12px;
    min-height: 45px;
}

.blind-bid-btn:hover {
    background: #c62828;
    transform: translateY(-2px);
}

.regular-bid-prompt {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid #ccc;
}

.regular-bid-prompt p {
    font-size: 12px;
    color: #666;
    margin-bottom: 6px;
}

/* Bottom section */
.bottom-section {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(5px);
    padding: 4px 8px;
    box-shadow: 0 -2px 6px rgba(0, 0, 0, 0.1);
    z-index: 997;
    text-align: center;
    border-top: 1px solid #e9ecef;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
}

.bottom-new-game-btn {
    background: #dc3545;
    color: white;
    border: none;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: 600;
    cursor: pointer;
    height: 22px;
    min-width: 50px;
}

.bottom-new-game-btn:hover {
    background: #c82333;
}

.bottom-rules-btn {
    background: #28a745;
    color: white;
    border: none;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: 600;
    cursor: pointer;
    height: 22px;
    min-width: 45px;
}

.bottom-rules-btn:hover {
    background: #218838;
}

#toggleComputerHand {
    font-size: 12px;
    padding: 6px 10px;
    background: #6c757d;
    border-radius: 4px;
}

#toggleComputerHand:hover {
    background: #5a6268;
}

/* Desktop adjustments */
@media (min-width: 768px) {
    body {
        padding-top: 160px;
        /* Increased for desktop too */
        padding-bottom: 45px;
    }

    .container {
        max-width: 750px;
        padding: 20px;
    }

    .floating-game-score,
    .floating-hand-score {
        max-width: 750px;
        left: 50%;
        right: auto;
        transform: translateX(-50%);
    }

    .floating-hand-score {
        top: 85px;
        /* Increased spacing for desktop */
    }

    .bottom-section {
        max-width: 750px;
        left: 50%;
        right: auto;
        transform: translateX(-50%);
        height: 35px;
    }

    .bottom-new-game-btn,
    .bottom-rules-btn {
        padding: 6px 10px;
        font-size: 11px;
        height: 25px;
        min-width: 60px;
    }

    .play-area {
        min-height: 170px;
        padding: 25px 10px;
    }

    .trick-card {
        width: 140px;
        height: 160px;
        padding: 18px 14px;
    }

    .trick-card .card-content {
        font-size: 36px;
    }

    .trick-card-placeholder {
        width: 140px;
        height: 160px;
    }

    .game-over {
        padding: 25px 20px;
        margin-bottom: 20px;
    }

    .winner-text {
        font-size: 26px;
        margin-bottom: 18px;
    }

    .game-over button {
        padding: 18px 30px;
        font-size: 20px;
    }

    .cards {
        grid-template-columns: repeat(auto-fit, minmax(85px, 1fr));
        gap: 12px;
        max-width: 700px;
        margin: 0 auto 15px auto;
    }

    .card {
        min-width: 85px;
        min-height: 105px;
        font-size: 22px;
        padding: 16px 10px;
    }

    .bid-buttons {
        grid-template-columns: repeat(11, 1fr);
        max-width: 600px;
    }

    .blind-buttons {
        grid-template-columns: repeat(6, 1fr);
        max-width: 400px;
    }

    .trick-line {
        flex-direction: row;
        align-items: center;
    }

    .trick-number,
    .trick-cards,
    .trick-winner {
        width: auto;
        text-align: center;
    }

    .trick-cards {
        margin: 0;
        flex: 1;
    }

    .trick-winner {
        font-size: 11px;
        min-width: 60px;
        text-align: right;
    }

    .trick-history {
        max-height: 200px;
    }
}

================================================================================

FILE: ./templates/index.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Two-Player Spades</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

<body>
    <!-- Floating score headers -->
    <div class="floating-game-score" id="floatingGameScore">
        <div class="game-score-item">
            <div class="game-score-label">Tom</div>
            <div class="game-score-parity" id="floatingPlayerParity">(EVEN)</div>
            <div class="game-score-value" id="floatingPlayerScore">0</div>
        </div>
        <div class="game-score-item">
            <div class="game-score-label">Hand #<span id="floatingHandNumber">1</span></div>
        </div>
        <div class="game-score-item">
            <div class="game-score-label">Marta</div>
            <div class="game-score-parity" id="floatingComputerParity">(ODD)</div>
            <div class="game-score-value" id="floatingComputerScore">0</div>
        </div>
    </div>

    <div class="floating-hand-score" id="floatingHandScore">
        <div class="hand-score-item">
            <div class="label">Tricks</div>
            <div class="value" id="floatingPlayerTricks">0</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bid</div>
            <div class="value" id="floatingPlayerBid">-</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bags</div>
            <div class="value" id="floatingPlayerBags">0</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Spades</div>
            <div class="value" id="floatingSpadesStatus">Not Broken</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bags</div>
            <div class="value" id="floatingComputerBags">0</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bid</div>
            <div class="value" id="floatingComputerBid">-</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Tricks</div>
            <div class="value" id="floatingComputerTricks">0</div>
        </div>
    </div>

    <div class="container">
        <!-- Play area and messages at top - always visible -->
        <div class="top-interactive-area">
            <div class="play-area" id="playArea">
                <div id="trickDisplay"></div>
            </div>

            <!-- Game Over section moved here, right below play area -->
            <div class="game-over" id="gameOver" style="display: none;">
                <div class="winner-text" id="winnerText"></div>
                <button onclick="startNewGame()">Play Again</button>
            </div>

            <div class="message" id="message">Loading game...</div>

            <!-- Next Hand Button - moved above results -->
            <div class="next-hand-section" id="nextHandSection" style="display: none;">
                <button id="nextHandButton" onclick="nextHand()" class="next-hand-btn">Next Hand</button>
            </div>

            <!-- Discarded cards section - moved below Next Hand button -->
            <div class="discards-section" id="discardsSection" style="display: none;">
                <div class="hand-title">Discarded Cards</div>
                <div class="discards-content">
                    <div class="discard-item">
                        <div class="discard-label">Tom</div>
                        <div id="playerDiscard"></div>
                    </div>
                    <div class="discard-item">
                        <div class="discard-label">Marta</div>
                        <div id="computerDiscard"></div>
                    </div>
                </div>
            </div>

            <!-- Clean Results Section -->
            <div class="results-section" id="resultsSection">
                <div class="results-header">Hand Summary</div>
                <div class="results-content" id="resultsContent"></div>
            </div>

            <!-- Blind Bidding Section for Discard Phase -->
            <div class="blind-bidding-section" id="discardBlindBiddingSection" style="display: none;">
                <div class="blind-header">
                    <h3>Blind Bidding Available</h3>
                    <p>You're down by 100+ points. Go blind BEFORE seeing your cards for <strong>DOUBLE</strong>
                        points/penalties!</p>
                    <div class="blind-warning">
                        Must bid at least 5 tricks, get double rewards or double punishment!
                    </div>
                </div>
                <div class="bid-buttons blind-buttons">
                    <button onclick="makeBlindBid(5)" class="blind-bid-btn">BLIND 5</button>
                    <button onclick="makeBlindBid(6)" class="blind-bid-btn">BLIND 6</button>
                    <button onclick="makeBlindBid(7)" class="blind-bid-btn">BLIND 7</button>
                    <button onclick="makeBlindBid(8)" class="blind-bid-btn">BLIND 8</button>
                    <button onclick="makeBlindBid(9)" class="blind-bid-btn">BLIND 9</button>
                    <button onclick="makeBlindBid(10)" class="blind-bid-btn">BLIND 10</button>
                </div>
                <div class="regular-bid-prompt">
                    <p>Or discard normally and then make a regular bid:</p>
                </div>
            </div>

            <!-- UPDATED BIDDING SECTION WITH CONFIRMATION -->
            <div class="bidding-section" id="biddingSection" style="display: none;">
                <div class="bidding-title">Make Your Bid</div>
                <div class="bidding-prompt">How many tricks will you take out of 10?<br>
                    <small style="color: #666;">Tap a number to select, then confirm your bid</small>
                </div>

                <!-- Updated bidding buttons - changed onclick to selectBid -->
                <div class="bid-buttons">
                    <button onclick="selectBid(0)" class="bid-btn" data-bid="0">0<br><small>NIL</small></button>
                    <button onclick="selectBid(1)" class="bid-btn" data-bid="1">1</button>
                    <button onclick="selectBid(2)" class="bid-btn" data-bid="2">2</button>
                    <button onclick="selectBid(3)" class="bid-btn" data-bid="3">3</button>
                    <button onclick="selectBid(4)" class="bid-btn" data-bid="4">4</button>
                    <button onclick="selectBid(5)" class="bid-btn" data-bid="5">5</button>
                    <button onclick="selectBid(6)" class="bid-btn" data-bid="6">6</button>
                    <button onclick="selectBid(7)" class="bid-btn" data-bid="7">7</button>
                    <button onclick="selectBid(8)" class="bid-btn" data-bid="8">8</button>
                    <button onclick="selectBid(9)" class="bid-btn" data-bid="9">9</button>
                    <button onclick="selectBid(10)" class="bid-btn" data-bid="10">10</button>
                </div>

                <!-- New confirmation buttons -->
                <div class="bid-confirmation-buttons" style="margin-top: 15px; text-align: center;">
                    <button id="confirmBidButton" onclick="confirmSelectedBid()"
                        style="display: none; background: #28a745; color: white; border: none; padding: 12px 24px; border-radius: 6px; font-size: 16px; font-weight: bold; margin-right: 10px; cursor: pointer;">
                        Confirm Bid
                    </button>
                    <button id="cancelBidButton" onclick="cancelBidSelection()"
                        style="display: none; background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 6px; font-size: 16px; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            </div>
        </div>

        <!-- Hands section - can scroll if needed -->
        <div class="hands-area">

            <!-- Player hand section with conditional hiding -->
            <div class="hand-section" id="playerHandSection">
                <div class="hand-title">
                    Your Hand
                    <span style="font-size: 12px; color: #666; font-weight: normal;" id="playerHandCount"></span>
                </div>
                <div class="cards" id="playerHand"></div>
                <div class="controls">
                    <button id="actionButton" onclick="performAction()">Discard Card</button>
                </div>
            </div>

            <!-- Computer hand section -->
            <div class="hand-section" id="computerHandSection">
                <div class="hand-title">
                    Marta's Hand (hidden)
                    <!-- Only show toggle button if debug mode is enabled -->
                    <button id="toggleComputerHand" onclick="toggleComputerHand()" style="display: none;">Show
                        Cards</button>
                </div>
                <div class="cards" id="computerHand"></div>
            </div>
        </div>

        <!-- Bottom navigation -->
        <div class="bottom-section">
            <button class="bottom-new-game-btn" onclick="startNewGame()">New Game</button>
            <button class="bottom-rules-btn"
                onclick="window.open('https://docs.google.com/spreadsheets/d/1uxxzX09zhGm0b8R48Fi4vHvOEyrlp1AmVN-sN41voj0/edit?usp=sharing', '_blank')">Rules</button>
        </div>
    </div>

    <script src="{{ url_for('static', filename='game.js') }}"></script>
</body>

</html>

================================================================================

