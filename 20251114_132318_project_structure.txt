Number of files: 24
Number of directories: 5

Directory structure:
.
static
templates
utilities
utilities/__pycache__

List of file paths by type:

HTML Files (3):
  ./templates/index.html
  ./templates/instructions.html
  ./templates/stats.html

JS Files (1):
  ./static/game.js

PY Files (20):
  ./app.py
  ./gather_pythons.py
  ./gcloud_deploy.py
  ./jobs.py
  ./test_ip.py
  ./test_ip2.py
  ./test_ip3.py
  ./test_minimal.py
  ./test_monthly.py
  ./test_postg.py
  ./test_save_ip.py
  ./test_stats.py
  ./utilities/app_helpers.py
  ./utilities/claude_utils.py
  ./utilities/computer_logic.py
  ./utilities/custom_rules.py
  ./utilities/gameplay_logic.py
  ./utilities/gmail_utils.py
  ./utilities/logging_utils.py
  ./utilities/postgres_utils.py

================================================================================
FILE CONTENTS
================================================================================

FILE: ./gcloud_deploy.py
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Deployment script for Two Man Spades
This script manages deployment to Google App Engine for twomanspades project.
"""

import subprocess
import json
import time
import os
import sys
import random
import string

# Configuration - TWO MAN SPADES PROJECT SPECIFIC
EXPECTED_PROJECT_ID = "twomanspades"  # Critical: This must match your project
SERVICE_NAME = "default"
VERSION_MAX = 15  # Keep 15 versions to minimize storage costs

def print_separator():
    """Print a visual separator in console output."""
    print("\n" + "="*70 + "\n")

def check_gcloud_project():
    """Verify we're using the correct GCP project - CRITICAL SAFEGUARD."""
    print_separator()
    print("üîí VERIFYING GOOGLE CLOUD PROJECT CONFIGURATION...")
    print(f"Expected project: {EXPECTED_PROJECT_ID}")
    
    try:
        current_project = subprocess.run(
            ["gcloud", "config", "get-value", "project"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True
        ).stdout.decode().strip()
        
        print(f"Current project:  {current_project}")
        
        if current_project != EXPECTED_PROJECT_ID:
            print(f"‚ùå ERROR: Current gcloud project is '{current_project}' but expected '{EXPECTED_PROJECT_ID}'")
            print(f"üîÑ Attempting to switch to the correct project...")
            
            # Try to use an existing configuration first
            try:
                configs_result = subprocess.run(
                    ["gcloud", "config", "configurations", "list", "--format=value(name)"],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True
                )
                configs = configs_result.stdout.decode().strip().split('\n')
                
                if "twomanspades-config" in configs:
                    print("üìã Using existing twomanspades-config configuration")
                    subprocess.run(
                        ["gcloud", "config", "configurations", "activate", "twomanspades-config"],
                        check=True
                    )
                else:
                    print("‚öôÔ∏è  Setting project directly")
                    subprocess.run(
                        ["gcloud", "config", "set", "project", EXPECTED_PROJECT_ID],
                        check=True
                    )
            except subprocess.CalledProcessError:
                print("‚öôÔ∏è  Setting project directly")
                subprocess.run(
                    ["gcloud", "config", "set", "project", EXPECTED_PROJECT_ID],
                    check=True
                )
            
            # CRITICAL: Verify the switch was successful
            current_project = subprocess.run(
                ["gcloud", "config", "get-value", "project"],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True
            ).stdout.decode().strip()
            
            if current_project != EXPECTED_PROJECT_ID:
                print(f"‚ùå CRITICAL ERROR: Failed to switch to project {EXPECTED_PROJECT_ID}")
                print("üõë DEPLOYMENT ABORTED to prevent deploying to wrong project!")
                print("")
                print("Please manually set the project with one of these commands:")
                print(f"  gcloud config configurations activate twomanspades-config")
                print(f"  gcloud config set project {EXPECTED_PROJECT_ID}")
                print("")
                print("Then re-run this script.")
                sys.exit(1)
            else:
                print(f"‚úÖ Successfully switched to project {EXPECTED_PROJECT_ID}")
        else:
            print(f"‚úÖ Project verification passed - correctly configured for {EXPECTED_PROJECT_ID}")
    
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Error checking Google Cloud project: {e}")
        print("üõë DEPLOYMENT ABORTED")
        sys.exit(1)

# Function to get versions of a service
def get_versions(service_name):
    """Fetch the current versions of the App Engine service."""
    print(f"üìã Checking existing versions for service: {service_name}...")
    try:
        result = subprocess.run(
            ["gcloud", "app", "versions", "list", 
             "--service", service_name, 
             "--format", "json", 
             "--project", EXPECTED_PROJECT_ID],  # Always specify project
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        versions = json.loads(result.stdout)
        versions.sort(key=lambda x: x["version"]["createTime"], reverse=True)
        return versions
    except subprocess.CalledProcessError as e:
        if "Service not found" in e.stderr.decode() or f"Service [{service_name}] not found" in e.stderr.decode():
            print(f"üìù Service {service_name} not found. It will be created during deployment.")
            return []
        else:
            print(f"‚ùå Error getting versions: {e.stderr.decode()}")
            raise e

# Function to delete versions
def delete_old_versions(service_name, versions_to_delete):
    """Delete older versions to maintain version limit."""
    if not versions_to_delete:
        return
    
    print(f"üßπ Cleaning up old versions. Deleting {len(versions_to_delete)} older versions...")
    
    for v in versions_to_delete:
        version_id = v["id"]
        print(f"  - Deleting version {service_name}-{version_id}")
        subprocess.run(
            ["gcloud", "app", "versions", "delete", version_id, 
             "--service", service_name, 
             "--quiet", 
             "--project", EXPECTED_PROJECT_ID],  # Always specify project
            check=True)
    
    print("‚úÖ Cleanup complete.")

# Function to get changed files using git diff
def get_changed_files(directory):
    """Get list of new or modified files using git diff"""
    try:
        result = subprocess.run(
            ["git", "-C", directory, "diff", "--name-only", "HEAD^", "HEAD"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        files = result.stdout.decode().strip().split("\n")
        return [os.path.join(directory, f) for f in files if f]
    except subprocess.CalledProcessError:
        print("‚ÑπÔ∏è  Error determining changed files (this is normal for first deployment).")
        return []

def list_files_to_upload():
    """List files that will be uploaded to Google Cloud Storage."""
    print("üìÅ Files to be uploaded:")
    
    # Fallback: manually parse .gcloudignore and list files
    ignored_patterns = set()
    if os.path.exists('.gcloudignore'):
        with open('.gcloudignore', 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    ignored_patterns.add(line.rstrip('/'))
    
    # Default ignore patterns if no .gcloudignore exists
    if not ignored_patterns:
        ignored_patterns = {
            '.git',  'logging', '__pycache__', '*.pyc', '.env', 'venv*', 
            '.vscode', '.idea', '*.md', 'gather_pythons.py', 
            '*_project_structure.txt'
        }
    
    # Walk directory and respect .gcloudignore patterns
    files_to_upload = []
    for root, dirs, files in os.walk('.'):
        # Remove ignored directories from dirs to prevent walking into them
        dirs[:] = [d for d in dirs if not any(
            d == pattern or f"{root}/{d}".startswith(f"./{pattern}")
            for pattern in ignored_patterns
        )]
        
        for file in files:
            rel_path = os.path.relpath(os.path.join(root, file), '.')
            # Skip if file matches any ignore pattern
            if not any(
                rel_path.startswith(pattern) or file.endswith(pattern.lstrip('*'))
                for pattern in ignored_patterns
            ):
                files_to_upload.append(rel_path)
    
    # Print the files
    for file in sorted(files_to_upload):
        print(f"  - {file}")
    
    print(f"\nüìä Total files to upload: {len(files_to_upload)}")

# Function to generate a valid version name
def generate_version_name():
    random_string = ''.join(random.choices(string.ascii_lowercase + string.digits, k=10))
    return f"version-{random_string}"

# Function to deploy the services
def deploy_service(service_name, yaml_path):
    """Deploy the application to Google App Engine."""
    start_time = time.time()
    current_directory = os.path.dirname(os.path.abspath(yaml_path))
    
    print_separator()
    print(f"üöÄ DEPLOYING TWO MAN SPADES TO GOOGLE APP ENGINE")
    print(f"üì¶ Project: {EXPECTED_PROJECT_ID}")
    print(f"‚öôÔ∏è  Service: {service_name}")
    print(f"üìÇ Deploy from: {current_directory}")
    print(f"üìÑ Using config: {yaml_path}")
    print_separator()
    
    # List changed files
    print("üìù Listing new or modified files to be uploaded:")
    changed_files = get_changed_files(current_directory)
    if changed_files:
        for file_path in changed_files:
            print(f"  üìÑ Changed file: {file_path}")
    else:
        print("  ‚ÑπÔ∏è  No new or modified files detected (normal for first deployment).")
    
    # Check the current versions
    try:
        versions = get_versions(service_name)
        print(f"‚úÖ {len(versions)} versions retrieved successfully.")
    except subprocess.CalledProcessError as e:
        versions = []
        print(f"‚ö†Ô∏è  Failed to get versions. Error: {e}")
        print(f"üìù First deployment for service {service_name}. Proceeding with deployment.")
    
    print(f"üìä You currently have {len(versions)} versions for {service_name}.")
    if versions:
        print(f"üìã The latest version is {versions[0]['id']} for {service_name}.")
    
    if len(versions) > VERSION_MAX:
        print(f"üßπ More than {VERSION_MAX} versions exist for {service_name}.")
    
    # Show files that will be uploaded
    print_separator()
    list_files_to_upload()
    
    # Deploy new version
    print_separator()
    version_name = generate_version_name()
    print(f"üöÄ Deploying new version: {version_name}")
    try:
        result = subprocess.run([
            "gcloud", "app", "deploy", yaml_path, 
            "--quiet", 
            "--project", EXPECTED_PROJECT_ID,  # Always specify project
            "--version", version_name
        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        print("‚úÖ Deployment successful!")
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Failed to deploy new version. Error: {e.stderr.decode()}")
        return  # Early exit if deployment fails
    
    # Delete old versions if needed
    if len(versions) > VERSION_MAX:
        print_separator()
        try:
            # Get fresh list of versions after deployment
            updated_versions = get_versions(service_name)
            versions_to_delete = updated_versions[VERSION_MAX:]
            delete_old_versions(service_name, versions_to_delete)
        except subprocess.CalledProcessError as e:
            print(f"‚ö†Ô∏è  Failed to delete old versions. Error: {e.stderr.decode()}")

    # Calculate and display execution time
    end_time = time.time()
    execution_time = end_time - start_time
    
    # Display the target URL
    print_separator()
    print(f"‚è±Ô∏è  Deployment completed in {execution_time:.2f} seconds.")
    print(f"üåê Your Two Man Spades game is now live at:")
    print(f"  - https://{EXPECTED_PROJECT_ID}.appspot.com")
    print_separator()

# Main deployment function
def main_deploy():
    # CRITICAL: Verify project before doing ANYTHING
    check_gcloud_project()
    
    # Deploy the service
    deploy_service(SERVICE_NAME, 'app.yaml')
    
    # Automatically tail logs
    print(f"\nüìã Tailing logs... (Press Ctrl+C to stop)")
    try:
        subprocess.run([
            "gcloud", "app", "logs", "tail",
            "--service", SERVICE_NAME,
            "--project", EXPECTED_PROJECT_ID  # Always specify project
        ])
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è  Stopped tailing logs.")
        print(f"üìã You can view logs anytime with: gcloud app logs tail -s {SERVICE_NAME} --project {EXPECTED_PROJECT_ID}")

if __name__ == "__main__":
    print(f"üîí You have chosen to keep {VERSION_MAX} versions of your app.")
    main_deploy()

================================================================================

FILE: ./test_stats.py
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Test script to debug stats page data queries
Run this sibling to app.py to test database connections and data retrieval
"""

import sys
import os
import json

# Add the current directory to path to import utilities
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

try:
    from utilities.postgres_utils import get_db_connection
    print("‚úÖ Successfully imported postgres_utils")
except ImportError as e:
    print(f"‚ùå Failed to import postgres_utils: {e}")
    sys.exit(1)

def test_database_connection():
    """Test basic database connection"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT 1")
        result = cur.fetchone()
        cur.close()
        conn.close()
        print("‚úÖ Database connection successful")
        return True
    except Exception as e:
        print(f"‚ùå Database connection failed: {e}")
        return False

def test_competitive_leaders_query():
    """Test the competitive leaders query directly"""
    print("\nüîç Testing Competitive Leaders Query...")
    print("=" * 50)
    
    try:
        conn = get_db_connection()
        
        # Try to use RealDictCursor for better output
        try:
            import psycopg2.extras
            cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
            dict_cursor = True
        except:
            cur = conn.cursor()
            dict_cursor = False
            print("‚ö†Ô∏è  Using regular cursor (no RealDictCursor available)")
        
        # First, check if the view exists
        cur.execute("""
            SELECT table_name FROM information_schema.views 
            WHERE table_schema = 'twomanspades' 
            AND table_name = 'vw_city_leaders'
        """)
        view_exists = cur.fetchone()
        
        if not view_exists:
            print("‚ùå View 'vw_city_leaders' does not exist")
            cur.close()
            conn.close()
            return []
        
        print("‚úÖ View 'vw_city_leaders' exists")
        
        # Now query the actual data
        cur.execute("""
            SELECT * FROM twomanspades.vw_city_leaders 
            ORDER BY total_games DESC, total_wins DESC
        """)
        
        results = cur.fetchall()
        
        print(f"üìä Query returned {len(results)} rows")
        
        if dict_cursor:
            data = [dict(row) for row in results]
        else:
            # Get column names for regular cursor
            col_names = [desc[0] for desc in cur.description]
            data = [dict(zip(col_names, row)) for row in results]
        
        cur.close()
        conn.close()
        
        # Print the results nicely
        for i, row in enumerate(data, 1):
            print(f"\n--- Row {i} ---")
            for key, value in row.items():
                print(f"  {key}: {value}")
        
        return data
        
    except Exception as e:
        print(f"‚ùå Competitive leaders query failed: {e}")
        import traceback
        traceback.print_exc()
        return []

def test_detailed_leaders_query():
    """Test the detailed leaders query directly"""
    print("\nüîç Testing Detailed Leaders Query...")
    print("=" * 50)
    
    try:
        conn = get_db_connection()
        
        # Try to use RealDictCursor for better output
        try:
            import psycopg2.extras
            cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
            dict_cursor = True
        except:
            cur = conn.cursor()
            dict_cursor = False
            print("‚ö†Ô∏è  Using regular cursor (no RealDictCursor available)")
        
        # First, check if the view exists
        cur.execute("""
            SELECT table_name FROM information_schema.views 
            WHERE table_schema = 'twomanspades' 
            AND table_name = 'vw_city_leaders_totals'
        """)
        view_exists = cur.fetchone()
        
        if not view_exists:
            print("‚ùå View 'vw_city_leaders_totals' does not exist")
            cur.close()
            conn.close()
            return []
        
        print("‚úÖ View 'vw_city_leaders_totals' exists")
        
        # Now query the actual data
        cur.execute("""
            SELECT * FROM twomanspades.vw_city_leaders_totals 
            ORDER BY total_hands_with_bids DESC
        """)
        
        results = cur.fetchall()
        
        print(f"üìä Query returned {len(results)} rows")
        
        if dict_cursor:
            data = [dict(row) for row in results]
        else:
            # Get column names for regular cursor
            col_names = [desc[0] for desc in cur.description]
            data = [dict(zip(col_names, row)) for row in results]
        
        cur.close()
        conn.close()
        
        # Print the results nicely
        for i, row in enumerate(data, 1):
            print(f"\n--- Row {i} ---")
            for key, value in row.items():
                print(f"  {key}: {value}")
        
        return data
        
    except Exception as e:
        print(f"‚ùå Detailed leaders query failed: {e}")
        import traceback
        traceback.print_exc()
        return []

def test_functions():
    """Test the actual functions from postgres_utils"""
    print("\nüîç Testing postgres_utils Functions...")
    print("=" * 50)
    
    try:
        from utilities.postgres_utils import get_competitive_leaders_stats, get_city_leaders_stats
        
        print("Testing get_competitive_leaders_stats()...")
        competitive_data = get_competitive_leaders_stats()
        print(f"‚úÖ Returned {len(competitive_data)} competitive records")
        
        print("\nTesting get_city_leaders_stats()...")
        detailed_data = get_city_leaders_stats()
        print(f"‚úÖ Returned {len(detailed_data)} detailed records")
        
        return competitive_data, detailed_data
        
    except ImportError as e:
        print(f"‚ùå Cannot import functions: {e}")
        return [], []
    except Exception as e:
        print(f"‚ùå Function test failed: {e}")
        import traceback
        traceback.print_exc()
        return [], []

def list_available_views():
    """List all views in the twomanspades schema"""
    print("\nüîç Available Views in twomanspades Schema...")
    print("=" * 50)
    
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        cur.execute("""
            SELECT table_name, view_definition 
            FROM information_schema.views 
            WHERE table_schema = 'twomanspades'
            ORDER BY table_name
        """)
        
        results = cur.fetchall()
        
        for table_name, view_def in results:
            print(f"üìã View: {table_name}")
            # Truncate view definition for readability
            short_def = view_def[:100] + "..." if len(view_def) > 100 else view_def
            print(f"   Definition: {short_def}")
            print()
        
        cur.close()
        conn.close()
        
        return [row[0] for row in results]
        
    except Exception as e:
        print(f"‚ùå Failed to list views: {e}")
        return []

def main():
    """Main test function"""
    print("üöÄ Two-Man Spades Stats Database Tester")
    print("=" * 60)
    
    # Test 1: Basic connection
    if not test_database_connection():
        return
    
    # Test 2: List available views
    views = list_available_views()
    
    # Test 3: Test direct queries
    competitive_data = test_competitive_leaders_query()
    detailed_data = test_detailed_leaders_query()
    
    # Test 4: Test the actual functions
    func_competitive, func_detailed = test_functions()
    
    # Summary
    print("\n" + "=" * 60)
    print("üìä SUMMARY")
    print("=" * 60)
    print(f"Available views: {len(views)}")
    print(f"Direct competitive query: {len(competitive_data)} rows")
    print(f"Direct detailed query: {len(detailed_data)} rows")
    print(f"Function competitive results: {len(func_competitive)} rows")
    print(f"Function detailed results: {len(func_detailed)} rows")
    
    if len(competitive_data) == 0:
        print("\n‚ùå ISSUE: Competitive data is empty")
        print("   - Check if vw_city_leaders view has data")
        print("   - Verify the view definition includes win/loss columns")
    
    if len(detailed_data) > 0 and len(func_detailed) == 0:
        print("\n‚ùå ISSUE: Function returns empty but direct query works")
        print("   - Check get_city_leaders_stats() function definition")
    
    print("\n‚ú® Test complete!")

if __name__ == "__main__":
    main()

================================================================================

FILE: ./test_save_ip.py
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Import IP location data from CSV to database
Only inserts unique IP addresses that don't already exist
"""

import csv
import os
import sys
from typing import Dict, Any, List

# Add the current directory to path to import utilities
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

try:
    from utilities.postgres_utils import get_db_connection, save_ip_location_data
    print("‚úÖ Successfully imported postgres_utils")
except ImportError as e:
    print(f"‚ùå Failed to import postgres_utils: {e}")
    print("Make sure you're running this script from the same directory as app.py")
    sys.exit(1)

def get_existing_ips() -> set:
    """Get all IP addresses that already exist in the database"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        cur.execute("SELECT ip_address FROM twomanspades.ip_location_data")
        existing_ips = {row[0] for row in cur.fetchall()}
        
        cur.close()
        conn.close()
        
        print(f"üìä Found {len(existing_ips)} existing IP addresses in database")
        return existing_ips
        
    except Exception as e:
        print(f"‚ùå Error getting existing IPs: {e}")
        return set()

def read_csv_data(filename: str) -> List[Dict[str, Any]]:
    """Read IP location data from CSV file"""
    csv_path = os.path.join(os.path.dirname(__file__), filename)
    
    if not os.path.exists(csv_path):
        print(f"‚ùå CSV file not found: {csv_path}")
        return []
    
    try:
        with open(csv_path, 'r', encoding='utf-8') as csvfile:
            # Use DictReader to automatically handle headers
            reader = csv.DictReader(csvfile)
            
            data = []
            for row in reader:
                # Map CSV columns to our database fields
                location_data = {
                    'ip_address': row.get('ip_address', '').strip(),
                    'country': row.get('country', '').strip(),
                    'region': row.get('region', '').strip(), 
                    'city': row.get('city', '').strip(),
                    'lat': float(row.get('latitude', 0)) if row.get('latitude') else None,
                    'lon': float(row.get('longitude', 0)) if row.get('longitude') else None,
                    'timezone': row.get('timezone', '').strip(),
                    'zip': row.get('zip_code', '').strip(),
                    'isp': row.get('isp', '').strip(),
                    'org': row.get('org', '').strip(),
                    'as': row.get('as_number', '').strip() + ' ' + row.get('as_name', '').strip()
                }
                
                # Only add if we have an IP address
                if location_data['ip_address']:
                    data.append(location_data)
            
            print(f"‚úÖ Read {len(data)} records from CSV")
            return data
            
    except Exception as e:
        print(f"‚ùå Error reading CSV file: {e}")
        return []

def import_unique_ips(csv_filename: str = "data.csv") -> bool:
    """Import IP location data from CSV, only inserting unique IPs"""
    
    print("üåç Starting IP Location Data Import")
    print("=" * 50)
    
    # Get existing IPs from database
    existing_ips = get_existing_ips()
    
    # Read CSV data
    csv_data = read_csv_data(csv_filename)
    if not csv_data:
        return False
    
    # Filter out IPs that already exist
    new_ips = []
    skipped_count = 0
    
    for record in csv_data:
        ip_address = record['ip_address']
        if ip_address not in existing_ips:
            new_ips.append(record)
        else:
            skipped_count += 1
    
    print(f"üìä Import Summary:")
    print(f"   - Total IPs in CSV: {len(csv_data)}")
    print(f"   - Already in database: {skipped_count}")
    print(f"   - New IPs to import: {len(new_ips)}")
    
    if not new_ips:
        print("‚úÖ No new IPs to import - all already exist in database")
        return True
    
    # Import new IPs
    success_count = 0
    error_count = 0
    
    print(f"\nüîÑ Importing {len(new_ips)} new IP records...")
    
    for i, record in enumerate(new_ips, 1):
        ip_address = record['ip_address']
        
        # Use the existing save_ip_location_data function
        if save_ip_location_data(ip_address, record):
            success_count += 1
            print(f"[{i:3}/{len(new_ips)}] ‚úÖ {ip_address[:15]:<15} -> {record.get('city', 'Unknown')}, {record.get('country', 'Unknown')}")
        else:
            error_count += 1
            print(f"[{i:3}/{len(new_ips)}] ‚ùå {ip_address[:15]:<15} -> Failed to insert")
    
    print(f"\nüìä Import Results:")
    print(f"   - Successfully imported: {success_count}")
    print(f"   - Failed imports: {error_count}")
    print(f"   - Success rate: {success_count/len(new_ips)*100:.1f}%")
    
    return error_count == 0

def verify_import(sample_size: int = 5) -> None:
    """Verify the import by checking a few random records"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        cur.execute("""
            SELECT ip_address, city, region, country, isp 
            FROM twomanspades.ip_location_data 
            WHERE lookup_success = true
            ORDER BY created_at DESC 
            LIMIT %s
        """, (sample_size,))
        
        results = cur.fetchall()
        cur.close()
        conn.close()
        
        if results:
            print(f"\nüîç Recent imports verification (last {len(results)} records):")
            print("-" * 70)
            for ip, city, region, country, isp in results:
                location = f"{city}, {region}, {country}"
                print(f"{ip[:15]:<15} | {location[:30]:<30} | {isp[:20]}")
        
    except Exception as e:
        print(f"‚ùå Verification failed: {e}")

def main():
    """Main execution function"""
    
    # Test database connection first
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT 1")
        cur.close()
        conn.close()
        print("‚úÖ Database connection successful")
    except Exception as e:
        print(f"‚ùå Database connection failed: {e}")
        return
    
    # Import the data
    success = import_unique_ips("data.csv")
    
    if success:
        # Verify the import
        verify_import()
        print("\n‚ú® IP location data import completed successfully!")
    else:
        print("\n‚ùå Import completed with errors")

if __name__ == "__main__":
    main()

================================================================================

FILE: ./test_postg.py
--------------------------------------------------------------------------------
# test_game_logging.py
from utilities.postgres_utils import insert_game, log_game_event_to_db
import time

# Test game data
test_game = {
    'game_id': f'test_{int(time.time())}',
    'game_started_at': time.time(),
    'player_parity': 'even',
    'computer_parity': 'odd',
    'first_leader': 'player',
    'client_info': {'ip_address': '127.0.0.1', 'user_agent': 'test'}
}

# Test inserting game
if insert_game(test_game):
    print("Game inserted successfully!")
    
    # Test logging an event
    if log_game_event_to_db(
        test_game['game_id'],
        'test_event',
        {'action': 'card_play', 'card': 'A‚ô†'},
        hand_number=1,
        session_sequence=1,
        player='player',
        action_type='card_play'
    ):
        print("Event logged successfully!")
    else:
        print("Event logging failed")
else:
    print("Game insertion failed")

================================================================================

FILE: ./jobs.py
--------------------------------------------------------------------------------
import requests
from bs4 import BeautifulSoup
import re

def scrape_mudbay_jobs():
    url = "https://www.indeed.com/cmp/Mud-Bay/jobs"
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
    }
    
    try:
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        soup = BeautifulSoup(response.text, 'html.parser')
        
        jobs = []
        job_cards = soup.find_all('div', class_='jobsearch-JobCard')
        
        for card in job_cards:
            title = card.find('h2', class_='jobsearch-JobInfoHeader-title').text.strip() if card.find('h2', class_='jobsearch-JobInfoHeader-title') else "N/A"
            location = card.find('div', class_='jobsearch-JobMetadataHeader-location').text.strip() if card.find('div', class_='jobsearch-JobMetadataHeader-location') else "N/A"
            salary = card.find('div', class_='jobsearch-JobMetadataHeader-salary').text.strip() if card.find('div', class_='jobsearch-JobMetadataHeader-salary') else "N/A"
            job_type = card.find('div', class_='jobsearch-JobMetadataHeader-jobType').text.strip() if card.find('div', class_='jobsearch-JobMetadataHeader-jobType') else "N/A"
            
            jobs.append({
                'title': title,
                'location': location,
                'salary': salary,
                'job_type': job_type
            })
        
        return jobs
    
    except requests.RequestException as e:
        print(f"Error fetching page: {e}")
        return []

def main():
    jobs = scrape_mudbay_jobs()
    if jobs:
        for job in jobs:
            print(f"Title: {job['title']}")
            print(f"Location: {job['location']}")
            print(f"Salary: {job['salary']}")
            print(f"Job Type: {job['job_type']}")
            print("-" * 40)
    else:
        print("No jobs found or an error occurred.")

if __name__ == "__main__":
    main()

================================================================================

FILE: ./test_ip.py
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Test script to geolocate all IP addresses from the Two-Man Spades database
Uses ip-api.com free service to lookup locations for all unique player IPs
"""

import sys
import os
import time
import urllib.request
import urllib.error
import json
from collections import defaultdict

# Add the current directory to path to import utilities
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

try:
    from utilities.postgres_utils import get_db_connection, get_ip_address_game_stats
    print("‚úÖ Successfully imported postgres_utils")
except ImportError as e:
    print(f"‚ùå Failed to import postgres_utils: {e}")
    print("Make sure you're running this script from the same directory as app.py")
    sys.exit(1)

def get_top_players_stats():
    """Get top 10 players from your existing stats view"""
    try:
        # Use your existing function to get all player stats
        all_stats = get_ip_address_game_stats()
        
        # Filter out any with no games and take top 10
        valid_stats = [stat for stat in all_stats if stat.get('total_games', 0) > 0]
        top_10 = valid_stats[:10]
        
        # Convert to format we need (ip, games, first_seen, last_seen)
        formatted_data = []
        for stat in top_10:
            formatted_data.append((
                stat['client_ip'],
                stat['total_games'],
                stat.get('first_game'),  # These are already datetime objects
                stat.get('last_game')
            ))
        
        return formatted_data, len(all_stats)
        
    except Exception as e:
        print(f"‚ùå Error getting player stats: {e}")
        return [], 0

def get_all_unique_ips():
    """Get all unique IP addresses with their game counts and timestamps"""
    try:
        # Use your existing function to get all player stats
        all_stats = get_ip_address_game_stats()
        
        # Filter out any with no games
        valid_stats = [stat for stat in all_stats if stat.get('total_games', 0) > 0]
        
        # Convert to format we need (ip, games, first_seen, last_seen)
        formatted_data = []
        for stat in valid_stats:
            formatted_data.append((
                stat['client_ip'],
                stat['total_games'],
                stat.get('first_game'),  # These are already datetime objects
                stat.get('last_game')
            ))
        
        # Sort by game count (descending) to get most active first
        formatted_data.sort(key=lambda x: x[1], reverse=True)
        
        return formatted_data
        
    except Exception as e:
        print(f"‚ùå Error getting IP addresses: {e}")
        return []

def geolocate_ip(ip_address):
    """
    Use ip-api.com free service to geolocate an IP address
    Returns dict with location info or None if failed
    """
    try:
        # Free API endpoint - no key needed
        url = f"http://ip-api.com/json/{ip_address}"
        
        # Make request with timeout using urllib
        request = urllib.request.Request(url)
        request.add_header('User-Agent', 'TwoManSpades-GeoTest/1.0')
        
        with urllib.request.urlopen(request, timeout=5) as response:
            if response.getcode() == 200:
                data = json.loads(response.read().decode('utf-8'))
                
                # Check if the lookup was successful
                if data.get('status') == 'success':
                    return {
                        'country': data.get('country', 'Unknown'),
                        'region': data.get('regionName', 'Unknown'),
                        'city': data.get('city', 'Unknown'),
                        'isp': data.get('isp', 'Unknown'),
                        'lat': data.get('lat', 0),
                        'lon': data.get('lon', 0),
                        'timezone': data.get('timezone', 'Unknown'),
                        'zip': data.get('zip', 'Unknown')
                    }
                else:
                    print(f"  ‚ö†Ô∏è  API returned failure for {ip_address}: {data.get('message', 'Unknown error')}")
                    return None
            else:
                print(f"  ‚ùå HTTP error {response.getcode()} for {ip_address}")
                return None
            
    except urllib.error.URLError as e:
        if hasattr(e, 'reason'):
            if 'timeout' in str(e.reason).lower():
                print(f"  ‚è±Ô∏è  Timeout for {ip_address}")
            else:
                print(f"  ‚ùå URL error for {ip_address}: {e.reason}")
        else:
            print(f"  ‚ùå URL error for {ip_address}: {e}")
        return None
    except json.JSONDecodeError:
        print(f"  ‚ùå Invalid JSON response for {ip_address}")
        return None
    except Exception as e:
        print(f"  ‚ùå Unexpected error for {ip_address}: {e}")
        return None

def format_ip_for_display(ip):
    """Format IP for privacy (show first 3 and last 3 chars)"""
    if len(ip) <= 6:
        return ip  # Too short to mask
    return f"{ip[:3]}***{ip[-3:]}"

def main():
    print("üåç Two-Man Spades IP Geolocation Test")
    print("=" * 50)
    
    # Test database connection first
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT 1")
        cur.close()
        conn.close()
        print("‚úÖ Database connection successful")
    except Exception as e:
        print(f"‚ùå Database connection failed: {e}")
        return
    
    # Get all unique IPs
    print("\nüìã Fetching unique IP addresses from database...")
    ip_data = get_all_unique_ips()
    
    if not ip_data:
        print("‚ùå No IP addresses found in database")
        return
    
    total_players = len(ip_data)  # Define total_players here
    print(f"‚úÖ Found {total_players} unique IP addresses")
    
    # Limit to top 10 most active IPs
    top_ips = ip_data[:10]
    print(f"üéØ Focusing on top {len(top_ips)} most active players")
    print(f"üìä Rate limit: 45 requests/minute (will pace requests automatically)")
    
    # Initialize results storage
    results = []
    country_stats = defaultdict(int)
    region_stats = defaultdict(int)
    isp_stats = defaultdict(int)
    
    print("\nüîç Starting geolocation lookups for top players...")
    print("=" * 70)
    
    # Process only the top IPs, not all of them
    for i, (ip, games, first_seen, last_seen) in enumerate(top_ips, 1):
        print(f"\n[{i:2}/{len(top_ips)}] {format_ip_for_display(ip)} ({games} games)")
        if first_seen and last_seen:
            print(f"         First: {first_seen.strftime('%Y-%m-%d %H:%M')} | Last: {last_seen.strftime('%Y-%m-%d %H:%M')}")
        else:
            print(f"         First/Last: Unknown")
        
        # Rate limiting - free tier allows 45 requests/minute
        if i > 1:
            time.sleep(1.5)  # ~40 requests/minute to stay under limit
        
        # Geolocate the IP
        location = geolocate_ip(ip)
        
        if location:
            print(f"         üìç {location['city']}, {location['region']}, {location['country']}")
            print(f"         üåê ISP: {location['isp']}")
            print(f"         üïê Timezone: {location['timezone']}")
            
            # Store results
            result = {
                'ip': ip,
                'ip_display': format_ip_for_display(ip),
                'games': games,
                'first_seen': first_seen,
                'last_seen': last_seen,
                'location': location
            }
            results.append(result)
            
            # Update statistics
            country_stats[location['country']] += games
            region_key = f"{location['region']}, {location['country']}"
            region_stats[region_key] += games
            isp_stats[location['isp']] += games
            
        else:
            print(f"         ‚ùå Geolocation failed")
            # Store failed result
            result = {
                'ip': ip,
                'ip_display': format_ip_for_display(ip),
                'games': games,
                'first_seen': first_seen,
                'last_seen': last_seen,
                'location': None
            }
            results.append(result)
    
    # Print summary statistics
    print("\n" + "=" * 70)
    print("üìä GEOLOCATION SUMMARY")
    print("=" * 70)
    
    successful_lookups = len([r for r in results if r['location']])
    print(f"‚úÖ Successful lookups: {successful_lookups}/{len(results)} ({successful_lookups/len(results)*100:.1f}%)")
    
    print(f"\nüåç TOP COUNTRIES BY GAME ACTIVITY:")
    for country, games in sorted(country_stats.items(), key=lambda x: x[1], reverse=True):
        print(f"   {country:<20} {games:>3} games")
    
    print(f"\nüèôÔ∏è  TOP REGIONS BY GAME ACTIVITY:")
    for region, games in sorted(region_stats.items(), key=lambda x: x[1], reverse=True):
        print(f"   {region:<35} {games:>3} games")
    
    print(f"\nüîó TOP ISPs BY GAME ACTIVITY:")
    for isp, games in sorted(isp_stats.items(), key=lambda x: x[1], reverse=True):
        # Truncate long ISP names
        isp_display = isp[:40] + "..." if len(isp) > 40 else isp
        print(f"   {isp_display:<43} {games:>3} games")
    
    print(f"\nüéÆ TOP {len(results)} PLAYERS BY ACTIVITY:")
    print("-" * 70)
    for result in results:
        ip_display = result['ip_display']
        games = result['games']
        
        if result['location']:
            loc = result['location']
            location_str = f"{loc['city']}, {loc['region']}, {loc['country']}"
            print(f"{ip_display:<12} | {games:>3} games | {location_str}")
        else:
            print(f"{ip_display:<12} | {games:>3} games | Location unknown")
    
    total_games_top10 = sum(r['games'] for r in results)
    
    print(f"\nüéØ TOP 10 TOTALS: {len(results)} players, {total_games_top10} games")
    print(f"üåç ALL PLAYERS: {total_players} players total")
    print(f"üìà Top 10 represent a significant portion of all game activity")
    
    print("\n‚ú® Geolocation test complete!")

if __name__ == "__main__":
    main()

================================================================================

FILE: ./test_minimal.py
--------------------------------------------------------------------------------
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return 'Minimal test works'


================================================================================

FILE: ./app.py
--------------------------------------------------------------------------------
from flask import Flask, render_template, request, session, jsonify
import sys
import os
import time
import traceback

# Add utilities directory to path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# Import all helper functions
from utilities.app_helpers import (
    check_content_filter, track_request_session, 
    initialize_new_game_session, process_new_game_request,
    build_safe_game_state, process_bidding_phase, process_blind_bid_phase,
    process_discard_phase, resolve_trick_with_delay,
    computer_follow_with_logging, computer_lead_with_logging,
    process_hand_completion, process_auto_resolution,
    start_development_server, process_ip_geolocation
)
from utilities.gameplay_logic import is_valid_play, init_new_hand
from utilities.logging_utils import log_action, log_game_event, get_client_ip, start_async_db_logging, IS_PRODUCTION
from utilities.postgres_utils import get_ip_address_game_stats, get_city_leaders_stats, get_competitive_leaders_stats, get_monthly_stats_by_location
from utilities.gmail_utils import send_simple_email


app = Flask(__name__)
app.secret_key = 'a-super-secret-key-change-this-or-dont-whatever-its-spades-man'


# Initialize async logging for production immediately when module loads
if IS_PRODUCTION:
    start_async_db_logging()
    print("[STARTUP] Async database logging initialized")

DEBUG_MODE = False
session_tracker = {}

# Error notification system
LAST_ERROR_EMAIL_TIME = {}  # Track when we last emailed about each error type

@app.errorhandler(Exception)
def handle_error(error):
    """Catch all errors and email notifications"""
    error_type = type(error).__name__
    error_message = str(error)
    error_key = f"{error_type}_{error_message[:50]}"  # Unique key for this error
    
    # Rate limiting: only email once per hour per error type
    current_time = time.time()
    last_email_time = LAST_ERROR_EMAIL_TIME.get(error_key, 0)
    
    if current_time - last_email_time > 3600:  # 3600 seconds = 1 hour
        LAST_ERROR_EMAIL_TIME[error_key] = current_time
        
        # Get request context
        endpoint = request.endpoint or 'unknown'
        client_ip = get_client_ip(request)
        
        # Get game state if available
        game_state = "No game in session"
        if 'game' in session:
            game = session['game']
            game_state = f"""
Hand #{game.get('hand_number', '?')}
Phase: {game.get('phase', '?')}
Player Score: {game.get('player_score', '?')}
Computer Score: {game.get('computer_score', '?')}
Player Bid: {game.get('player_bid', '?')}
Computer Bid: {game.get('computer_bid', '?')}
pending_discard_result: {game.get('pending_discard_result', 'NOT SET')}
blind_decision_made: {game.get('blind_decision_made', 'NOT SET')}
"""
        
        # Build email body
        email_body = f"""
2MANSPADES ERROR DETECTED

Error Type: {error_type}
Error Message: {error_message}
Endpoint: {endpoint}
Player IP: {client_ip}
Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}

GAME STATE:
{game_state}

STACK TRACE:
{traceback.format_exc()}
"""
        
        # Send email (non-blocking, won't slow down response)
        try:
            send_simple_email(
                subject=f"[2MANSPADES BUG] {error_type} in {endpoint}",
                body=email_body,
                to_email="andy.tillo@gmail.com"  # YOUR EMAIL HERE
            )
            print(f"[ERROR EMAIL] Sent notification about {error_type} in {endpoint}")
        except Exception as email_error:
            print(f"[ERROR EMAIL] Failed to send: {email_error}")
    
    # Re-raise the error so normal logging still works
    raise error


@app.route('/debug_async_logging')
def debug_async_logging():
    """Debug endpoint to check async logging status"""
    from utilities.logging_utils import get_async_db_stats, IS_PRODUCTION
    
    stats = get_async_db_stats()
    
    return jsonify({
        'is_production': IS_PRODUCTION,
        'async_logging_enabled': IS_PRODUCTION,
        'worker_running': stats['worker_running'],
        'queue_size': stats['queue_size'],
        'operations_completed': stats['operations_completed'],
        'operations_failed': stats['operations_failed'],
        'queue_max_size': 1000
    })

@app.route('/')
def index():
    force_new = request.args.get('new', '').lower() == 'true'
    
    if force_new or 'game' not in session:
        session.clear()
        session['game'] = initialize_new_game_session(request)
        
        # ADD THIS: Trigger geolocation for new visitors
        client_info = track_request_session(session, request)
        if client_info and client_info.get('ip_address'):
            process_ip_geolocation(client_info['ip_address'])
    
    return render_template('index.html')

@app.route('/new_game', methods=['POST'])
def new_game():
    session['game'] = process_new_game_request(session, request)
    return jsonify({'success': True})

@app.route('/chat_response', methods=['POST'])
def chat_response():
    print("[CHAT] Received chat request")
    
    try:
        data = request.get_json()
        player_message = data.get('message', '')
        print(f"[CHAT] Player message: '{player_message}'")
        
        # Content filter check with working tinyurl filtering
        is_allowed, filter_message = check_content_filter(player_message)
        if not is_allowed:
            print(f"[CHAT] Message blocked by content filter")
            return jsonify({'response': filter_message})
        
        if 'game' in session:
            game_state = session['game']
            print(f"[CHAT] Game state found: Hand {game_state.get('hand_number', 1)}, Phase {game_state.get('phase', 'unknown')}")
            
            from utilities.claude_utils import get_smart_marta_response
            
            print("[CHAT] Calling Claude...")
            response = get_smart_marta_response(player_message, game_state)
            print(f"[CHAT] Final response: '{response}'")
            
            return jsonify({'response': response})
        else:
            print("[CHAT] No game session found")
            return jsonify({'response': 'Hi there! Start a game and let\'s chat!'})
            
    except Exception as e:
        print(f"[CHAT] Error: {e}")
        fallback_responses = [
            "That's interesting!",
            "I see what you mean...",
            "Good point!",
            "Let's focus on the game!",
            "Hmm, tell me more..."
        ]
        import random
        fallback = random.choice(fallback_responses)
        print(f"[CHAT] Using fallback: '{fallback}'")
        return jsonify({'response': fallback})

@app.route('/state')
def get_state():
    global session_tracker
    client_ip = get_client_ip(request)
    game_phase = session.get('game', {}).get('phase', 'no-game')
    
    session_tracker[client_ip] = {'last_seen': time.time(), 'phase': game_phase}
    
    cutoff = time.time() - 300
    active = {ip: data for ip, data in session_tracker.items() if data['last_seen'] > cutoff}
    session_tracker = active
    
    total_ips = len(active)
    print(f"ACTIVE: {total_ips} users | Current: {client_ip} ({game_phase})")
    if total_ips > 1:
        for ip, data in active.items():
            print(f"  {ip}: {data['phase']}")
    
    if 'game' not in session:
        session['game'] = initialize_new_game_session(request)
    
    game = session['game']
    safe_state = build_safe_game_state(game, DEBUG_MODE)
    
    return jsonify(safe_state)

@app.route('/toggle_computer_hand', methods=['POST'])
def toggle_computer_hand():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    if not DEBUG_MODE:
        return jsonify({'error': 'Debug mode disabled'}), 400
    
    game = session['game']
    game['show_computer_hand'] = not game.get('show_computer_hand', False)
    session.modified = True
    
    return jsonify({'success': True, 'showing': game['show_computer_hand']})

@app.route('/choose_blind_bidding', methods=['POST'])
def choose_blind_bidding():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    client_info = track_request_session(session, request)
    game = session['game']
    
    if game['phase'] != 'blind_decision':
        return jsonify({'error': 'Not in blind decision phase'}), 400
    
    log_action(
        action_type='blind_decision',
        player='player',
        action_data={'chose_blind': True, 'chose_normal': False},
        session=session,
        request=request
    )
    
    game['phase'] = 'blind_bidding'
    game['blind_decision_made'] = True  # CRITICAL: Mark decision as made
    game['message'] = 'Choose your blind bid amount (5-10 tricks). Double points if you make it, double penalty if you fail!'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/choose_normal_bidding', methods=['POST'])
def choose_normal_bidding():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    client_info = track_request_session(session, request)
    game = session['game']
    
    if game['phase'] != 'blind_decision':
        return jsonify({'error': 'Not in blind decision phase'}), 400
    
    log_action(
        action_type='blind_decision',
        player='player',
        action_data={'chose_blind': False, 'chose_normal': True},
        session=session,
        request=request
    )
    
    # CRITICAL FIX: Go to discard phase, not bidding phase
    # Player must discard before bidding
    game['phase'] = 'discard'
    game['blind_decision_made'] = True  # Mark decision as made
    game['message'] = 'You chose normal bidding. Select a card to discard.'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/blind_bid', methods=['POST'])
def make_blind_bid():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    client_info = track_request_session(session, request)
    game = session['game']
    data = request.get_json()
    bid = data.get('bid')
    
    if game['phase'] != 'blind_bidding':
        return jsonify({'error': 'Can only make blind bid during blind bidding phase'}), 400
    
    if bid < 5 or bid > 10:
        return jsonify({'error': 'Blind bid must be between 5 and 10'}), 400
    
    process_blind_bid_phase(game, session, bid, request)
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/choose_blind_nil', methods=['POST'])
def choose_blind_nil():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    game = session['game']
    if game['phase'] != 'blind_decision':
        return jsonify({'error': 'Not in blind decision phase'}), 400
    
    game['blind_bid'] = 0
    game['player_bid'] = 0
    game['blind_nil'] = True
    
    from utilities.computer_logic import computer_bidding_brain
    computer_bid, computer_is_blind = computer_bidding_brain(
        game['computer_hand'], 0, game
    )
    game['computer_bid'] = computer_bid
    if computer_is_blind:
        game['computer_blind_bid'] = computer_bid
    
    game['phase'] = 'discard'
    computer_text = f" Marta bid {computer_bid}{'(BLIND)' if computer_is_blind else ''}."
    game['message'] = f'BLIND NIL chosen! Win instantly with 0 tricks or lose the game!{computer_text} Select a card to discard.'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/bid', methods=['POST'])
def make_bid():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    client_info = track_request_session(session, request)
    game = session['game']
    data = request.get_json()
    bid = data.get('bid')
    
    if game['phase'] != 'bidding':
        return jsonify({'error': 'Not in bidding phase'}), 400
    
    if bid < 0 or bid > 10:
        return jsonify({'error': 'Bid must be between 0 and 10'}), 400
    
    process_bidding_phase(game, session, bid, request)
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/discard', methods=['POST'])
def discard_card():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    client_info = track_request_session(session, request)
    game = session['game']
    data = request.get_json()
    card_index = data.get('index')
    
    if game['phase'] != 'discard':
        return jsonify({'error': 'Not in discard phase'}), 400
    
    if card_index < 0 or card_index >= len(game['player_hand']):
        return jsonify({'error': 'Invalid card index'}), 400
    
    process_discard_phase(game, session, card_index, request)
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/play', methods=['POST'])
def play_card():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    client_info = track_request_session(session, request)
    game = session['game']
    data = request.get_json()
    card_index = data.get('index')
    
    if game['phase'] != 'playing':
        return jsonify({'error': 'Not in playing phase'}), 400
    
    if game['turn'] != 'player':
        return jsonify({'error': 'Not your turn'}), 400
    
    if card_index < 0 or card_index >= len(game['player_hand']):
        return jsonify({'error': 'Invalid card index'}), 400
    
    card = game['player_hand'][card_index]
    
    if not is_valid_play(card, game['player_hand'], game['current_trick'], game['spades_broken']):
        return jsonify({'error': 'Invalid play - must follow suit if possible'}), 400
    
    log_action(
        action_type='card_play',
        player='player', 
        action_data={
            'card_played': f"{card['rank']}{card['suit']}",
            'card_index': card_index,
            'trick_position': len(game['current_trick']) + 1,
            'leading': len(game['current_trick']) == 0
        },
        session=session,
        additional_context={
            'hand_size_before': len(game['player_hand']),
            'spades_broken_before': game['spades_broken']
        },
        request=request
    )
    
    game['player_hand'].pop(card_index)
    game['current_trick'].append({'player': 'player', 'card': card})
    
    if card['suit'] == '‚ô†':
        game['spades_broken'] = True
        log_game_event('spades_broken', {'broken_by': 'player', 'card': f"{card['rank']}{card['suit']}"}, session)
    
    if len(game['current_trick']) == 1:
        game['trick_leader'] = 'player'
        game['turn'] = 'computer'
        computer_follow_with_logging(game, session)
        resolve_trick_with_delay(game, session)
    elif len(game['current_trick']) == 2:
        resolve_trick_with_delay(game, session)
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/clear_trick', methods=['POST'])
def clear_trick():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    game = session['game']
    
    if not game.get('trick_completed'):
        return jsonify({'success': True, 'message': 'No trick to clear'}), 200
    
    winner = game.get('trick_winner')
    
    game['current_trick'] = []
    game['trick_completed'] = False
    game['trick_winner'] = None
    
    if len(game['player_hand']) == 0:
        game['hand_over'] = True
        process_hand_completion(game, session)
    elif len(game['player_hand']) > 0 and len(game['computer_hand']) > 0:
        auto_resolved = process_auto_resolution(game, session)
        
        if not auto_resolved:
            if winner == 'computer':
                computer_lead_with_logging(game, session)
                game['turn'] = 'player'
                game['message'] = 'Marta led. Your turn to follow.'
            else:
                game['turn'] = 'player'
                game['message'] = 'You won the trick! Your turn to lead.'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/next_hand', methods=['POST'])
def next_hand():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    client_info = track_request_session(session, request)
    game = session['game']
    
    if not game.get('hand_over', False) or game.get('game_over', False):
        return jsonify({'error': 'Cannot start next hand'}), 400
    
    log_game_event(
        event_type='new_hand_started',
        event_data={
            'previous_hand': game['hand_number'],
            'new_hand': game['hand_number'] + 1
        },
        session=session
    )
    
    game['hand_number'] += 1
    init_new_hand(game)
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/instructions')
def instructions():
    return render_template('instructions.html')

@app.route('/stats')
def stats():
    client_ip = get_client_ip(request)  # Add 'request' parameter here!
    
    # Get existing stats
    competitive_leaders = get_competitive_leaders_stats()
    detailed_leaders = get_city_leaders_stats()
    player_stats = get_ip_address_game_stats(client_ip)
    
    # Get monthly stats
    monthly_stats = get_monthly_stats_by_location()
    
    return render_template('stats.html', 
                        competitive_leaders=competitive_leaders,
                        detailed_leaders=detailed_leaders,
                        player_stats=player_stats[0] if player_stats else None,
                        monthly_stats=monthly_stats,
                        current_ip=client_ip)

@app.route('/debug_game_creation')
def debug_game_creation():
    """Debug game creation issues"""
    if 'game' not in session:
        return jsonify({'error': 'No game in session'})
    
    game = session['game']
    game_id = game.get('game_id')
    
    # Try to create the game synchronously to see the error
    try:
        from utilities.postgres_utils import create_game_with_player, get_db_connection
        
        # First test database connection
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT 1")
        cur.close()
        conn.close()
        db_connection_ok = True
    except Exception as e:
        db_connection_ok = False
        db_error = str(e)
    
    # Try creating the game
    try:
        from utilities.postgres_utils import create_game_with_player
        creation_result = create_game_with_player(game, game.get('client_info'))
    except Exception as e:
        creation_result = f"Exception: {e}"
    
    return jsonify({
        'game_id': game_id,
        'game_started_at': game.get('game_started_at'),
        'client_info': game.get('client_info'),
        'db_connection_ok': db_connection_ok,
        'db_error': db_error if not db_connection_ok else None,
        'creation_result': creation_result,
        'is_production': IS_PRODUCTION
    })

if __name__ == '__main__':
    start_development_server(app)

================================================================================

FILE: ./test_ip2.py
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Two-Man Spades IP Geolocation Analysis Script
Analyzes all IP addresses from the database and provides geographic insights
"""

# =============================================================================
# GLOBAL CONFIGURATION VARIABLES - ADJUST THESE AS NEEDED
# =============================================================================

# Spam filtering settings
MINIMUM_ACTIVITIES = 3              # Filter out IPs with fewer activities (likely spam/bots)
INCLUDE_FAILED_GEOLOCATIONS = True  # Whether to include IPs that failed geolocation

# Rate limiting settings (ip-api.com free tier: 45 requests/minute)
REQUESTS_PER_MINUTE = 40            # Conservative rate to stay under limit
DELAY_BETWEEN_REQUESTS = 60 / REQUESTS_PER_MINUTE  # Auto-calculated delay

# IP privacy settings
IP_MASK_PREFIX_CHARS = 3            # How many chars to show at start of IP
IP_MASK_SUFFIX_CHARS = 3            # How many chars to show at end of IP

# Output settings
CONSOLE_OUTPUT_ENABLED = True       # Show detailed console output
CSV_EXPORT_ENABLED = True           # Export results to CSV
CSV_FILENAME_PREFIX = "twomanspades_geolocation"  # CSV file prefix

# Database query settings
COMBINE_HANDS_AND_EVENTS = True     # Query both hands and game_events tables
SORT_BY_ACTIVITY_COUNT = True       # Sort results by activity count (desc)

# Geolocation API settings
API_TIMEOUT_SECONDS = 5             # Timeout for each API request
USER_AGENT = "TwoManSpades-GeoAnalysis/1.0"  # User agent for API requests
API_BASE_URL = "http://ip-api.com/json"      # API endpoint

# =============================================================================
# IMPORTS AND SETUP
# =============================================================================

import sys
import os
import time
import urllib.request
import urllib.error
import json
import csv
from collections import defaultdict
from datetime import datetime

# Add the current directory to path to import utilities
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

try:
    from utilities.postgres_utils import get_db_connection, get_ip_address_game_stats
    print("‚úÖ Successfully imported postgres_utils")
except ImportError as e:
    print(f"‚ùå Failed to import postgres_utils: {e}")
    print("Make sure you're running this script from the same directory as app.py")
    sys.exit(1)

# =============================================================================
# CORE FUNCTIONS
# =============================================================================

def get_all_unique_ips():
    """Get all unique IP addresses from both hands and game_events tables"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        if COMBINE_HANDS_AND_EVENTS:
            # Query to get all unique IPs from both tables with activity stats
            query = """
            WITH combined_ips AS (
                -- IPs from hands table
                SELECT 
                    client_ip,
                    started_at as activity_time,
                    'hand' as source_table
                FROM twomanspades.hands 
                WHERE client_ip IS NOT NULL AND client_ip != ''
                
                UNION ALL
                
                -- IPs from game_events table  
                SELECT 
                    client_ip,
                    timestamp as activity_time,
                    'event' as source_table
                FROM twomanspades.game_events 
                WHERE client_ip IS NOT NULL AND client_ip != ''
            ),
            ip_stats AS (
                SELECT 
                    client_ip,
                    COUNT(*) as total_activities,
                    MIN(activity_time) as first_seen,
                    MAX(activity_time) as last_seen,
                    COUNT(CASE WHEN source_table = 'hand' THEN 1 END) as hand_count,
                    COUNT(CASE WHEN source_table = 'event' THEN 1 END) as event_count
                FROM combined_ips
                GROUP BY client_ip
            )
            SELECT 
                client_ip,
                total_activities,
                first_seen,
                last_seen,
                hand_count,
                event_count
            FROM ip_stats
            ORDER BY total_activities DESC, hand_count DESC
            """
        else:
            # Use existing view for hands table only
            all_stats = get_ip_address_game_stats()
            valid_stats = [stat for stat in all_stats if stat.get('total_games', 0) > 0]
            formatted_data = []
            for stat in valid_stats:
                formatted_data.append((
                    stat['client_ip'],
                    stat['total_games'],
                    stat.get('first_game'),
                    stat.get('last_game')
                ))
            return formatted_data
        
        cur.execute(query)
        results = cur.fetchall()
        cur.close()
        conn.close()
        
        # Convert to format we need (ip, activity_count, first_seen, last_seen)
        formatted_data = []
        for row in results:
            ip, total_activities, first_seen, last_seen, hand_count, event_count = row
            formatted_data.append((
                ip,
                total_activities,
                first_seen,
                last_seen
            ))
        
        if CONSOLE_OUTPUT_ENABLED:
            print(f"üìä Found IPs across both tables:")
            print(f"   - {len(set(r[0] for r in formatted_data))} unique IP addresses")
            print(f"   - Total activities: {sum(r[1] for r in formatted_data)}")
        
        return formatted_data
        
    except Exception as e:
        print(f"‚ùå Error getting IP addresses from both tables: {e}")
        return []

def geolocate_ip(ip_address):
    """Use ip-api.com free service to geolocate an IP address"""
    try:
        url = f"{API_BASE_URL}/{ip_address}"
        
        request = urllib.request.Request(url)
        request.add_header('User-Agent', USER_AGENT)
        
        with urllib.request.urlopen(request, timeout=API_TIMEOUT_SECONDS) as response:
            if response.getcode() == 200:
                data = json.loads(response.read().decode('utf-8'))
                
                if data.get('status') == 'success':
                    return {
                        'country': data.get('country', 'Unknown'),
                        'region': data.get('regionName', 'Unknown'),
                        'city': data.get('city', 'Unknown'),
                        'isp': data.get('isp', 'Unknown'),
                        'lat': data.get('lat', 0),
                        'lon': data.get('lon', 0),
                        'timezone': data.get('timezone', 'Unknown'),
                        'zip': data.get('zip', 'Unknown')
                    }
                else:
                    if CONSOLE_OUTPUT_ENABLED:
                        print(f"  ‚ö†Ô∏è  API returned failure for {ip_address}: {data.get('message', 'Unknown error')}")
                    return None
            else:
                if CONSOLE_OUTPUT_ENABLED:
                    print(f"  ‚ùå HTTP error {response.getcode()} for {ip_address}")
                return None
            
    except urllib.error.URLError as e:
        if CONSOLE_OUTPUT_ENABLED:
            if hasattr(e, 'reason'):
                if 'timeout' in str(e.reason).lower():
                    print(f"  ‚è±Ô∏è  Timeout for {ip_address}")
                else:
                    print(f"  ‚ùå URL error for {ip_address}: {e.reason}")
            else:
                print(f"  ‚ùå URL error for {ip_address}: {e}")
        return None
    except json.JSONDecodeError:
        if CONSOLE_OUTPUT_ENABLED:
            print(f"  ‚ùå Invalid JSON response for {ip_address}")
        return None
    except Exception as e:
        if CONSOLE_OUTPUT_ENABLED:
            print(f"  ‚ùå Unexpected error for {ip_address}: {e}")
        return None

def format_ip_for_display(ip):
    """Format IP for privacy display"""
    if len(ip) <= (IP_MASK_PREFIX_CHARS + IP_MASK_SUFFIX_CHARS):
        return ip  # Too short to mask
    return f"{ip[:IP_MASK_PREFIX_CHARS]}***{ip[-IP_MASK_SUFFIX_CHARS:]}"

def save_results_to_csv(results, all_ip_data, filename=None):
    """Save geolocation results to CSV file"""
    if not CSV_EXPORT_ENABLED:
        return None
        
    if not filename:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{CSV_FILENAME_PREFIX}_{timestamp}.csv"
    
    try:
        with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
            fieldnames = [
                'ip_masked', 'activities', 'first_seen', 'last_seen', 
                'city', 'region', 'country', 'isp', 'timezone', 
                'latitude', 'longitude', 'zip_code', 'lookup_success'
            ]
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            
            for result in results:
                row = {
                    'ip_masked': result['ip_display'],
                    'activities': result['activities'],
                    'first_seen': result['first_seen'].strftime('%Y-%m-%d %H:%M:%S') if result['first_seen'] else '',
                    'last_seen': result['last_seen'].strftime('%Y-%m-%d %H:%M:%S') if result['last_seen'] else '',
                    'lookup_success': 'Yes' if result['location'] else 'No'
                }
                
                if result['location']:
                    loc = result['location']
                    row.update({
                        'city': loc['city'],
                        'region': loc['region'], 
                        'country': loc['country'],
                        'isp': loc['isp'],
                        'timezone': loc['timezone'],
                        'latitude': loc['lat'],
                        'longitude': loc['lon'],
                        'zip_code': loc['zip']
                    })
                else:
                    row.update({
                        'city': 'Unknown', 'region': 'Unknown', 'country': 'Unknown',
                        'isp': 'Unknown', 'timezone': 'Unknown', 'latitude': 0,
                        'longitude': 0, 'zip_code': 'Unknown'
                    })
                
                writer.writerow(row)
        
        if CONSOLE_OUTPUT_ENABLED:
            print(f"üíæ Results saved to: {filename}")
        return filename
        
    except Exception as e:
        if CONSOLE_OUTPUT_ENABLED:
            print(f"‚ùå Failed to save CSV: {e}")
        return None

# =============================================================================
# MAIN EXECUTION
# =============================================================================

def main():
    if CONSOLE_OUTPUT_ENABLED:
        print("üåç Two-Man Spades IP Geolocation Analysis")
        print("=" * 50)
        print(f"‚öôÔ∏è  Configuration:")
        print(f"   - Minimum activities filter: {MINIMUM_ACTIVITIES}")
        print(f"   - Rate limit: {REQUESTS_PER_MINUTE} requests/minute")
        print(f"   - Combine tables: {COMBINE_HANDS_AND_EVENTS}")
        print(f"   - CSV export: {CSV_EXPORT_ENABLED}")
    
    # Test database connection first
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT 1")
        cur.close()
        conn.close()
        if CONSOLE_OUTPUT_ENABLED:
            print("‚úÖ Database connection successful")
    except Exception as e:
        print(f"‚ùå Database connection failed: {e}")
        return
    
    # Get all unique IPs
    if CONSOLE_OUTPUT_ENABLED:
        print("\nüìã Fetching unique IP addresses from database...")
    all_ip_data = get_all_unique_ips()
    
    if not all_ip_data:
        print("‚ùå No IP addresses found in database")
        return
    
    # Filter out likely spam/automated traffic
    ip_data = [ip for ip in all_ip_data if ip[1] >= MINIMUM_ACTIVITIES]
    
    total_all_ips = len(all_ip_data)
    total_filtered_ips = len(ip_data)
    filtered_out = total_all_ips - total_filtered_ips
    
    if CONSOLE_OUTPUT_ENABLED:
        print(f"‚úÖ Found {total_all_ips} unique IP addresses")
        print(f"üîç Filtered to {total_filtered_ips} IPs with {MINIMUM_ACTIVITIES}+ activities (removed {filtered_out} likely spam/automated)")
    
    # Process ALL filtered IP addresses
    if CONSOLE_OUTPUT_ENABLED:
        print(f"üéØ Processing ALL {total_filtered_ips} legitimate players")
        print(f"üìä Rate limit: {REQUESTS_PER_MINUTE} requests/minute")
        print(f"‚è±Ô∏è  Estimated time: ~{(total_filtered_ips * DELAY_BETWEEN_REQUESTS) / 60:.1f} minutes")
        print("\nüîç Starting geolocation lookups...")
        print("=" * 70)
    
    # Initialize results storage
    results = []
    country_stats = defaultdict(int)
    region_stats = defaultdict(int)
    isp_stats = defaultdict(int)
    
    for i, (ip, activities, first_seen, last_seen) in enumerate(ip_data, 1):
        if CONSOLE_OUTPUT_ENABLED:
            print(f"\n[{i:2}/{total_filtered_ips}] {format_ip_for_display(ip)} ({activities} activities)")
            if first_seen and last_seen:
                print(f"         First: {first_seen.strftime('%Y-%m-%d %H:%M')} | Last: {last_seen.strftime('%Y-%m-%d %H:%M')}")
            else:
                print(f"         First/Last: Unknown")
        
        # Rate limiting
        if i > 1:
            time.sleep(DELAY_BETWEEN_REQUESTS)
        
        # Geolocate the IP
        location = geolocate_ip(ip)
        
        if location:
            if CONSOLE_OUTPUT_ENABLED:
                print(f"         üìç {location['city']}, {location['region']}, {location['country']}")
                print(f"         üåê ISP: {location['isp']}")
                print(f"         üïê Timezone: {location['timezone']}")
            
            # Store results
            result = {
                'ip': ip,
                'ip_display': format_ip_for_display(ip),
                'activities': activities,
                'first_seen': first_seen,
                'last_seen': last_seen,
                'location': location
            }
            results.append(result)
            
            # Update statistics
            country_stats[location['country']] += activities
            region_key = f"{location['region']}, {location['country']}"
            region_stats[region_key] += activities
            isp_stats[location['isp']] += activities
            
        else:
            if CONSOLE_OUTPUT_ENABLED:
                print(f"         ‚ùå Geolocation failed")
            
            if INCLUDE_FAILED_GEOLOCATIONS:
                # Store failed result
                result = {
                    'ip': ip,
                    'ip_display': format_ip_for_display(ip),
                    'activities': activities,
                    'first_seen': first_seen,
                    'last_seen': last_seen,
                    'location': None
                }
                results.append(result)
    
    # Print summary statistics
    if CONSOLE_OUTPUT_ENABLED:
        print("\n" + "=" * 70)
        print("üìä GEOLOCATION SUMMARY")
        print("=" * 70)
        
        successful_lookups = len([r for r in results if r['location']])
        print(f"‚úÖ Successful lookups: {successful_lookups}/{len(results)} ({successful_lookups/len(results)*100:.1f}%)")
        
        print(f"\nüåç TOP COUNTRIES BY ACTIVITY:")
        for country, activities in sorted(country_stats.items(), key=lambda x: x[1], reverse=True):
            print(f"   {country:<20} {activities:>3} activities")
        
        print(f"\nüèôÔ∏è  TOP REGIONS BY ACTIVITY:")
        for region, activities in sorted(region_stats.items(), key=lambda x: x[1], reverse=True):
            print(f"   {region:<35} {activities:>3} activities")
        
        print(f"\nüîó TOP ISPs BY ACTIVITY:")
        for isp, activities in sorted(isp_stats.items(), key=lambda x: x[1], reverse=True):
            isp_display = isp[:40] + "..." if len(isp) > 40 else isp
            print(f"   {isp_display:<43} {activities:>3} activities")
        
        print(f"\nüéÆ ALL {total_filtered_ips} LEGITIMATE PLAYERS SORTED BY CITY:")
        print("-" * 70)
        
        # Sort results by city for final display
        results_by_city = sorted(results, key=lambda x: (
            x['location']['city'] if x['location'] else 'zzz_Unknown',
            x['location']['region'] if x['location'] else '',
            x['location']['country'] if x['location'] else ''
        ))
        
        for result in results_by_city:
            ip_display = result['ip_display']
            activities = result['activities']
            
            if result['location']:
                loc = result['location']
                location_str = f"{loc['city']}, {loc['region']}, {loc['country']}"
                print(f"{ip_display:<12} | {activities:>3} activities | {location_str}")
            else:
                print(f"{ip_display:<12} | {activities:>3} activities | Location unknown")
        
        total_activities_filtered = sum(r['activities'] for r in results)
        total_activities_all = sum(ip[1] for ip in all_ip_data)
        spam_activities = total_activities_all - total_activities_filtered
        
        print(f"\nüéØ LEGITIMATE PLAYERS: {len(results)} players, {total_activities_filtered} activities")
        print(f"ü§ñ FILTERED OUT: {filtered_out} likely spam/bot IPs, {spam_activities} activities")
        print(f"üåç TOTAL IN DATABASE: {total_all_ips} IPs, {total_activities_all} total activities")
        print(f"üåç ALL PLAYERS: {total_filtered_ips} legitimate players processed")
        print(f"üìà Players with {MINIMUM_ACTIVITIES}+ activities sorted by city alphabetically")
    
    # Save results to CSV
    if CSV_EXPORT_ENABLED:
        if CONSOLE_OUTPUT_ENABLED:
            print(f"\nüíæ Saving results to CSV...")
        csv_filename = save_results_to_csv(results, all_ip_data)
        if csv_filename and CONSOLE_OUTPUT_ENABLED:
            print(f"üìä CSV contains {len(results)} legitimate players with detailed geolocation data")
            print(f"üìÅ File includes columns: IP (masked), activities, timestamps, location details, ISP info")
            print(f"üîç You can now sort/filter by any column in Excel or other tools")
    
    if CONSOLE_OUTPUT_ENABLED:
        print("\n‚ú® Spam-filtered geolocation analysis complete!")

if __name__ == "__main__":
    main()

================================================================================

FILE: ./gather_pythons.py
--------------------------------------------------------------------------------
import os
from datetime import datetime

# Configuration
# Set file types to include
FILE_EXTENSIONS = [
    '.py',    # Python files (always included)
    '.html',  # HTML files
    '.js',    # JavaScript files
    #'.css',   # CSS files
    #'.json',  # JSON configuration files
]

# Flag to control directory depth
ONLY_ROOT_DIRECTORY = False  # Set to True to only search in root directory

# Filename patterns to exclude (new)
EXCLUDED_FILENAME_PATTERNS = [
    'copy',   # Any file with 'copy' in the name
    'backup', # Any file with 'backup' in the name
    'temp',   # Any file with 'temp' in the name
        'archives',   # Any file with 'temp' in the name
                '_full',   # Any file with '_full' in the name
]

# Directories to completely exclude from both scanning and output
EXCLUDED_DIRECTORIES = [
    "assets",
    "tests",
    "previous_versions",
    "projects",
    "tools",
    "revisions_app",
    "venv_2man",
    ".git",
    "archives"

]

def gather_files(root_dir, excluded_directories, file_extensions, excluded_patterns, only_root=False):
    """
    Gathers files with specified extensions within the root directory and its subdirectories,
    excluding specified directories and filename patterns.

    Parameters:
        root_dir (str): The root directory to search for files.
        excluded_directories (list): List of directory names to exclude.
        file_extensions (list): List of file extensions to include.
        excluded_patterns (list): List of filename patterns to exclude.
        only_root (bool): If True, only search in the root directory (no subdirectories).

    Returns:
        tuple: (files_data, included_directories)
    """
    files_data = []
    included_directories = set()

    if only_root:
        # Only process files in the root directory
        relative_path = "."
        included_directories.add(relative_path)
        
        try:
            filenames = os.listdir(root_dir)
            for filename in filenames:
                file_path = os.path.join(root_dir, filename)
                
                # Skip directories
                if os.path.isdir(file_path):
                    continue
                
                # Skip files with excluded patterns in the filename
                if any(pattern.lower() in filename.lower() for pattern in excluded_patterns):
                    continue
                    
                # Only include files with the specified extensions
                if any(filename.endswith(ext) for ext in file_extensions):
                    try:
                        with open(file_path, 'r', encoding='utf-8') as file:
                            file_contents = file.read()
                        files_data.append((file_path, file_contents))
                    except UnicodeDecodeError:
                        print(f"Could not read file {file_path} due to encoding error. Skipping.")
                    except Exception as e:
                        print(f"Error with file {file_path}: {e}")
        except Exception as e:
            print(f"Error accessing root directory: {e}")
    else:
        # Original recursive behavior
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Get the relative path
            relative_path = os.path.relpath(dirpath, root_dir)
            
            # Skip excluded directories - check if any part of the path matches exclusion patterns
            should_exclude = False
            for excluded_dir in excluded_directories:
                # Check both exact match and path-based matches
                if excluded_dir == relative_path or excluded_dir in relative_path.replace('\\', '/'):
                    should_exclude = True
                    break
                    
            if should_exclude:
                continue

            # Add directory to our structure
            included_directories.add(relative_path)
            
            # Process files
            for filename in filenames:
                file_path = os.path.join(dirpath, filename)
                
                # Skip files with excluded patterns in the filename
                if any(pattern.lower() in filename.lower() for pattern in excluded_patterns):
                    continue
                    
                # Only include files with the specified extensions
                if any(filename.endswith(ext) for ext in file_extensions):
                    try:
                        with open(file_path, 'r', encoding='utf-8') as file:
                            file_contents = file.read()
                        files_data.append((file_path, file_contents))
                    except UnicodeDecodeError:
                        print(f"Could not read file {file_path} due to encoding error. Skipping.")
                    except Exception as e:
                        print(f"Error with file {file_path}: {e}")

    return files_data, sorted(included_directories)

def write_to_file(output_filepath, files_data, included_directories):
    """
    Writes the gathered data to a file with project information and file contents.
    """
    with open(output_filepath, 'w', encoding='utf-8') as file:
        # Write statistics
        file.write(f"Number of files: {len(files_data)}\n")
        file.write(f"Number of directories: {len(included_directories)}\n\n")
        
        # Write directory structure
        file.write("Directory structure:\n")
        for directory in included_directories:
            file.write(f"{directory}\n")
        file.write("\n")
        
        # Group and list files by extension
        extension_groups = {}
        for filepath, _ in files_data:
            ext = os.path.splitext(filepath)[1].lower()
            if ext not in extension_groups:
                extension_groups[ext] = []
            extension_groups[ext].append(filepath)
        
        file.write("List of file paths by type:\n")
        for ext, filepaths in sorted(extension_groups.items()):
            file.write(f"\n{ext.upper()[1:]} Files ({len(filepaths)}):\n")
            for filepath in sorted(filepaths):
                file.write(f"  {filepath}\n")
        file.write("\n")
        
        # Write file contents
        file.write("="*80 + "\n")
        file.write("FILE CONTENTS\n")
        file.write("="*80 + "\n\n")
        
        for filepath, file_contents in files_data:
            file.write(f"FILE: {filepath}\n")
            file.write("-"*80 + "\n")
            file.write(f"{file_contents}\n\n")
            file.write("="*80 + "\n\n")

def scan_project_structure():
    """
    Main function to scan the project structure and write the results to a file.
    """
    root_dir = "."  # Current directory
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_filepath = f"{timestamp}_project_structure.txt"
    
    print(f"Starting to scan project structure at {root_dir}...")
    print(f"Including file types: {', '.join(FILE_EXTENSIONS)}")
    print(f"Excluding file patterns: {', '.join(EXCLUDED_FILENAME_PATTERNS)}")
    
    if ONLY_ROOT_DIRECTORY:
        print("Scanning ONLY root directory (subdirectories will be skipped)")
    else:
        print(f"Excluding directories: {', '.join(EXCLUDED_DIRECTORIES)}")
    
    # Gather files and directory information
    files_data, included_directories = gather_files(
        root_dir, 
        EXCLUDED_DIRECTORIES, 
        FILE_EXTENSIONS,
        EXCLUDED_FILENAME_PATTERNS,
        only_root=ONLY_ROOT_DIRECTORY
    )
    
    print(f"Found {len(files_data)} files across {len(included_directories)} directories.")
    if not ONLY_ROOT_DIRECTORY:
        print(f"Excluded directories won't appear in the output file.")
    
    # Write the output file
    write_to_file(
        output_filepath, 
        files_data, 
        included_directories
    )
    
    print(f"Project structure has been written to {output_filepath}")
    print(f"File size: {os.path.getsize(output_filepath) / (1024*1024):.2f} MB")

if __name__ == "__main__":
    scan_project_structure()

================================================================================

FILE: ./test_monthly.py
--------------------------------------------------------------------------------
"""
Test script for monthly stats functionality
Run this locally to verify the get_monthly_stats_by_location() function works
"""

import os
import sys
from pprint import pprint

# Add the parent directory to the path so we can import utilities
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from utilities.postgres_utils import get_monthly_stats_by_location

def test_monthly_stats():
    print("=" * 80)
    print("Testing get_monthly_stats_by_location()")
    print("=" * 80)
    
    try:
        results = get_monthly_stats_by_location()
        
        print("\nüìä Results structure:")
        print(f"   Number of family members: {len(results)}")
        print(f"   Family members: {list(results.keys())}")
        
        print("\n" + "=" * 80)
        print("DETAILED RESULTS BY FAMILY MEMBER")
        print("=" * 80)
        
        for family_member, data in results.items():
            print(f"\nüè† {family_member.upper()}")
            print("-" * 80)
            
            monthly_data = data['monthly']
            print(f"   Total months with data: {len(monthly_data)}")
            
            if monthly_data:
                print("\n   Monthly breakdown:")
                for month_stat in monthly_data:
                    month = month_stat['month'].strftime('%B %Y')
                    print(f"\n   üìÖ {month}")
                    print(f"      Hands Played:     {month_stat['hands_played']}")
                    print(f"      Hands Won:        {month_stat['hands_won']}")
                    print(f"      Hands Lost:       {month_stat['hands_lost']}")
                    print(f"      Avg Player Score: {month_stat['avg_player_score']}")
                    print(f"      Avg CPU Score:    {month_stat['avg_computer_score']}")
                    print(f"      Total Bags:       {month_stat['total_bags']}")
                    
                    if month_stat['hands_played'] > 0:
                        win_rate = (month_stat['hands_won'] / month_stat['hands_played']) * 100
                        print(f"      Win Rate:         {win_rate:.1f}%")
        
        print("\n" + "=" * 80)
        print("‚úÖ TEST COMPLETED SUCCESSFULLY!")
        print("=" * 80)
        
    except Exception as e:
        print("\n" + "=" * 80)
        print("‚ùå ERROR OCCURRED")
        print("=" * 80)
        print(f"\nError type: {type(e).__name__}")
        print(f"Error message: {str(e)}")
        
        import traceback
        print("\nFull traceback:")
        traceback.print_exc()
        
        return False
    
    return True

if __name__ == "__main__":
    print("\nüß™ Starting monthly stats test...\n")
    success = test_monthly_stats()
    
    if success:
        print("\n‚ú® All tests passed! Function is working correctly.\n")
        sys.exit(0)
    else:
        print("\nüí• Tests failed. Check the error messages above.\n")
        sys.exit(1)

================================================================================

FILE: ./test_ip3.py
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Two-Man Spades IP Geolocation Analysis Script
Analyzes all IP addresses from the database and provides geographic insights
"""

# =============================================================================
# GLOBAL CONFIGURATION VARIABLES - ADJUST THESE AS NEEDED
# =============================================================================

# Spam filtering settings
MINIMUM_ACTIVITIES = 3              # Filter out IPs with fewer activities (likely spam/bots)
INCLUDE_FAILED_GEOLOCATIONS = True  # Whether to include IPs that failed geolocation

# Rate limiting settings (ip-api.com free tier: 45 requests/minute)
REQUESTS_PER_MINUTE = 40            # Conservative rate to stay under limit
DELAY_BETWEEN_REQUESTS = 60 / REQUESTS_PER_MINUTE  # Auto-calculated delay

# IP privacy settings
IP_MASK_IN_CSV = False              # Set to False to show full IPs in CSV
IP_MASK_IN_CONSOLE = True           # Keep masking in console for privacy
IP_MASK_PREFIX_CHARS = 3            # Console display only
IP_MASK_SUFFIX_CHARS = 3            # Console display only

# Output settings
CONSOLE_OUTPUT_ENABLED = True       # Show detailed console output
CSV_EXPORT_ENABLED = True           # Export results to CSV
CSV_FILENAME_PREFIX = "twomanspades_geolocation"  # CSV file prefix

# Multiple CSV output files
EXPORT_SUMMARY_CSV = True           # Main summary with all data points
EXPORT_COUNTRIES_CSV = True         # Countries breakdown
EXPORT_REGIONS_CSV = True           # Regions breakdown  
EXPORT_ISPS_CSV = True              # ISPs breakdown
EXPORT_FAILED_LOOKUPS_CSV = True    # Failed geolocation attempts

# Database query settings
COMBINE_HANDS_AND_EVENTS = True     # Query both hands and game_events tables
SORT_BY_ACTIVITY_COUNT = True       # Sort results by activity count (desc)

# Geolocation API settings
API_TIMEOUT_SECONDS = 5             # Timeout for each API request
USER_AGENT = "TwoManSpades-GeoAnalysis/1.0"  # User agent for API requests
API_BASE_URL = "http://ip-api.com/json"      # API endpoint

# =============================================================================
# IMPORTS AND SETUP
# =============================================================================

import sys
import os
import time
import urllib.request
import urllib.error
import json
import csv
from collections import defaultdict
from datetime import datetime

# Add the current directory to path to import utilities
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

try:
    from utilities.postgres_utils import get_db_connection, get_ip_address_game_stats
    print("‚úÖ Successfully imported postgres_utils")
except ImportError as e:
    print(f"‚ùå Failed to import postgres_utils: {e}")
    print("Make sure you're running this script from the same directory as app.py")
    sys.exit(1)

# =============================================================================
# CORE FUNCTIONS
# =============================================================================

def get_all_unique_ips():
    """Get all unique IP addresses from both hands and game_events tables"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        if COMBINE_HANDS_AND_EVENTS:
            # Query to get all unique IPs from both tables with activity stats
            query = """
            WITH combined_ips AS (
                -- IPs from hands table
                SELECT 
                    client_ip,
                    started_at as activity_time,
                    'hand' as source_table
                FROM twomanspades.hands 
                WHERE client_ip IS NOT NULL AND client_ip != ''
                
                UNION ALL
                
                -- IPs from game_events table  
                SELECT 
                    client_ip,
                    timestamp as activity_time,
                    'event' as source_table
                FROM twomanspades.game_events 
                WHERE client_ip IS NOT NULL AND client_ip != ''
            ),
            ip_stats AS (
                SELECT 
                    client_ip,
                    COUNT(*) as total_activities,
                    MIN(activity_time) as first_seen,
                    MAX(activity_time) as last_seen,
                    COUNT(CASE WHEN source_table = 'hand' THEN 1 END) as hand_count,
                    COUNT(CASE WHEN source_table = 'event' THEN 1 END) as event_count
                FROM combined_ips
                GROUP BY client_ip
            )
            SELECT 
                client_ip,
                total_activities,
                first_seen,
                last_seen,
                hand_count,
                event_count
            FROM ip_stats
            ORDER BY total_activities DESC, hand_count DESC
            """
        else:
            # Use existing view for hands table only
            all_stats = get_ip_address_game_stats()
            valid_stats = [stat for stat in all_stats if stat.get('total_games', 0) > 0]
            formatted_data = []
            for stat in valid_stats:
                formatted_data.append((
                    stat['client_ip'],
                    stat['total_games'],
                    stat.get('first_game'),
                    stat.get('last_game')
                ))
            return formatted_data
        
        cur.execute(query)
        results = cur.fetchall()
        cur.close()
        conn.close()
        
        # Convert to format we need (ip, activity_count, first_seen, last_seen)
        formatted_data = []
        for row in results:
            ip, total_activities, first_seen, last_seen, hand_count, event_count = row
            formatted_data.append((
                ip,
                total_activities,
                first_seen,
                last_seen
            ))
        
        if CONSOLE_OUTPUT_ENABLED:
            print(f"üìä Found IPs across both tables:")
            print(f"   - {len(set(r[0] for r in formatted_data))} unique IP addresses")
            print(f"   - Total activities: {sum(r[1] for r in formatted_data)}")
        
        return formatted_data
        
    except Exception as e:
        print(f"‚ùå Error getting IP addresses from both tables: {e}")
        return []

def geolocate_ip(ip_address):
    """Use ip-api.com free service to geolocate an IP address"""
    try:
        url = f"{API_BASE_URL}/{ip_address}"
        
        request = urllib.request.Request(url)
        request.add_header('User-Agent', USER_AGENT)
        
        with urllib.request.urlopen(request, timeout=API_TIMEOUT_SECONDS) as response:
            if response.getcode() == 200:
                data = json.loads(response.read().decode('utf-8'))
                
                if data.get('status') == 'success':
                    return {
                        'country': data.get('country', 'Unknown'),
                        'region': data.get('regionName', 'Unknown'),
                        'city': data.get('city', 'Unknown'),
                        'isp': data.get('isp', 'Unknown'),
                        'lat': data.get('lat', 0),
                        'lon': data.get('lon', 0),
                        'timezone': data.get('timezone', 'Unknown'),
                        'zip': data.get('zip', 'Unknown'),
                        'org': data.get('org', data.get('isp', 'Unknown')),
                        'as': data.get('as', 'Unknown')
                    }
                else:
                    if CONSOLE_OUTPUT_ENABLED:
                        print(f"  ‚ö†Ô∏è  API returned failure for {ip_address}: {data.get('message', 'Unknown error')}")
                    return None
            else:
                if CONSOLE_OUTPUT_ENABLED:
                    print(f"  ‚ùå HTTP error {response.getcode()} for {ip_address}")
                return None
            
    except urllib.error.URLError as e:
        if CONSOLE_OUTPUT_ENABLED:
            if hasattr(e, 'reason'):
                if 'timeout' in str(e.reason).lower():
                    print(f"  ‚è±Ô∏è  Timeout for {ip_address}")
                else:
                    print(f"  ‚ùå URL error for {ip_address}: {e.reason}")
            else:
                print(f"  ‚ùå URL error for {ip_address}: {e}")
        return None
    except json.JSONDecodeError:
        if CONSOLE_OUTPUT_ENABLED:
            print(f"  ‚ùå Invalid JSON response for {ip_address}")
        return None
    except Exception as e:
        if CONSOLE_OUTPUT_ENABLED:
            print(f"  ‚ùå Unexpected error for {ip_address}: {e}")
        return None

def format_ip_for_display(ip):
    """Format IP for privacy display - separate from CSV export"""
    if not IP_MASK_IN_CONSOLE:
        return ip
    if len(ip) <= (IP_MASK_PREFIX_CHARS + IP_MASK_SUFFIX_CHARS):
        return ip  # Too short to mask
    return f"{ip[:IP_MASK_PREFIX_CHARS]}***{ip[-IP_MASK_SUFFIX_CHARS:]}"

# =============================================================================
# ENHANCED CSV EXPORT FUNCTIONS
# =============================================================================

def save_comprehensive_csv(results, filename):
    """Save the main comprehensive CSV with all possible data points"""
    try:
        with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
            fieldnames = [
                # IP and Activity Data
                'ip_address', 'total_activities', 'first_seen_date', 'first_seen_time', 
                'last_seen_date', 'last_seen_time', 'activity_span_days',
                
                # Location Data
                'city', 'region', 'country', 'timezone', 'zip_code',
                
                # Geographic Coordinates
                'latitude', 'longitude',
                
                # Network Data
                'isp', 'org', 'as_number', 'as_name',
                
                # Analysis Fields
                'activities_per_day', 'player_type', 'lookup_success',
                
                # Timestamps for sorting
                'first_seen_timestamp', 'last_seen_timestamp'
            ]
            
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            
            for result in results:
                # Calculate activity patterns
                activity_span_days = 0
                activities_per_day = 0
                
                if result['first_seen'] and result['last_seen']:
                    activity_span = result['last_seen'] - result['first_seen']
                    activity_span_days = activity_span.days + 1  # Include partial days
                    if activity_span_days > 0:
                        activities_per_day = round(result['activities'] / activity_span_days, 2)
                
                # Determine player type based on activity patterns
                player_type = "Unknown"
                if result['activities'] >= 1000:
                    player_type = "Heavy Player"
                elif result['activities'] >= 100:
                    player_type = "Regular Player" 
                elif result['activities'] >= 10:
                    player_type = "Casual Player"
                else:
                    player_type = "Light Player"
                
                # Base row data
                row = {
                    'ip_address': result['ip'] if not IP_MASK_IN_CSV else result['ip_display'],
                    'total_activities': result['activities'],
                    'first_seen_date': result['first_seen'].strftime('%Y-%m-%d') if result['first_seen'] else '',
                    'first_seen_time': result['first_seen'].strftime('%H:%M:%S') if result['first_seen'] else '',
                    'last_seen_date': result['last_seen'].strftime('%Y-%m-%d') if result['last_seen'] else '',
                    'last_seen_time': result['last_seen'].strftime('%H:%M:%S') if result['last_seen'] else '',
                    'first_seen_timestamp': result['first_seen'].isoformat() if result['first_seen'] else '',
                    'last_seen_timestamp': result['last_seen'].isoformat() if result['last_seen'] else '',
                    'activity_span_days': activity_span_days,
                    'activities_per_day': activities_per_day,
                    'player_type': player_type,
                    'lookup_success': 'Yes' if result['location'] else 'No'
                }
                
                # Add location data if available
                if result['location']:
                    loc = result['location']
                    row.update({
                        'city': loc.get('city', ''),
                        'region': loc.get('region', ''),
                        'country': loc.get('country', ''),
                        'timezone': loc.get('timezone', ''),
                        'zip_code': loc.get('zip', ''),
                        'latitude': loc.get('lat', ''),
                        'longitude': loc.get('lon', ''),
                        'isp': loc.get('isp', ''),
                        'org': loc.get('org', loc.get('isp', '')),  # Fallback to ISP if org not available
                        'as_number': loc.get('as', '').split(' ')[0] if loc.get('as') else '',
                        'as_name': ' '.join(loc.get('as', '').split(' ')[1:]) if loc.get('as') else ''
                    })
                else:
                    # Fill with empty values for failed lookups
                    row.update({
                        'city': '', 'region': '', 'country': '', 'timezone': '', 'zip_code': '',
                        'latitude': '', 'longitude': '', 'isp': '', 'org': '', 'as_number': '', 'as_name': ''
                    })
                
                writer.writerow(row)
        
        if CONSOLE_OUTPUT_ENABLED:
            print(f"‚úÖ Comprehensive CSV saved: {filename}")
        return filename
        
    except Exception as e:
        if CONSOLE_OUTPUT_ENABLED:
            print(f"‚ùå Failed to save comprehensive CSV: {e}")
        return None

def save_countries_csv(results, filename):
    """Save countries breakdown CSV"""
    try:
        country_stats = defaultdict(lambda: {'players': 0, 'activities': 0, 'cities': set()})
        
        for result in results:
            if result['location']:
                country = result['location']['country']
                city = result['location']['city']
                country_stats[country]['players'] += 1
                country_stats[country]['activities'] += result['activities']
                country_stats[country]['cities'].add(city)
        
        with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
            fieldnames = ['country', 'total_players', 'total_activities', 'unique_cities', 'avg_activities_per_player']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            
            for country, stats in sorted(country_stats.items(), key=lambda x: x[1]['activities'], reverse=True):
                writer.writerow({
                    'country': country,
                    'total_players': stats['players'],
                    'total_activities': stats['activities'],
                    'unique_cities': len(stats['cities']),
                    'avg_activities_per_player': round(stats['activities'] / stats['players'], 2)
                })
        
        if CONSOLE_OUTPUT_ENABLED:
            print(f"‚úÖ Countries CSV saved: {filename}")
        return filename
        
    except Exception as e:
        if CONSOLE_OUTPUT_ENABLED:
            print(f"‚ùå Failed to save countries CSV: {e}")
        return None

def save_regions_csv(results, filename):
    """Save regions breakdown CSV"""
    try:
        region_stats = defaultdict(lambda: {'players': 0, 'activities': 0})
        
        for result in results:
            if result['location']:
                region_key = f"{result['location']['region']}, {result['location']['country']}"
                region_stats[region_key]['players'] += 1
                region_stats[region_key]['activities'] += result['activities']
        
        with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
            fieldnames = ['region_country', 'region', 'country', 'total_players', 'total_activities', 'avg_activities_per_player']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            
            for region_key, stats in sorted(region_stats.items(), key=lambda x: x[1]['activities'], reverse=True):
                region, country = region_key.rsplit(', ', 1)
                writer.writerow({
                    'region_country': region_key,
                    'region': region,
                    'country': country,
                    'total_players': stats['players'],
                    'total_activities': stats['activities'],
                    'avg_activities_per_player': round(stats['activities'] / stats['players'], 2)
                })
        
        if CONSOLE_OUTPUT_ENABLED:
            print(f"‚úÖ Regions CSV saved: {filename}")
        return filename
        
    except Exception as e:
        if CONSOLE_OUTPUT_ENABLED:
            print(f"‚ùå Failed to save regions CSV: {e}")
        return None

def save_isps_csv(results, filename):
    """Save ISPs breakdown CSV"""
    try:
        isp_stats = defaultdict(lambda: {'players': 0, 'activities': 0, 'countries': set()})
        
        for result in results:
            if result['location']:
                isp = result['location']['isp']
                country = result['location']['country']
                isp_stats[isp]['players'] += 1
                isp_stats[isp]['activities'] += result['activities']
                isp_stats[isp]['countries'].add(country)
        
        with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
            fieldnames = ['isp', 'total_players', 'total_activities', 'countries_served', 'avg_activities_per_player']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            
            for isp, stats in sorted(isp_stats.items(), key=lambda x: x[1]['activities'], reverse=True):
                writer.writerow({
                    'isp': isp,
                    'total_players': stats['players'],
                    'total_activities': stats['activities'],
                    'countries_served': len(stats['countries']),
                    'avg_activities_per_player': round(stats['activities'] / stats['players'], 2)
                })
        
        if CONSOLE_OUTPUT_ENABLED:
            print(f"‚úÖ ISPs CSV saved: {filename}")
        return filename
        
    except Exception as e:
        if CONSOLE_OUTPUT_ENABLED:
            print(f"‚ùå Failed to save ISPs CSV: {e}")
        return None

def save_failed_lookups_csv(failed_results, filename):
    """Save failed geolocation lookups CSV for investigation"""
    try:
        with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
            fieldnames = ['ip_address', 'total_activities', 'first_seen', 'last_seen', 'failure_reason']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            
            for result in failed_results:
                writer.writerow({
                    'ip_address': result['ip'] if not IP_MASK_IN_CSV else result['ip_display'],
                    'total_activities': result['activities'],
                    'first_seen': result['first_seen'].isoformat() if result['first_seen'] else '',
                    'last_seen': result['last_seen'].isoformat() if result['last_seen'] else '',
                    'failure_reason': 'Geolocation API failed or returned invalid data'
                })
        
        if CONSOLE_OUTPUT_ENABLED:
            print(f"‚úÖ Failed lookups CSV saved: {filename}")
        return filename
        
    except Exception as e:
        if CONSOLE_OUTPUT_ENABLED:
            print(f"‚ùå Failed to save failed lookups CSV: {e}")
        return None

def save_enhanced_results_to_csv(results, all_ip_data, base_filename=None):
    """Save comprehensive geolocation results to multiple CSV files"""
    if not CSV_EXPORT_ENABLED:
        return []
        
    if not base_filename:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        base_filename = f"{CSV_FILENAME_PREFIX}_{timestamp}"
    
    saved_files = []
    
    # 1. Main comprehensive summary CSV
    if EXPORT_SUMMARY_CSV:
        filename = f"{base_filename}_comprehensive.csv"
        result = save_comprehensive_csv(results, filename)
        if result:
            saved_files.append(result)
    
    # 2. Countries breakdown CSV
    if EXPORT_COUNTRIES_CSV:
        filename = f"{base_filename}_countries.csv"
        result = save_countries_csv(results, filename)
        if result:
            saved_files.append(result)
    
    # 3. Regions breakdown CSV  
    if EXPORT_REGIONS_CSV:
        filename = f"{base_filename}_regions.csv"
        result = save_regions_csv(results, filename)
        if result:
            saved_files.append(result)
    
    # 4. ISPs breakdown CSV
    if EXPORT_ISPS_CSV:
        filename = f"{base_filename}_isps.csv"
        result = save_isps_csv(results, filename)
        if result:
            saved_files.append(result)
    
    # 5. Failed lookups CSV (if any)
    if EXPORT_FAILED_LOOKUPS_CSV:
        failed_results = [r for r in results if not r['location']]
        if failed_results:
            filename = f"{base_filename}_failed_lookups.csv"
            result = save_failed_lookups_csv(failed_results, filename)
            if result:
                saved_files.append(result)
    
    return saved_files

# =============================================================================
# MAIN EXECUTION
# =============================================================================

def main():
    if CONSOLE_OUTPUT_ENABLED:
        print("üåç Two-Man Spades IP Geolocation Analysis")
        print("=" * 50)
        print(f"‚öôÔ∏è  Configuration:")
        print(f"   - Minimum activities filter: {MINIMUM_ACTIVITIES}")
        print(f"   - Rate limit: {REQUESTS_PER_MINUTE} requests/minute")
        print(f"   - Combine tables: {COMBINE_HANDS_AND_EVENTS}")
        print(f"   - CSV export: {CSV_EXPORT_ENABLED}")
        print(f"   - Full IPs in CSV: {'Yes' if not IP_MASK_IN_CSV else 'No'}")
    
    # Test database connection first
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT 1")
        cur.close()
        conn.close()
        if CONSOLE_OUTPUT_ENABLED:
            print("‚úÖ Database connection successful")
    except Exception as e:
        print(f"‚ùå Database connection failed: {e}")
        return
    
    # Get all unique IPs
    if CONSOLE_OUTPUT_ENABLED:
        print("\nüìã Fetching unique IP addresses from database...")
    all_ip_data = get_all_unique_ips()
    
    if not all_ip_data:
        print("‚ùå No IP addresses found in database")
        return
    
    # Filter out likely spam/automated traffic
    ip_data = [ip for ip in all_ip_data if ip[1] >= MINIMUM_ACTIVITIES]
    
    total_all_ips = len(all_ip_data)
    total_filtered_ips = len(ip_data)
    filtered_out = total_all_ips - total_filtered_ips
    
    if CONSOLE_OUTPUT_ENABLED:
        print(f"‚úÖ Found {total_all_ips} unique IP addresses")
        print(f"üîç Filtered to {total_filtered_ips} IPs with {MINIMUM_ACTIVITIES}+ activities (removed {filtered_out} likely spam/automated)")
    
    # Process ALL filtered IP addresses
    if CONSOLE_OUTPUT_ENABLED:
        print(f"üéØ Processing ALL {total_filtered_ips} legitimate players")
        print(f"üìä Rate limit: {REQUESTS_PER_MINUTE} requests/minute")
        print(f"‚è±Ô∏è  Estimated time: ~{(total_filtered_ips * DELAY_BETWEEN_REQUESTS) / 60:.1f} minutes")
        print("\nüîç Starting geolocation lookups...")
        print("=" * 70)
    
    # Initialize results storage
    results = []
    country_stats = defaultdict(int)
    region_stats = defaultdict(int)
    isp_stats = defaultdict(int)
    
    for i, (ip, activities, first_seen, last_seen) in enumerate(ip_data, 1):
        if CONSOLE_OUTPUT_ENABLED:
            print(f"\n[{i:2}/{total_filtered_ips}] {format_ip_for_display(ip)} ({activities} activities)")
            if first_seen and last_seen:
                print(f"         First: {first_seen.strftime('%Y-%m-%d %H:%M')} | Last: {last_seen.strftime('%Y-%m-%d %H:%M')}")
            else:
                print(f"         First/Last: Unknown")
        
        # Rate limiting
        if i > 1:
            time.sleep(DELAY_BETWEEN_REQUESTS)
        
        # Geolocate the IP
        location = geolocate_ip(ip)
        
        if location:
            if CONSOLE_OUTPUT_ENABLED:
                print(f"         üìç {location['city']}, {location['region']}, {location['country']}")
                print(f"         üåê ISP: {location['isp']}")
                print(f"         üïê Timezone: {location['timezone']}")
            
            # Store results
            result = {
                'ip': ip,
                'ip_display': format_ip_for_display(ip),
                'activities': activities,
                'first_seen': first_seen,
                'last_seen': last_seen,
                'location': location
            }
            results.append(result)
            
            # Update statistics
            country_stats[location['country']] += activities
            region_key = f"{location['region']}, {location['country']}"
            region_stats[region_key] += activities
            isp_stats[location['isp']] += activities
            
        else:
            if CONSOLE_OUTPUT_ENABLED:
                print(f"         ‚ùå Geolocation failed")
            
            if INCLUDE_FAILED_GEOLOCATIONS:
                # Store failed result
                result = {
                    'ip': ip,
                    'ip_display': format_ip_for_display(ip),
                    'activities': activities,
                    'first_seen': first_seen,
                    'last_seen': last_seen,
                    'location': None
                }
                results.append(result)
    
    # Print summary statistics
    if CONSOLE_OUTPUT_ENABLED:
        print("\n" + "=" * 70)
        print("üìä GEOLOCATION SUMMARY")
        print("=" * 70)
        
        successful_lookups = len([r for r in results if r['location']])
        print(f"‚úÖ Successful lookups: {successful_lookups}/{len(results)} ({successful_lookups/len(results)*100:.1f}%)")
        
        print(f"\nüåç TOP COUNTRIES BY ACTIVITY:")
        for country, activities in sorted(country_stats.items(), key=lambda x: x[1], reverse=True):
            print(f"   {country:<20} {activities:>3} activities")
        
        print(f"\nüèôÔ∏è  TOP REGIONS BY ACTIVITY:")
        for region, activities in sorted(region_stats.items(), key=lambda x: x[1], reverse=True):
            print(f"   {region:<35} {activities:>3} activities")
        
        print(f"\nüîó TOP ISPs BY ACTIVITY:")
        for isp, activities in sorted(isp_stats.items(), key=lambda x: x[1], reverse=True):
            isp_display = isp[:40] + "..." if len(isp) > 40 else isp
            print(f"   {isp_display:<43} {activities:>3} activities")
        
        print(f"\nüéÆ ALL {total_filtered_ips} LEGITIMATE PLAYERS SORTED BY CITY:")
        print("-" * 70)
        
        # Sort results by city for final display
        results_by_city = sorted(results, key=lambda x: (
            x['location']['city'] if x['location'] else 'zzz_Unknown',
            x['location']['region'] if x['location'] else '',
            x['location']['country'] if x['location'] else ''
        ))
        
        for result in results_by_city:
            ip_display = result['ip_display']
            activities = result['activities']
            
            if result['location']:
                loc = result['location']
                location_str = f"{loc['city']}, {loc['region']}, {loc['country']}"
                print(f"{ip_display:<12} | {activities:>3} activities | {location_str}")
            else:
                print(f"{ip_display:<12} | {activities:>3} activities | Location unknown")
        
        total_activities_filtered = sum(r['activities'] for r in results)
        total_activities_all = sum(ip[1] for ip in all_ip_data)
        spam_activities = total_activities_all - total_activities_filtered
        
        print(f"\nüéØ LEGITIMATE PLAYERS: {len(results)} players, {total_activities_filtered} activities")
        print(f"ü§ñ FILTERED OUT: {filtered_out} likely spam/bot IPs, {spam_activities} activities")
        print(f"üåç TOTAL IN DATABASE: {total_all_ips} IPs, {total_activities_all} total activities")
    
    # Enhanced CSV export
    if CSV_EXPORT_ENABLED:
        if CONSOLE_OUTPUT_ENABLED:
            print(f"\nüíæ Saving enhanced results to multiple CSV files...")
        
        saved_files = save_enhanced_results_to_csv(results, all_ip_data)
        
        if saved_files and CONSOLE_OUTPUT_ENABLED:
            print(f"\nüìä Enhanced CSV Export Complete!")
            print(f"üìÅ Saved {len(saved_files)} CSV files:")
            for file in saved_files:
                print(f"   - {file}")
            
            print(f"\nüìã CSV Features:")
            print(f"   - Full IP addresses: {'Yes' if not IP_MASK_IN_CSV else 'No (masked)'}")
            print(f"   - Geographic coordinates: Yes (for mapping)")
            print(f"   - Activity patterns: Yes (span, frequency)")
            print(f"   - Player classification: Yes (Heavy/Regular/Casual/Light)")
            print(f"   - Separate breakdowns: Countries, Regions, ISPs")
            print(f"   - Sortable timestamps: Yes (ISO format)")
            print(f"   - Google Sheets ready: Yes")
            
            print(f"\nüîç Analysis Tips:")
            print(f"   - Import comprehensive CSV to Google Sheets")
            print(f"   - Sort by country/region to see geographic distribution")
            print(f"   - Filter by player_type to focus on active users")
            print(f"   - Use lat/lon columns for mapping visualization")
            print(f"   - Check activities_per_day for engagement patterns")
    
    if CONSOLE_OUTPUT_ENABLED:
        print("\n‚ú® Enhanced spam-filtered geolocation analysis complete!")

if __name__ == "__main__":
    main()

================================================================================

FILE: ./utilities/postgres_utils.py
--------------------------------------------------------------------------------
"""
Two-Man Spades PostgreSQL Utilities - Updated for Hands Table
"""
import psycopg2
import psycopg2.extras
import json
import os
from datetime import datetime
from google.cloud import secretmanager
from typing import Dict, Any, Optional, List


def get_monthly_stats_by_location():
    """Get monthly statistics grouped by family member location"""
    query = """
        SELECT 
            DATE_TRUNC('month', h.started_at) as month,
            CASE
                WHEN loc.city = 'Helena' AND loc.region = 'Montana' THEN 'Helena'
                WHEN loc.city IN ('Missoula', 'Blackfoot') AND loc.region = 'Montana' THEN 'Elliston'
                WHEN loc.city IN ('Rocklin', 'Sacramento') AND loc.region = 'California' THEN 'Rocklin'
                WHEN loc.city IN ('Bellevue', 'Seattle', 'Bothell', 'Redmond') AND loc.region = 'Washington' THEN 'Bothell'
                WHEN loc.region = 'Washington' THEN 'Bothell'
                WHEN loc.region = 'Montana' AND loc.city IS NOT NULL THEN 'Helena'
                WHEN loc.region = 'California' AND loc.city IS NOT NULL THEN 'Rocklin'
                ELSE 'Other'
            END as family_member,
            COUNT(*) as hands_played,
            SUM(CASE WHEN h.hand_player_score > h.hand_computer_score THEN 1 ELSE 0 END) as hands_won,
            SUM(CASE WHEN h.hand_player_score < h.hand_computer_score THEN 1 ELSE 0 END) as hands_lost,
            ROUND(AVG(h.hand_player_score), 2) as avg_player_score,
            ROUND(AVG(h.hand_computer_score), 2) as avg_computer_score,
            SUM(h.player_bags) as total_bags
        FROM twomanspades.hands h
        JOIN twomanspades.players p ON h.player_id = p.player_id
        LEFT JOIN twomanspades.ip_location_data loc ON p.ip_address = loc.ip_address
        WHERE h.completed_at IS NOT NULL
        GROUP BY DATE_TRUNC('month', h.started_at), 
            CASE
                WHEN loc.city = 'Helena' AND loc.region = 'Montana' THEN 'Helena'
                WHEN loc.city IN ('Missoula', 'Blackfoot') AND loc.region = 'Montana' THEN 'Elliston'
                WHEN loc.city IN ('Rocklin', 'Sacramento') AND loc.region = 'California' THEN 'Rocklin'
                WHEN loc.city IN ('Bellevue', 'Seattle', 'Bothell', 'Redmond') AND loc.region = 'Washington' THEN 'Bothell'
                WHEN loc.region = 'Washington' THEN 'Bothell'
                WHEN loc.region = 'Montana' AND loc.city IS NOT NULL THEN 'Helena'
                WHEN loc.region = 'California' AND loc.city IS NOT NULL THEN 'Rocklin'
                ELSE 'Other'
            END
        HAVING CASE
            WHEN loc.city = 'Helena' AND loc.region = 'Montana' THEN 'Helena'
            WHEN loc.city IN ('Missoula', 'Blackfoot') AND loc.region = 'Montana' THEN 'Elliston'
            WHEN loc.city IN ('Rocklin', 'Sacramento') AND loc.region = 'California' THEN 'Rocklin'
            WHEN loc.city IN ('Bellevue', 'Seattle', 'Bothell', 'Redmond') AND loc.region = 'Washington' THEN 'Bothell'
            WHEN loc.region = 'Washington' THEN 'Bothell'
            WHEN loc.region = 'Montana' AND loc.city IS NOT NULL THEN 'Helena'
            WHEN loc.region = 'California' AND loc.city IS NOT NULL THEN 'Rocklin'
            ELSE 'Other'
        END != 'Other'
        ORDER BY family_member, month DESC;
    """
    
    conn = get_db_connection()
    cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
    cur.execute(query)
    results = cur.fetchall()
    cur.close()
    conn.close()
    
    # Organize by family member with current month first
    organized = {}
    for row in results:
        member = row['family_member']
        if member not in organized:
            organized[member] = {'monthly': [], 'lifetime': None}
        organized[member]['monthly'].append(row)
    
    return organized

def get_secret(secret_id: str, project_id: str = "kumori-404602") -> str:
    """Get secret from Google Secret Manager"""
    client = secretmanager.SecretManagerServiceClient()
    name = f"projects/{project_id}/secrets/{secret_id}/versions/latest"
    response = client.access_secret_version(request={"name": name})
    return response.payload.data.decode('UTF-8')

def get_db_connection():
    """Create database connection using TWOMANSPADES secrets"""
    is_gcp = os.environ.get('GAE_ENV', '').startswith('standard')
    
    if is_gcp:
        # Production - use secrets and Cloud SQL socket
        connection_name = get_secret('TWOMANSPADES_POSTGRES_CONNECTION_NAME')
        host = f"/cloudsql/{connection_name}"
        dbname = get_secret('TWOMANSPADES_POSTGRES_DB_NAME') 
        user = get_secret('TWOMANSPADES_POSTGRES_USERNAME')
        password = get_secret('TWOMANSPADES_POSTGRES_PASSWORD')
    else:
        # Local development - use environment variables or direct secrets
        try:
            # Try secrets first (in case you want to test with real DB locally)
            host = get_secret('TWOMANSPADES_POSTGRES_IP')
            dbname = get_secret('TWOMANSPADES_POSTGRES_DB_NAME')
            user = get_secret('TWOMANSPADES_POSTGRES_USERNAME')
            password = get_secret('TWOMANSPADES_POSTGRES_PASSWORD')
        except:
            # Fallback to env vars for local dev
            host = os.getenv('DB_HOST', 'localhost')
            dbname = os.getenv('DB_NAME', 'twomanspades_dev')
            user = os.getenv('DB_USER', 'postgres') 
            password = os.getenv('DB_PASSWORD', 'password')
    
    return psycopg2.connect(
        host=host,
        database=dbname,
        user=user,
        password=password,
        connect_timeout=10
    )

def test_connection():
    """Test database connection"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT version();")
        version = cur.fetchone()
        print(f"PostgreSQL connection successful: {version[0]}")
        cur.close()
        conn.close()
        return True
    except Exception as e:
        print(f"Database connection failed: {e}")
        return False

def insert_hand(hand_data: Dict[str, Any]) -> bool:
    """Insert new hand record"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        # Debug: print what we're trying to insert
        print(f"Attempting to insert hand: {hand_data.get('hand_id')}")
        
        cur.execute("""
            INSERT INTO twomanspades.hands 
            (hand_id, started_at, player_parity, computer_parity, first_leader, client_ip, user_agent)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, (
            hand_data['hand_id'],
            datetime.fromtimestamp(hand_data['game_started_at']),  # Still using game_started_at from session
            hand_data['player_parity'],
            hand_data['computer_parity'], 
            hand_data['first_leader'],
            hand_data.get('client_info', {}).get('ip_address'),
            hand_data.get('client_info', {}).get('user_agent')
        ))
        
        conn.commit()
        cur.close()
        conn.close()
        print(f"Hand {hand_data.get('hand_id')} successfully inserted")
        return True
    except Exception as e:
        print(f"Failed to insert hand {hand_data.get('hand_id')}: {e}")
        # Try to close connection if it exists
        try:
            if 'conn' in locals():
                conn.close()
        except:
            pass
        return False

def log_game_event_to_db(hand_id: str, event_type: str, event_data: Dict, **kwargs) -> bool:
    """Log game event to database using hand_id"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        cur.execute("""
            INSERT INTO twomanspades.game_events 
            (hand_id, event_type, event_data, hand_number, session_sequence, player, action_type, client_ip)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            hand_id,
            event_type,
            json.dumps(event_data),
            kwargs.get('hand_number'),
            kwargs.get('session_sequence'),
            kwargs.get('player'),
            kwargs.get('action_type'),
            kwargs.get('client_ip')
        ))
        
        conn.commit()
        cur.close()
        conn.close()
        return True
    except Exception as e:
        print(f"Failed to log event: {e}")
        return False

def finalize_hand(hand_id: str, final_data: Dict[str, Any]) -> bool:
    """Update hand record when hand completes"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        cur.execute("""
            UPDATE twomanspades.hands 
            SET completed_at = %s,
                hand_player_score = %s,
                hand_computer_score = %s,
                player_bags = %s,
                computer_bags = %s
            WHERE hand_id = %s
        """, (
            datetime.now(),
            final_data.get('player_score', 0),
            final_data.get('computer_score', 0),
            final_data.get('player_bags', 0),
            final_data.get('computer_bags', 0),
            hand_id
        ))
        
        conn.commit()
        cur.close()
        conn.close()
        return True
    except Exception as e:
        print(f"Failed to finalize hand: {e}")
        return False

def upsert_player(ip_address: str, user_agent: str = None) -> Optional[int]:
    """Create or update player record, return player_id"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        cur.execute("""
            INSERT INTO twomanspades.players (ip_address, user_agent_latest, total_games)
            VALUES (%s, %s, 0)
            ON CONFLICT (ip_address) DO UPDATE SET
                last_seen = NOW(),
                user_agent_latest = COALESCE(EXCLUDED.user_agent_latest, players.user_agent_latest)
            RETURNING player_id
        """, (ip_address, user_agent))
        
        player_id = cur.fetchone()[0]
        conn.commit()
        cur.close()
        conn.close()
        return player_id
    except Exception as e:
        print(f"Failed to upsert player: {e}")
        return None

def batch_log_events(hand_id: str, events: List[Dict]) -> bool:
    """Log multiple events in a single database transaction"""
    if not events:
        return True
    
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        events_data = []
        for event in events:
            events_data.append((
                hand_id,
                event.get('event_type'),
                json.dumps(event.get('event_data', {})),
                event.get('hand_number'),
                event.get('session_sequence'),
                event.get('player'),
                event.get('action_type'),
                event.get('client_ip')
            ))
        
        cur.executemany("""
            INSERT INTO twomanspades.game_events 
            (hand_id, event_type, event_data, hand_number, session_sequence, player, action_type, client_ip)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """, events_data)
        
        conn.commit()
        cur.close()
        conn.close()
        return True
    except Exception as e:
        print(f"Batch event logging failed: {e}")
        try:
            if 'conn' in locals():
                conn.rollback()
                conn.close()
        except:
            pass
        return False

def create_hand_with_player(hand_data: Dict[str, Any], client_info: Dict[str, Any] = None) -> bool:
    """Create hand and update player in single transaction"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        player_id = None
        if client_info:
            ip_address = client_info.get('ip_address')
            user_agent = client_info.get('user_agent')
            
            # Update player stats - increment total_hands instead of total_games
            cur.execute("""
                INSERT INTO twomanspades.players (ip_address, user_agent_latest, total_hands)
                VALUES (%s, %s, 1)
                ON CONFLICT (ip_address) DO UPDATE SET
                    last_seen = NOW(),
                    user_agent_latest = EXCLUDED.user_agent_latest,
                    total_hands = players.total_hands + 1
                RETURNING player_id
            """, (ip_address, user_agent))
            
            player_id = cur.fetchone()[0]
        
        # Insert hand record using current_hand_id from game data
        cur.execute("""
            INSERT INTO twomanspades.hands 
            (hand_id, started_at, player_parity, computer_parity, first_leader, 
             client_ip, user_agent, player_id)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """, (
            hand_data['current_hand_id'],  # Use current_hand_id instead of game_id
            datetime.fromtimestamp(hand_data['game_started_at']),
            hand_data['player_parity'],
            hand_data['computer_parity'], 
            hand_data['first_leader'],
            client_info.get('ip_address') if client_info else None,
            client_info.get('user_agent') if client_info else None,
            player_id
        ))
        
        conn.commit()
        cur.close()
        conn.close()
        return True
    except Exception as e:
        print(f"Failed to create hand with player: {e}")
        try:
            if 'conn' in locals():
                conn.rollback()
                conn.close()
        except:
            pass
        return False

# Legacy function names for backward compatibility
def insert_game(game_data: Dict[str, Any]) -> bool:
    """Legacy wrapper - use insert_hand instead"""
    return insert_hand(game_data)

def finalize_game(game_id: str, final_data: Dict[str, Any]) -> bool:
    """Legacy wrapper - use finalize_hand instead"""
    return finalize_hand(game_id, final_data)

def create_game_with_player(game_data: Dict[str, Any], client_info: Dict[str, Any] = None) -> bool:
    """Legacy wrapper - use create_hand_with_player instead"""
    return create_hand_with_player(game_data, client_info)

def get_ip_address_game_stats(client_ip: str = None) -> List[Dict[str, Any]]:
    """Get game statistics from the view, optionally filtered by IP address"""
    try:
        conn = get_db_connection()
        cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
        
        if client_ip:
            cur.execute("""
                SELECT * FROM twomanspades.vw_ip_address_game_win_loss_stats 
                WHERE client_ip = %s
                ORDER BY total_games DESC, win_rate DESC
            """, (client_ip,))
        else:
            cur.execute("""
                SELECT * FROM twomanspades.vw_ip_address_game_win_loss_stats 
                ORDER BY total_games DESC, win_rate DESC
            """)
        
        results = cur.fetchall()
        cur.close()
        conn.close()
        
        # Convert to list of dicts for easier handling
        return [dict(row) for row in results]
        
    except Exception as e:
        print(f"Failed to get game stats: {e}")
        return []
    
# Replace the save_ip_location_data function in postgres_utils.py

def save_ip_location_data(ip_address: str, location_data: Dict[str, Any]) -> bool:
    """Save IP location data - ONLY data that comes from the IP API call"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        cur.execute("""
            INSERT INTO twomanspades.ip_location_data 
            (ip_address, country, region, city, latitude, longitude, timezone, zip_code,
             isp, org, as_info, lookup_success)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            ON CONFLICT (ip_address) DO UPDATE SET
                country = EXCLUDED.country,
                region = EXCLUDED.region,
                city = EXCLUDED.city,
                latitude = EXCLUDED.latitude,
                longitude = EXCLUDED.longitude,
                timezone = EXCLUDED.timezone,
                zip_code = EXCLUDED.zip_code,
                isp = EXCLUDED.isp,
                org = EXCLUDED.org,
                as_info = EXCLUDED.as_info,
                lookup_success = EXCLUDED.lookup_success,
                created_at = NOW()
        """, (
            ip_address,
            location_data.get('country'),
            location_data.get('region'),
            location_data.get('city'),
            location_data.get('lat'),
            location_data.get('lon'),
            location_data.get('timezone'),
            location_data.get('zip'),
            location_data.get('isp'),
            location_data.get('org'),
            location_data.get('as'),  # Store the full AS string
            True  # lookup_success
        ))
        
        conn.commit()
        cur.close()
        conn.close()
        return True
        
    except Exception as e:
        print(f"Failed to save IP location data for {ip_address}: {e}")
        try:
            if 'conn' in locals():
                conn.rollback()
                conn.close()
        except:
            pass
        return False

def save_failed_ip_lookup(ip_address: str) -> bool:
    """Save a record for failed IP lookup"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        cur.execute("""
            INSERT INTO twomanspades.ip_location_data (ip_address, lookup_success)
            VALUES (%s, %s)
            ON CONFLICT (ip_address) DO UPDATE SET
                lookup_success = EXCLUDED.lookup_success,
                created_at = NOW()
        """, (ip_address, False))
        
        conn.commit()
        cur.close()
        conn.close()
        return True
        
    except Exception as e:
        print(f"Failed to save failed lookup for {ip_address}: {e}")
        return False

def get_player_city_membership(client_ip):
    """Get which city/family member this IP belongs to"""
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        # Query the ip_location_data to determine city mapping
        cur.execute("""
            SELECT city, region, country FROM twomanspades.ip_location_data 
            WHERE ip_address = %s AND lookup_success = true
        """, (client_ip,))
        
        result = cur.fetchone()
        cur.close()
        conn.close()
        
        if not result:
            return 'Other'
            
        city, region, country = result
        
        # Apply the same logic as the view
        if city == 'Helena' and region == 'Montana':
            return 'Helena'
        elif city in ['Missoula', 'Blackfoot'] and region == 'Montana':
            return 'Elliston'
        elif city in ['Rocklin', 'Sacramento'] and region == 'California':
            return 'Rocklin'
        elif city in ['Bellevue', 'Seattle', 'Bothell', 'Redmond'] and region == 'Washington':
            return 'Bothell'
        elif region == 'Washington':
            return 'Bothell'
        elif region == 'Montana' and city:
            return 'Helena'
        elif region == 'California' and city:
            return 'Rocklin'
        else:
            return 'Other'
            
    except Exception as e:
        print(f"Failed to get player city membership: {e}")
        return 'Other'
    
def get_competitive_leaders_stats() -> List[Dict[str, Any]]:
    """Get competitive win/loss records from vw_city_leaders view"""
    try:
        conn = get_db_connection()
        cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
        
        cur.execute("""
            SELECT family_member, unique_ips, games_started, total_games, 
                   games_abandoned, total_wins, total_losses, win_rate_percent,
                   avg_winning_score, avg_winning_margin, avg_losing_score, avg_losing_margin
            FROM twomanspades.vw_city_leaders 
            ORDER BY win_rate_percent DESC, total_games DESC
        """)
        
        results = cur.fetchall()
        cur.close()
        conn.close()
        
        return [dict(row) for row in results]
        
    except Exception as e:
        print(f"Failed to get competitive leaders stats: {e}")
        return []


def get_city_leaders_stats() -> List[Dict[str, Any]]:
    """Get detailed hand performance stats from vw_city_leaders_totals view"""
    try:
        conn = get_db_connection()
        cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
        
        cur.execute("""
            SELECT family_member, total_hands_with_bids, total_hands_with_scoring,
                   avg_player_bid, avg_computer_bid, total_player_nil_bids,
                   total_player_nils_successful,
                   total_player_bags, total_computer_bags, 
                   avg_player_bags, avg_computer_bags
            FROM twomanspades.vw_city_leaders_totals 
            ORDER BY total_hands_with_bids DESC
        """)
        
        results = cur.fetchall()
        cur.close()
        conn.close()
        
        return [dict(row) for row in results]
        
    except Exception as e:
        print(f"Failed to get city leaders stats: {e}")
        return []

================================================================================

FILE: ./utilities/gameplay_logic.py
--------------------------------------------------------------------------------
import random

def create_deck():
    """Create a standard 52-card deck"""
    suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£']
    ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
    deck = []
    for suit in suits:
        for rank in ranks:
            deck.append({'rank': rank, 'suit': suit, 'value': get_card_value(rank)})
    return deck

def get_card_value(rank):
    """Get numerical value of a card rank"""
    if rank == 'A':
        return 14
    elif rank == 'K':
        return 13
    elif rank == 'Q':
        return 12
    elif rank == 'J':
        return 11
    else:
        return int(rank)

def sort_hand(hand):
    """Sort hand by suit (clubs, diamonds, hearts, spades) then by value"""
    suit_order = {'‚ô£': 0, '‚ô¶': 1, '‚ô•': 2, '‚ô†': 3}
    return sorted(hand, key=lambda x: (suit_order[x['suit']], x['value']))

def init_game(player_parity='even', computer_parity='odd', first_leader='player'):
    """Initialize a new game"""
    deck = create_deck()
    random.shuffle(deck)
    
    game = {
        'player_hand': sort_hand(deck[:11]),
        'computer_hand': sort_hand(deck[11:22]),
        'current_trick': [],
        'player_tricks': 0,
        'computer_tricks': 0,
        'spades_broken': False,
        'phase': 'discard',
        'turn': 'player',  # Both players can discard simultaneously
        'trick_leader': None,
        'hand_over': False,
        'game_over': False,
        'winner': None,
        'message': 'Select a card to discard',
        'player_discarded': None,
        'computer_discarded': None,
        'show_computer_hand': False,
        'trick_display_timer': None,
        'player_bid': None,
        'computer_bid': None,
        'total_tricks': 10,
        'player_score': 0,
        'computer_score': 0,
        'player_bags': 0,
        'computer_bags': 0,
        'player_trick_special_cards': 0,
        'computer_trick_special_cards': 0,
        'hand_number': 1,
        'target_score': 300,
        'player_parity': player_parity,
        'computer_parity': computer_parity,
        'first_leader': first_leader,  # Who leads the first trick of each hand
        'discard_bonus_explanation': None,
        'pending_discard_result': None,
        'pending_special_discard_result': None,
        'blind_bidding_available': False,
        'blind_bid': None,
        'computer_blind_bid': None,
        'blind_multiplier': 2,
        'trick_history': []  # Track all tricks played this hand
    }
    
    # Log initial hands dealt for first hand
    from .logging_utils import log_game_event
    
    # Log player's starting hand
    player_hand_cards = [f"{card['rank']}{card['suit']}" for card in game['player_hand']]
    log_game_event(
        event_type='hand_dealt',
        event_data={
            'hand_number': game['hand_number'],
            'player': 'player',
            'cards': player_hand_cards,
            'card_count': len(player_hand_cards)
        },
        session={'game': game}
    )
    
    # Log computer's starting hand
    computer_hand_cards = [f"{card['rank']}{card['suit']}" for card in game['computer_hand']]
    log_game_event(
        event_type='hand_dealt',
        event_data={
            'hand_number': game['hand_number'],
            'player': 'computer',
            'cards': computer_hand_cards,
            'card_count': len(computer_hand_cards)
        },
        session={'game': game}
    )
    
    return game


def init_new_hand(game):
    """Start a new hand while preserving scores, bags, and parity assignments"""
    deck = create_deck()
    random.shuffle(deck)
    
    # Alternate who leads the first trick each hand
    current_first_leader = game.get('first_leader', 'player')
    next_first_leader = 'computer' if current_first_leader == 'player' else 'player'
    
    # Get current scores and bags for blind eligibility check
    player_base_score = game.get('player_score', 0)
    computer_base_score = game.get('computer_score', 0)
    player_bags = game.get('player_bags', 0)
    computer_bags = game.get('computer_bags', 0)
    
    # Calculate display scores for blind eligibility check (what players actually see)
    def calc_display_score(base_score, bags):
        if bags >= 0:
            if base_score < 0:
                tens_and_higher = (base_score // 10) * 10
                return tens_and_higher - bags
            else:
                tens_and_higher = (base_score // 10) * 10
                return tens_and_higher + bags
        else:
            return base_score
    
    player_display_score = calc_display_score(player_base_score, player_bags)
    computer_display_score = calc_display_score(computer_base_score, computer_bags)
    
    # Check eligibility based on display scores (not base scores)
    from .custom_rules import check_blind_bidding_eligibility
    blind_eligibility = check_blind_bidding_eligibility(player_display_score, computer_display_score)
    
    # Set initial phase and message based on blind eligibility
    if blind_eligibility['player_eligible']:
        initial_phase = 'blind_decision'
        deficit = computer_display_score - player_display_score
        initial_message = f'You are down by {deficit} points. Choose: Go BLIND for double points/penalties, or bid normally?'
    else:
        initial_phase = 'discard'
        initial_message = f'Hand #{game["hand_number"]} - Select a card to discard'
    
    game.update({
        'player_hand': sort_hand(deck[:11]),
        'computer_hand': sort_hand(deck[11:22]),
        'current_trick': [],
        'player_tricks': 0,
        'computer_tricks': 0,
        'spades_broken': False,
        'phase': initial_phase,
        'turn': 'player',
        'trick_leader': None,
        'hand_over': False,
        'message': initial_message,
        'player_discarded': None,
        'computer_discarded': None,
        'show_computer_hand': False,
        'trick_display_timer': None,
        'player_bid': None,
        'computer_bid': None,
        'total_tricks': 10,
        'discard_bonus_explanation': None,
        'player_trick_special_cards': 0,
        'computer_trick_special_cards': 0,
        'pending_discard_result': None,
        'pending_special_discard_result': None,
        'blind_bidding_available': blind_eligibility['player_eligible'],
        'blind_bid': None,
        'computer_blind_bid': None,
        'first_leader': next_first_leader,
        'trick_history': []
    })
    
    # Log starting hands for this new hand
    from .logging_utils import log_game_event
    
    # Log player's starting hand
    player_hand_cards = [f"{card['rank']}{card['suit']}" for card in game['player_hand']]
    log_game_event(
        event_type='hand_dealt',
        event_data={
            'hand_number': game['hand_number'],
            'player': 'player',
            'cards': player_hand_cards,
            'card_count': len(player_hand_cards)
        },
        session={'game': game}
    )
    
    # Log computer's starting hand
    computer_hand_cards = [f"{card['rank']}{card['suit']}" for card in game['computer_hand']]
    log_game_event(
        event_type='hand_dealt',
        event_data={
            'hand_number': game['hand_number'],
            'player': 'computer',
            'cards': computer_hand_cards,
            'card_count': len(computer_hand_cards)
        },
        session={'game': game}
    )

def computer_bidding_brain(computer_hand, player_bid, game_state=None):
    """
    Computer bidding function - now delegates to computer_logic module
    """
    if game_state is None:
        # Fallback for backward compatibility
        game_state = {'player_score': 0, 'computer_score': 0, 'computer_bags': 0}
    
    from .computer_logic import computer_bidding_brain as enhanced_brain
    return enhanced_brain(computer_hand, player_bid, game_state)

def computer_discard_strategy(computer_hand, game_state=None):
    """
    Computer discard strategy - now delegates to computer_logic module
    """
    if game_state is None:
        # Fallback to simple strategy for backward compatibility
        computer_discards = []
        for i, card in enumerate(computer_hand):
            if card['suit'] != '‚ô†':
                computer_discards.append((i, card['value']))
        
        if computer_discards:
            return min(computer_discards, key=lambda x: x[1])[0]
        else:
            return 0
    
    from .computer_logic import computer_discard_strategy as enhanced_discard
    return enhanced_discard(computer_hand, game_state)

def is_valid_play(card, hand, trick, spades_broken):
    """Check if a card play is valid according to Spades rules"""
    if len(trick) == 0:
        # Leading
        if card['suit'] == '‚ô†' and not spades_broken:
            # Can only lead spades if no other suits
            for c in hand:
                if c['suit'] != '‚ô†':
                    return False
        return True
    else:
        # Following
        lead_suit = trick[0]['card']['suit']
        # Must follow suit if possible
        has_suit = any(c['suit'] == lead_suit for c in hand)
        if has_suit:
            return card['suit'] == lead_suit
        return True

def determine_trick_winner(trick):
    """
    Determine who won a completed trick
    Returns the player who won ('player' or 'computer')
    """
    if len(trick) != 2:
        return None
    
    first = trick[0]
    second = trick[1]
    
    if first['card']['suit'] == second['card']['suit']:
        # Same suit, higher value wins
        if first['card']['value'] > second['card']['value']:
            return first['player']
        else:
            return second['player']
    elif first['card']['suit'] == '‚ô†':
        # First player trumped
        return first['player']
    elif second['card']['suit'] == '‚ô†':
        # Second player trumped  
        return second['player']
    else:
        # Different suits, no trump - first player (leader) wins
        return first['player']

def resolve_trick_with_delay(game):
    """Resolve trick and set it up to be displayed for 3 seconds"""
    if len(game['current_trick']) != 2:
        return
    
    winner = determine_trick_winner(game['current_trick'])
    
    # SAVE TRICK TO HISTORY BEFORE PROCESSING
    trick_number = len(game.get('trick_history', [])) + 1
    player_card = next((play['card'] for play in game['current_trick'] if play['player'] == 'player'), None)
    computer_card = next((play['card'] for play in game['current_trick'] if play['player'] == 'computer'), None)
    
    game.setdefault('trick_history', []).append({
        'number': trick_number,
        'player_card': player_card,
        'computer_card': computer_card,
        'winner': winner
    })
    
    # LOG EACH TRICK TO CONSOLE
    p_text = f"{player_card['rank']}{player_card['suit']}" if player_card else "?"
    c_text = f"{computer_card['rank']}{computer_card['suit']}" if computer_card else "?"
    winner_name = "You" if winner == 'player' else "Marta"
    print(f"TRICK {trick_number}: {p_text} vs {c_text} -> {winner_name} wins")
    
    
    # Check for special cards in the trick and apply bag reduction IMMEDIATELY
    from utilities.custom_rules import check_special_cards_in_trick, reduce_bags_safely
    special_result = check_special_cards_in_trick(game['current_trick'], winner)
    
    if special_result['bag_reduction'] > 0:
        if winner == 'player':
            current_bags = game.get('player_bags', 0)
            game['player_bags'] = reduce_bags_safely(current_bags, special_result['bag_reduction'])
            game['player_trick_special_cards'] = game.get('player_trick_special_cards', 0) + special_result['bag_reduction']
        else:
            current_bags = game.get('computer_bags', 0)
            game['computer_bags'] = reduce_bags_safely(current_bags, special_result['bag_reduction'])
            game['computer_trick_special_cards'] = game.get('computer_trick_special_cards', 0) + special_result['bag_reduction']
        
        game['special_card_message'] = special_result['explanation']
    
    # Award trick
    if winner == 'player':
        game['player_tricks'] += 1
        base_message = 'You won the trick!'
    else:
        game['computer_tricks'] += 1
        base_message = 'Marta won the trick!'
    
    # Add special card info to message if present
    if special_result['explanation']:
        game['message'] = f"{base_message} {special_result['explanation']} Cards will clear in 3 seconds..."
    else:
        game['message'] = f"{base_message} Cards will clear in 3 seconds..."
    
    # Mark trick as completed but don't clear yet
    game['trick_completed'] = True
    game['trick_winner'] = winner

def computer_follow(game):
    """Computer plays a card when following - now uses bag avoidance strategy"""
    hand = game['computer_hand']
    trick = game['current_trick']
    
    if not trick or not hand:
        return
    
    # Use enhanced following strategy from computer_logic
    from .computer_logic import computer_follow_strategy
    chosen_idx = computer_follow_strategy(hand, trick, game)
    
    if chosen_idx is None:
        # Fallback to original simple logic if strategy fails
        lead_card = trick[0]['card']
        lead_suit = lead_card['suit']
        lead_value = lead_card['value']
        
        # Find valid plays
        same_suit = [(i, c) for i, c in enumerate(hand) if c['suit'] == lead_suit]
        spades = [(i, c) for i, c in enumerate(hand) if c['suit'] == '‚ô†']
        
        if same_suit:
            # Must follow suit - try to win with lowest winning card
            winners = [(i, c) for i, c in same_suit if c['value'] > lead_value]
            if winners:
                chosen_idx = min(winners, key=lambda x: x[1]['value'])[0]
            else:
                # Can't win, play lowest
                chosen_idx = min(same_suit, key=lambda x: x[1]['value'])[0]
        elif lead_suit != '‚ô†' and spades:
            # Can't follow suit, can trump with spade
            chosen_idx = min(spades, key=lambda x: x[1]['value'])[0]
        else:
            # Can't follow or trump, discard lowest
            all_cards = [(i, c) for i, c in enumerate(hand)]
            chosen_idx = min(all_cards, key=lambda x: x[1]['value'])[0]
    
    # Play the chosen card
    card = hand.pop(chosen_idx)
    game['current_trick'].append({'player': 'computer', 'card': card})
    
    if card['suit'] == '‚ô†':
        game['spades_broken'] = True

def computer_lead(game):
    """Computer plays a card when leading - now uses enhanced strategy"""
    hand = game['computer_hand']
    
    if not hand:
        return
    
    # Use enhanced leading strategy from computer_logic
    from .computer_logic import computer_lead_strategy
    chosen_idx = computer_lead_strategy(hand, game['spades_broken'], game)

    
    if chosen_idx is None:
        # Fallback to original simple logic if strategy fails
        valid = []
        for i, card in enumerate(hand):
            if card['suit'] != '‚ô†' or game['spades_broken'] or all(c['suit'] == '‚ô†' for c in hand):
                valid.append((i, card))
        
        if valid:
            chosen = min(valid, key=lambda x: (x[1]['suit'] == '‚ô†', x[1]['value']))
            chosen_idx = chosen[0]
        else:
            return
    
    # Play the chosen card
    card = hand.pop(chosen_idx)
    game['current_trick'] = [{'player': 'computer', 'card': card}]
    game['trick_leader'] = 'computer'
    
    if card['suit'] == '‚ô†':
        game['spades_broken'] = True


def check_game_over(game):
    """
    Check if the game is over (someone reached target score OR down by 300+ points)
    Updates game state with winner information if game is over
    
    SIMPLE RULE: Higher display score ALWAYS wins!
    - 302 beats 300 (regardless of bags)
    - 301 beats 300 (regardless of bags)
    - Bags only matter as tie-breaker when display scores are EXACTLY tied
    - More bags (further from 0) is always worse, whether positive or negative
    """
    player_base_score = game['player_score']
    computer_base_score = game['computer_score']
    player_bags = game.get('player_bags', 0)
    computer_bags = game.get('computer_bags', 0)
    target_score = game['target_score']
    
    # Calculate display scores inline (no import needed)
    def calc_display_score(base_score, bags):
        if bags >= 0:
            if base_score < 0:
                tens_and_higher = (base_score // 10) * 10
                return tens_and_higher - bags
            else:
                tens_and_higher = (base_score // 10) * 10
                return tens_and_higher + bags
        else:
            return base_score
    
    player_display_score = calc_display_score(player_base_score, player_bags)
    computer_display_score = calc_display_score(computer_base_score, computer_bags)
    
    # Check for 300-point deficit rule (mercy rule) using display scores
    if player_display_score - computer_display_score >= 300:
        game['game_over'] = True
        game['winner'] = 'player'
        game['message'] = f"GAME OVER! You WIN by mercy rule {player_display_score} to {computer_display_score}! (300+ point lead)"
        return True
    elif computer_display_score - player_display_score >= 300:
        game['game_over'] = True
        game['winner'] = 'computer'
        game['message'] = f"GAME OVER! Marta WINS by mercy rule {computer_display_score} to {player_display_score}! (300+ point lead)"
        return True
    
    # Check for regular target score (300 points) using display scores
    if player_display_score >= target_score or computer_display_score >= target_score:
        game['game_over'] = True
        
        # SIMPLE: Higher display score wins. Period.
        if player_display_score > computer_display_score:
            game['winner'] = 'player'
            game['message'] = f"GAME OVER! You WIN {player_display_score} to {computer_display_score}!"
        elif computer_display_score > player_display_score:
            game['winner'] = 'computer'
            game['message'] = f"GAME OVER! Marta WINS {computer_display_score} to {player_display_score}!"
        else:
            # Display scores are EXACTLY tied (e.g., both 300)
            # Only NOW do we look at tie-breakers
            
            # First tie-breaker: Higher base score
            if player_base_score > computer_base_score:
                game['winner'] = 'player'
                game['message'] = f"GAME OVER! You WIN {player_display_score} to {computer_display_score} (higher base score tie-breaker)!"
            elif computer_base_score > player_base_score:
                game['winner'] = 'computer'
                game['message'] = f"GAME OVER! Marta WINS {computer_display_score} to {player_display_score} (higher base score tie-breaker)!"
            else:
                # Second tie-breaker: Fewer bags (closer to 0 is better)
                # Convert to absolute values to compare distance from 0
                player_bag_distance = abs(player_bags)
                computer_bag_distance = abs(computer_bags)
                
                if player_bag_distance < computer_bag_distance:
                    # Player has fewer bags (closer to 0)
                    game['winner'] = 'player'
                    game['message'] = f"GAME OVER! You WIN {player_display_score} to {computer_display_score} (fewer bags: {player_bags} vs {computer_bags})!"
                elif computer_bag_distance < player_bag_distance:
                    # Computer has fewer bags (closer to 0)
                    game['winner'] = 'computer'
                    game['message'] = f"GAME OVER! Marta WINS {computer_display_score} to {player_display_score} (fewer bags: {computer_bags} vs {player_bags})!"
                else:
                    # Absolute tie - same everything
                    game['winner'] = 'tie'
                    game['message'] = f"GAME OVER! ABSOLUTE TIE at {player_display_score} points each!"
        
        return True
    
    return False

================================================================================

FILE: ./utilities/app_helpers.py
--------------------------------------------------------------------------------
"""
App helper functions for Two-Man Spades
Contains all non-routing logic moved from app.py
"""
from flask import session
import time
from .logging_utils import log_action, log_game_event, track_session_client, get_client_ip, IS_PRODUCTION
from .custom_rules import (
    check_special_cards_in_trick, reduce_bags_safely, assign_even_odd_at_game_start,
    calculate_discard_score_with_winner, calculate_hand_scores_with_bags, 
    get_player_names_with_parity, check_special_cards_in_discard,
    check_blind_bidding_eligibility
)
from .gameplay_logic import determine_trick_winner, init_game, init_new_hand, check_game_over
from .computer_logic import (
    computer_follow_strategy, computer_lead_strategy, computer_bidding_brain,
    computer_discard_strategy, autoplay_remaining_cards
)
from .logging_utils import initialize_game_logging_with_client, finalize_game_logging, flush_hand_events




# =============================================================================
# CONTENT FILTERING
# =============================================================================

def process_ip_geolocation(client_ip: str):
    """Process IP geolocation lookup - queue background lookup if needed"""
    if not client_ip or client_ip == 'unknown':
        return
    
    from .logging_utils import queue_db_operation
    
    # Always queue background geolocation lookup for production
    if IS_PRODUCTION:
        queue_db_operation(_check_and_perform_ip_geolocation, client_ip)
        print(f"[GEO] Queued geolocation check for IP: {client_ip}")
    
    return None


def _finalize_game_async(hand_id, game):
    try:
        from .postgres_utils import finalize_hand  # CHANGED from finalize_game
        success = finalize_hand(hand_id, game)
        if success:
            print(f"[DB] Hand {hand_id} finalized in database")
        else:
            print(f"[DB] Hand {hand_id} failed to finalize in database")
        return success
    except Exception as e:
        print(f"[DB] Database hand finalization failed: {e}")
        import traceback
        traceback.print_exc()  # This will show you the import error
        return False
    

def _check_and_perform_ip_geolocation(ip_address: str):
    """Check if IP exists in database, only call API if missing"""
    try:
        from .postgres_utils import get_db_connection
        
        # Check if we already have data for this IP
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT ip_address FROM twomanspades.ip_location_data WHERE ip_address = %s", (ip_address,))
        existing = cur.fetchone()
        cur.close()
        conn.close()
        
        if existing:
            print(f"[GEO] IP {ip_address} already in database, skipping API call")
            return True
        
        # No existing data, proceed with API call
        print(f"[GEO] IP {ip_address} not found, calling API...")
        return _perform_ip_geolocation_lookup(ip_address)
        
    except Exception as e:
        print(f"[GEO] Database check failed for {ip_address}: {e}")
        # Fall back to API call if database check fails
        return _perform_ip_geolocation_lookup(ip_address)

def _perform_ip_geolocation_lookup(ip_address: str):
    """
    Background worker function to perform actual geolocation API call
    Saves ONLY the data returned from the IP API - no calculated fields
    """
    import urllib.request
    import urllib.error
    import json
    import time
    
    try:
        print(f"[GEO] Starting geolocation lookup for {ip_address}")
        
        # Use ip-api.com
        url = f"http://ip-api.com/json/{ip_address}"
        
        request = urllib.request.Request(url)
        request.add_header('User-Agent', 'TwoManSpades-GeoLookup/1.0')
        
        with urllib.request.urlopen(request, timeout=10) as response:
            if response.getcode() == 200:
                data = json.loads(response.read().decode('utf-8'))
                
                if data.get('status') == 'success':
                    # Extract ALL the data from the API response
                    location_data = {
                        'country': data.get('country', 'Unknown'),
                        'region': data.get('regionName', 'Unknown'),  # Note: API returns 'regionName'
                        'city': data.get('city', 'Unknown'),
                        'lat': data.get('lat', 0),
                        'lon': data.get('lon', 0),
                        'timezone': data.get('timezone', 'Unknown'),
                        'zip': data.get('zip', 'Unknown'),
                        'isp': data.get('isp', 'Unknown'),
                        'org': data.get('org', data.get('isp', 'Unknown')),  # Fallback to ISP if org missing
                        'as': data.get('as', 'Unknown')  # Full AS string like "AS7922 Comcast Cable Communications, LLC"
                    }
                    
                    from .postgres_utils import save_ip_location_data
                    success = save_ip_location_data(ip_address, location_data)
                    
                    if success:
                        print(f"[GEO] Successfully saved location data for {ip_address}: {location_data['city']}, {location_data['country']}")
                    else:
                        print(f"[GEO] Failed to save location data for {ip_address}")
                    
                    return success
                else:
                    print(f"[GEO] API returned failure for {ip_address}: {data.get('message', 'Unknown error')}")
                    
                    # Save failed lookup record
                    from .postgres_utils import save_failed_ip_lookup
                    save_failed_ip_lookup(ip_address)
                    return False
            else:
                print(f"[GEO] HTTP error {response.getcode()} for {ip_address}")
                return False
                
    except Exception as e:
        print(f"[GEO] Geolocation lookup failed for {ip_address}: {e}")
        return False

def get_blocked_words():
    """Get blocked words from tinyurl"""
    import requests
    
    try:
        url = "https://tinyurl.com/35wba3d6"
        response = requests.get(url, timeout=5)
        if response.status_code == 200:
            return [word.strip() for word in response.text.split('\n') if word.strip()]
    except:
        pass
    
    # Fallback minimal list if tinyurl fails
    return ['placeholder1', 'placeholder2']

def check_content_filter(message):
    """Check if message contains disallowed content"""
    try:
        blocked_phrases = get_blocked_words()
        
        message_lower = message.lower()
        for phrase in blocked_phrases:
            if phrase.lower() in message_lower:
                print(f"[FILTER] BLOCKED message containing '{phrase}': '{message[:50]}{'...' if len(message) > 50 else ''}'")
                return False, "Hey, watch the language! Let's keep it PG-13 here - I've got a reputation to maintain!"
        
        return True, None
    except Exception as e:
        print(f"[FILTER] Error checking content filter: {e}")
        return True, None

# =============================================================================
# DEVELOPMENT SERVER UTILITIES
# =============================================================================

def start_development_server(app):
    """Start development server with port management and browser opening (macOS optimized)"""
    import subprocess
    import webbrowser
    import time
    import socket
    import os
    from threading import Thread
    
    def kill_process_on_port(port):
        try:
            result = subprocess.run(['lsof', '-ti:' + str(port)], capture_output=True, text=True)
            if result.stdout.strip():
                pids = result.stdout.strip().split('\n')
                for pid in pids:
                    if pid.strip():
                        subprocess.run(['kill', '-9', pid.strip()], capture_output=True)
                        print(f"Killed process {pid.strip()} on port {port}")
                time.sleep(1)
                return True
        except Exception as e:
            print(f"Could not kill processes on port {port}: {e}")
        return False
    
    def is_port_available(port):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        result = sock.connect_ex(('localhost', port))
        sock.close()
        return result != 0
    
    def find_available_port(start_port=5000, max_attempts=10):
        for port in range(start_port, start_port + max_attempts):
            if is_port_available(port):
                print(f"Port {port} is available")
                return port
            else:
                print(f"Port {port} is in use, attempting to kill process...")
                if kill_process_on_port(port):
                    time.sleep(0.5)
                    if is_port_available(port):
                        print(f"Successfully freed port {port}")
                        return port
                    else:
                        print(f"Port {port} still in use after kill attempt")
                else:
                    print(f"Could not kill process on port {port}")
        
        raise RuntimeError(f"Could not find an available port in range {start_port}-{start_port + max_attempts - 1}")
    
    def open_browser(port):
        time.sleep(1.5)
        url = f'http://localhost:{port}'
        
        # macOS Chrome path
        chrome_path = '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'
        
        opened = False
        if os.path.exists(chrome_path):
            try:
                subprocess.Popen([chrome_path, url])
                print(f"Opened Chrome at {url}")
                opened = True
            except:
                pass
        
        if not opened:
            webbrowser.open(url)
            print(f"Opened default browser at {url}")
    
    # Find and secure a port
    try:
        port = find_available_port(5000, 10)
    except RuntimeError as e:
        print(f"Error: {e}")
        print("Please manually kill processes or restart your computer")
        exit(1)
    
    # Start browser opening in a separate thread
    browser_thread = Thread(target=lambda: open_browser(port))
    browser_thread.daemon = True
    browser_thread.start()
    
    print(f"Starting Flask app on port {port}...")
    print(f"The browser should open automatically in a moment...")
    print(f"If not, navigate to http://localhost:{port}")
    
    # Run Flask app
    app.run(debug=True, port=port, use_reloader=False)

# =============================================================================
# SCORE DISPLAY FUNCTIONS
# =============================================================================

def get_display_score(base_score, bags):
    """Convert base score and bags to display score (bags in ones column)"""
    if bags >= 0:
        if base_score < 0:
            tens_and_higher = (base_score // 10) * 10
            return tens_and_higher - bags
        else:
            tens_and_higher = (base_score // 10) * 10
            return tens_and_higher + bags
    else:
        return base_score

def get_base_score_from_display(display_score, bags):
    """Convert display score back to base score (removing bags from ones column)"""
    return display_score - bags

# =============================================================================
# SESSION TRACKING
# =============================================================================

def track_request_session(session, request):
    """Track client session for this request"""
    if 'game' in session:
        return track_session_client(session, request)
    return None

# =============================================================================
# GAME INITIALIZATION
# =============================================================================

def initialize_new_game_session(request):
    """Initialize a new game session with logging"""
    player_parity, computer_parity, first_player = assign_even_odd_at_game_start()
    game = init_game(player_parity, computer_parity, first_player)
    game = initialize_game_logging_with_client(game, request)
    return game

def process_new_game_request(session, request):
    """Process new game request with logging cleanup"""
    client_info = track_request_session(session, request)
    
    if 'game' in session:
        finalize_game_logging(session['game'])
    
    game = initialize_new_game_session(request)
    
    # UNCOMMENT THIS LINE:
    if client_info and client_info.get('ip_address'):
        process_ip_geolocation(client_info['ip_address'])
    
    log_game_event(
        event_type='new_game_started',
        event_data={
            'player_parity': game.get('player_parity'),
            'computer_parity': game.get('computer_parity'),
            'first_leader': game.get('first_leader')
        },
        session={'game': game}
    )
    
    return game

# =============================================================================
# GAME STATE BUILDING
# =============================================================================

def build_safe_game_state(game, debug_mode=False):
    """Build safe game state for frontend"""
    player_name, computer_name = get_player_names_with_parity(
        game.get('player_parity', 'even'),
        game.get('computer_parity', 'odd')
    )
    
    show_discard_explanation = game.get('hand_over', False)
    discard_explanation = game.get('discard_bonus_explanation') if show_discard_explanation else None
    
    player_base_score = game.get('player_score', 0)
    computer_base_score = game.get('computer_score', 0)
    player_bags = game.get('player_bags', 0)
    computer_bags = game.get('computer_bags', 0)
    
    player_display_score = get_display_score(player_base_score, player_bags)
    computer_display_score = get_display_score(computer_base_score, computer_bags)
    
    safe_state = {
        'player_hand': game['player_hand'],
        'computer_hand_count': len(game['computer_hand']) if debug_mode else 0,
        'current_trick': game['current_trick'],
        'player_tricks': game['player_tricks'],
        'computer_tricks': game['computer_tricks'],
        'spades_broken': game['spades_broken'],
        'phase': game['phase'],
        'turn': game['turn'],
        'trick_leader': game.get('trick_leader'),
        'hand_over': game.get('hand_over', False),
        'game_over': game.get('game_over', False),
        'winner': game['winner'],
        'message': game['message'],
        'player_discarded': game.get('player_discarded'),
        'computer_discarded': game.get('computer_discarded'),
        'show_computer_hand': game.get('show_computer_hand', False) and debug_mode,
        'player_bid': game.get('player_bid'),
        'computer_bid': game.get('computer_bid'),
        'total_tricks': game.get('total_tricks', 10),
        'player_score': player_display_score,
        'computer_score': computer_display_score,
        'player_base_score': player_base_score,
        'computer_base_score': computer_base_score,
        'player_bags': player_bags,
        'computer_bags': computer_bags,
        'hand_number': game.get('hand_number', 1),
        'target_score': game.get('target_score', 300),
        'player_parity': game.get('player_parity', 'even'),
        'computer_parity': game.get('computer_parity', 'odd'),
        'player_name': player_name,
        'computer_name': computer_name,
        'discard_bonus_explanation': discard_explanation,
        'blind_bidding_available': game.get('blind_bidding_available', False),
        'blind_bid': game.get('blind_bid'),
        'computer_blind_bid': game.get('computer_blind_bid'),
        'debug_mode': debug_mode,
        'hand_results': game.get('hand_results')
    }
    
    if debug_mode and game.get('show_computer_hand', False):
        safe_state['computer_hand'] = game['computer_hand']
    
    return safe_state

# =============================================================================
# BIDDING LOGIC
# =============================================================================

def process_bidding_phase(game, session, bid, request):
    """Process player bidding with computer response and game state updates"""
    log_action(
        action_type='regular_bid',
        player='player',
        action_data={'bid_amount': bid, 'is_nil': bid == 0},
        session=session,
        request=request
    )
    
    game['player_bid'] = bid
    
    if game.get('computer_bid') is None:
        computer_bid, computer_is_blind = computer_bidding_brain(
            game['computer_hand'], 
            bid, 
            game
        )
        game['computer_bid'] = computer_bid
        
        if computer_is_blind:
            game['computer_blind_bid'] = computer_bid
            log_action(
                action_type='blind_bid',
                player='computer',
                action_data={'bid_amount': computer_bid, 'in_response_to_player': True},
                session=session
            )
        else:
            log_action(
                action_type='regular_bid',
                player='computer',
                action_data={'bid_amount': computer_bid, 'in_response_to_player': True},
                session=session
            )
            
        computer_blind_text = " (BLIND)" if computer_is_blind else ""
        player_blind_text = " (BLIND)" if game.get('blind_bid') == bid else ""
        
        message_base = f'You bid {bid}{player_blind_text}, Marta bid {computer_bid}{computer_blind_text}.'
    else:
        computer_blind_text = " (BLIND)" if game.get('computer_blind_bid') else ""
        player_blind_text = " (BLIND)" if game.get('blind_bid') == bid else ""
        
        message_base = f'You bid {bid}{player_blind_text}, Marta bid {game["computer_bid"]}{computer_blind_text}.'
    
    game['phase'] = 'playing'
    first_leader = game.get('first_leader', 'player')
    game['turn'] = first_leader
    game['trick_leader'] = first_leader
    
    log_game_event(
        event_type='bidding_complete',
        event_data={
            'player_bid': game['player_bid'],
            'computer_bid': game['computer_bid'],
            'first_leader': first_leader,
            'player_blind': game.get('blind_bid') is not None,
            'computer_blind': game.get('computer_blind_bid') is not None
        },
        session=session
    )
    
    if first_leader == 'player':
        game['message'] = f'{message_base} Your turn to lead the first trick.'
    else:
        game['message'] = f'{message_base} Marta leads the first trick.'
        computer_lead_with_logging(game, session)
        game['turn'] = 'player'
        game['message'] = f'{message_base} Marta led. Your turn to follow.'

def process_blind_bid_phase(game, session, bid, request):
    """Process blind bidding phase"""
    log_action(
        action_type='blind_bid',
        player='player',
        action_data={'bid_amount': bid},
        session=session,
        request=request
    )
    
    game['blind_bid'] = bid
    game['player_bid'] = bid
    
    computer_bid, computer_is_blind = computer_bidding_brain(
        game['computer_hand'], 
        bid, 
        game
    )
    game['computer_bid'] = computer_bid
    
    if computer_is_blind:
        game['computer_blind_bid'] = computer_bid
        log_action(
            action_type='blind_bid',
            player='computer',
            action_data={'bid_amount': computer_bid, 'in_response_to_player': True},
            session=session
        )
    else:
        log_action(
            action_type='regular_bid',
            player='computer',
            action_data={'bid_amount': computer_bid, 'in_response_to_blind': True},
            session=session
        )
    
    game['phase'] = 'discard'
    computer_blind_text = " (BLIND)" if computer_is_blind else ""
    game['message'] = f'You bid BLIND {bid}! Marta bid {computer_bid}{computer_blind_text}. Select a card to discard.'

# =============================================================================
# DISCARD LOGIC
# =============================================================================

def process_discard_phase(game, session, card_index, request):
    """Process discard phase with computer response and scoring"""
    player_card = game['player_hand'].pop(card_index)
    game['player_discarded'] = player_card
    
    log_action(
        action_type='discard',
        player='player',
        action_data={
            'card_discarded': f"{player_card['rank']}{player_card['suit']}",
            'card_index': card_index
        },
        session=session,
        additional_context={'hand_size_after': len(game['player_hand'])},
        request=request
    )
    
    idx = computer_discard_strategy(game['computer_hand'], game)
    computer_card = game['computer_hand'].pop(idx)
    game['computer_discarded'] = computer_card
    
    log_action(
        action_type='discard',
        player='computer',
        action_data={
            'card_discarded': f"{computer_card['rank']}{computer_card['suit']}",
            'card_index': idx
        },
        session=session,
        additional_context={'hand_size_after': len(game['computer_hand'])}
    )
    
    discard_result = calculate_discard_score_with_winner(
        game['player_discarded'],
        game['computer_discarded'],
        game.get('player_parity', 'even'),
        game.get('computer_parity', 'odd'),
        game
    )
    
    game['pending_discard_result'] = discard_result
    
    special_discard_result = check_special_cards_in_discard(
        game['player_discarded'],
        game['computer_discarded'],
        discard_result['winner']
    )
    
    game['pending_special_discard_result'] = special_discard_result
    
    log_game_event(
        event_type='discard_scoring',
        event_data={
            'player_card': f"{player_card['rank']}{player_card['suit']}",
            'computer_card': f"{computer_card['rank']}{computer_card['suit']}",
            'winner': discard_result['winner'],
            'bonus_points': discard_result['player_bonus'] + discard_result['computer_bonus'],
            'is_double': discard_result['is_double'],
            'explanation': discard_result['explanation']
        },
        session=session
    )
    
    # Handle post-discard phase transitions
    if game.get('player_bid') is not None:
        # Bids already set, go to playing
        transition_to_playing_phase(game, session)
    else:
        # CRITICAL FIX: Check if blind decision was already made
        if not game.get('blind_decision_made', False):
            # First time - check blind eligibility or go to bidding
            transition_to_bidding_phase(game, session)
        else:
            # Already made blind decision (chose "Bid Normal"), proceed directly to bidding
            game['phase'] = 'bidding'
            first_leader = game.get('first_leader', 'player')
            
            if first_leader == 'computer':
                # Computer bids first
                computer_bid, computer_is_blind = computer_bidding_brain(
                    game['computer_hand'], 
                    None,
                    game
                )
                game['computer_bid'] = computer_bid
                
                if computer_is_blind:
                    game['computer_blind_bid'] = computer_bid
                    computer_blind_text = " (BLIND)"
                    log_action(
                        action_type='blind_bid',
                        player='computer',
                        action_data={'bid_amount': computer_bid, 'bid_first': True},
                        session=session
                    )
                else:
                    computer_blind_text = ""
                    log_action(
                        action_type='regular_bid',
                        player='computer',
                        action_data={'bid_amount': computer_bid, 'bid_first': True},
                        session=session
                    )
                
                game['message'] = f'Cards discarded. Marta bid {computer_bid}{computer_blind_text}. Your turn to bid.'
            else:
                # Player bids first
                game['message'] = f'Cards discarded. Now make your bid: How many tricks will you take? (0-10)'

def transition_to_playing_phase(game, session):
    """Transition from discard to playing phase"""
    game['phase'] = 'playing'
    first_leader = game.get('first_leader', 'player')
    game['turn'] = first_leader
    game['trick_leader'] = first_leader
    
    player_blind_text = " (BLIND)" if game.get('blind_bid') else ""
    computer_blind_text = " (BLIND)" if game.get('computer_blind_bid') else ""
    
    if first_leader == 'player':
        game['message'] = f'Cards discarded. You bid {game["player_bid"]}{player_blind_text}, Marta bid {game["computer_bid"]}{computer_blind_text}. Your turn to lead the first trick.'
    else:
        game['message'] = f'Cards discarded. You bid {game["player_bid"]}{player_blind_text}, Marta bid {game["computer_bid"]}{computer_blind_text}. Marta leads the first trick.'
        computer_lead_with_logging(game, session)
        game['turn'] = 'player'
        game['message'] = f'Cards discarded. You bid {game["player_bid"]}{player_blind_text}, Marta bid {game["computer_bid"]}{computer_blind_text}. Marta led. Your turn to follow.'

def transition_to_bidding_phase(game, session):
    """Transition from discard to bidding phase (or blind decision) - Uses display scores for eligibility"""
    
    # CRITICAL FIX: Only check blind eligibility ONCE per hand
    # If we've already been through blind decision, skip straight to bidding
    if game.get('blind_decision_made', False):
        print(f"DEBUG: Blind decision already made this hand, proceeding to normal bidding")
        game['phase'] = 'bidding'
        first_leader = game.get('first_leader', 'player')
        
        if first_leader == 'computer':
            # Computer bids first
            computer_bid, computer_is_blind = computer_bidding_brain(
                game['computer_hand'], 
                None,
                game
            )
            game['computer_bid'] = computer_bid
            
            if computer_is_blind:
                game['computer_blind_bid'] = computer_bid
                computer_blind_text = " (BLIND)"
                log_action(
                    action_type='blind_bid',
                    player='computer',
                    action_data={'bid_amount': computer_bid, 'bid_first': True},
                    session=session
                )
            else:
                computer_blind_text = ""
                log_action(
                    action_type='regular_bid',
                    player='computer',
                    action_data={'bid_amount': computer_bid, 'bid_first': True},
                    session=session
                )
            
            game['message'] = f'Cards discarded. Marta bid {computer_bid}{computer_blind_text}. Your turn to bid.'
        else:
            # Player bids first
            game['message'] = f'Cards discarded. Now make your bid: How many tricks will you take? (0-10)'
        return
    
    # First time checking blind eligibility this hand - use DISPLAY SCORES
    player_base_score = game.get('player_score', 0)
    computer_base_score = game.get('computer_score', 0)
    player_bags = game.get('player_bags', 0)
    computer_bags = game.get('computer_bags', 0)
    
    # Calculate display scores (what players actually see)
    player_display_score = get_display_score(player_base_score, player_bags)
    computer_display_score = get_display_score(computer_base_score, computer_bags)
    
    # Check eligibility based on display scores
    blind_eligibility = check_blind_bidding_eligibility(player_display_score, computer_display_score)
    
    print(f"DEBUG BLIND CHECK: Player Display={player_display_score} (base={player_base_score}, bags={player_bags}), Computer Display={computer_display_score} (base={computer_base_score}, bags={computer_bags})")
    print(f"DEBUG BLIND CHECK: Player Eligible={blind_eligibility['player_eligible']}, Computer Eligible={blind_eligibility['computer_eligible']}")
    print(f"DEBUG BLIND CHECK: Player Deficit={blind_eligibility['player_deficit']}, Computer Deficit={blind_eligibility['computer_deficit']}")
    
    if blind_eligibility['player_eligible']:
        # Player is eligible for blind bidding - ask them to choose
        game['phase'] = 'blind_decision'
        game['blind_decision_made'] = True  # Mark that we've presented the choice
        deficit = computer_display_score - player_display_score
        game['message'] = f'Cards discarded! You are down by {deficit} points. Choose: Go BLIND for double points/penalties, or bid normally?'
        
        print(f"DEBUG: Entering blind_decision phase with deficit of {deficit}")
    else:
        # Player not eligible for blind bidding - go straight to normal bidding
        game['blind_decision_made'] = True  # Mark that we've checked (even though not eligible)
        game['phase'] = 'bidding'
        first_leader = game.get('first_leader', 'player')
        
        if first_leader == 'computer':
            # Computer bids first
            computer_bid, computer_is_blind = computer_bidding_brain(
                game['computer_hand'], 
                None,
                game
            )
            game['computer_bid'] = computer_bid
            
            if computer_is_blind:
                game['computer_blind_bid'] = computer_bid
                computer_blind_text = " (BLIND)"
                log_action(
                    action_type='blind_bid',
                    player='computer',
                    action_data={'bid_amount': computer_bid, 'bid_first': True},
                    session=session
                )
            else:
                computer_blind_text = ""
                log_action(
                    action_type='regular_bid',
                    player='computer',
                    action_data={'bid_amount': computer_bid, 'bid_first': True},
                    session=session
                )
            
            game['message'] = f'Cards discarded. Marta bid {computer_bid}{computer_blind_text}. Your turn to bid.'
        else:
            # Player bids first
            game['message'] = f'Cards discarded. Now make your bid: How many tricks will you take? (0-10)'
        
        print(f"DEBUG: Player not eligible for blind bidding (deficit only {blind_eligibility['player_deficit']}), proceeding to normal bidding")

# =============================================================================
# GAME LOGIC HELPERS
# =============================================================================

def resolve_trick_with_delay(game, session_obj=None):
    """Resolve trick and set it up to be displayed for 3 seconds with logging"""
    if len(game['current_trick']) != 2:
        return
    
    winner = determine_trick_winner(game['current_trick'])
    
    # Save trick to history
    trick_number = len(game.get('trick_history', [])) + 1
    player_card = next((play['card'] for play in game['current_trick'] if play['player'] == 'player'), None)
    computer_card = next((play['card'] for play in game['current_trick'] if play['player'] == 'computer'), None)
    
    game.setdefault('trick_history', []).append({
        'number': trick_number,
        'player_card': player_card,
        'computer_card': computer_card,
        'winner': winner
    })
    
    # Console logging
    p_text = f"{player_card['rank']}{player_card['suit']}" if player_card else "?"
    c_text = f"{computer_card['rank']}{computer_card['suit']}" if computer_card else "?"
    winner_name = "You" if winner == 'player' else "Marta"
    print(f"TRICK {trick_number}: {p_text} vs {c_text} -> {winner_name} wins")
    
    # JSON logging
    if session_obj:
        log_game_event(
            event_type='trick_completed',
            event_data={
                'trick_number': trick_number,
                'player_card': p_text,
                'computer_card': c_text,
                'winner': winner,
                'winner_name': winner_name
            },
            session=session_obj
        )
    
    # Apply special card effects immediately
    special_result = check_special_cards_in_trick(game['current_trick'], winner)
    
    if special_result['bag_reduction'] > 0:
        if winner == 'player':
            current_bags = game.get('player_bags', 0)
            game['player_bags'] = reduce_bags_safely(current_bags, special_result['bag_reduction'])
            game['player_trick_special_cards'] = game.get('player_trick_special_cards', 0) + special_result['bag_reduction']
        else:
            current_bags = game.get('computer_bags', 0)
            game['computer_bags'] = reduce_bags_safely(current_bags, special_result['bag_reduction'])
            game['computer_trick_special_cards'] = game.get('computer_trick_special_cards', 0) + special_result['bag_reduction']
        
        game['special_card_message'] = special_result['explanation']
        
        if session_obj:
            log_game_event(
                event_type='special_card_effect',
                event_data={
                    'trick_number': trick_number,
                    'bag_reduction': special_result['bag_reduction'],
                    'beneficiary': winner_name,
                    'explanation': special_result['explanation']
                },
                session=session_obj
            )
    
    # Award trick and set message
    if winner == 'player':
        game['player_tricks'] += 1
        base_message = 'You won the trick!'
    else:
        game['computer_tricks'] += 1
        base_message = 'Marta won the trick!'
    
    if special_result['explanation']:
        game['message'] = f"{base_message} {special_result['explanation']}."
    else:
        game['message'] = f"{base_message}."
    
    game['trick_completed'] = True
    game['trick_winner'] = winner

def computer_follow_with_logging(game, session_obj=None):
    """Computer plays a card when following with logging"""
    hand = game['computer_hand']
    trick = game['current_trick']
    
    if not trick or not hand:
        return
    
    # Use enhanced strategy or fallback
    chosen_idx = computer_follow_strategy(hand, trick, game)
    
    if chosen_idx is None:
        # Fallback logic
        lead_card = trick[0]['card']
        lead_suit = lead_card['suit']
        lead_value = lead_card['value']
        
        same_suit = [(i, c) for i, c in enumerate(hand) if c['suit'] == lead_suit]
        spades = [(i, c) for i, c in enumerate(hand) if c['suit'] == '‚ô†']
        
        if same_suit:
            winners = [(i, c) for i, c in same_suit if c['value'] > lead_value]
            if winners:
                chosen_idx = min(winners, key=lambda x: x[1]['value'])[0]
            else:
                chosen_idx = min(same_suit, key=lambda x: x[1]['value'])[0]
        elif lead_suit != '‚ô†' and spades:
            chosen_idx = min(spades, key=lambda x: x[1]['value'])[0]
        else:
            all_cards = [(i, c) for i, c in enumerate(hand)]
            chosen_idx = min(all_cards, key=lambda x: x[1]['value'])[0]
    
    # Play the card
    card = hand.pop(chosen_idx)
    game['current_trick'].append({'player': 'computer', 'card': card})
    
    # Logging
    if session_obj:
        lead_card = game['current_trick'][0]['card'] if len(game['current_trick']) >= 1 else None
        log_action(
            action_type='card_play',
            player='computer',
            action_data={
                'card_played': f"{card['rank']}{card['suit']}",
                'trick_position': 2,
                'following_suit': card['suit'] == lead_card['suit'] if lead_card else False
            },
            session=session_obj,
            additional_context={
                'responding_to': f"{lead_card['rank']}{lead_card['suit']}" if lead_card else None,
                'hand_size_after': len(hand)
            }
        )
    
    if card['suit'] == '‚ô†':
        game['spades_broken'] = True
        if session_obj:
            log_game_event('spades_broken', {'broken_by': 'computer', 'card': f"{card['rank']}{card['suit']}"}, session_obj)

def computer_lead_with_logging(game, session_obj=None):
    """Computer plays a card when leading with logging"""
    hand = game['computer_hand']
    
    if not hand:
        return
    
    # Use enhanced strategy or fallback
    chosen_idx = computer_lead_strategy(hand, game['spades_broken'], game)
    
    if chosen_idx is None:
        # Fallback logic
        valid = []
        for i, card in enumerate(hand):
            if card['suit'] != '‚ô†' or game['spades_broken'] or all(c['suit'] == '‚ô†' for c in hand):
                valid.append((i, card))
        
        if valid:
            chosen = min(valid, key=lambda x: (x[1]['suit'] == '‚ô†', x[1]['value']))
            chosen_idx = chosen[0]
        else:
            return
    
    # Play the card
    card = hand.pop(chosen_idx)
    game['current_trick'] = [{'player': 'computer', 'card': card}]
    game['trick_leader'] = 'computer'
    
    # Logging
    if session_obj:
        log_action(
            action_type='card_play',
            player='computer',
            action_data={
                'card_played': f"{card['rank']}{card['suit']}",
                'trick_position': 1,
                'leading': True
            },
            session=session_obj,
            additional_context={
                'hand_size_after': len(hand)
            }
        )
    
    if card['suit'] == '‚ô†':
        game['spades_broken'] = True
        if session_obj:
            log_game_event('spades_broken', {'broken_by': 'computer', 'card': f"{card['rank']}{card['suit']}"}, session_obj)

# =============================================================================
# HAND COMPLETION LOGIC
# =============================================================================
def process_hand_completion(game, session):
    """Process hand completion with all scoring logic"""
    log_game_event(
        event_type='hand_completed',
        event_data={
            'hand_number': game['hand_number'],
            'player_tricks': game['player_tricks'],
            'computer_tricks': game['computer_tricks'],
            'player_bid': game.get('player_bid', 0),
            'computer_bid': game.get('computer_bid', 0)
        },
        session=session
    )
    
    # Apply stored discard results at the end of the hand
    if 'pending_discard_result' in game:
        discard_result = game['pending_discard_result']
        game['player_score'] += discard_result['player_bonus']
        game['computer_score'] += discard_result['computer_bonus']
        
        # Apply special card effects from discards
        if 'pending_special_discard_result' in game:
            special_discard_result = game['pending_special_discard_result']
            
            if special_discard_result['player_bag_reduction'] > 0:
                game['player_bags'] = reduce_bags_safely(
                    game.get('player_bags', 0), 
                    special_discard_result['player_bag_reduction']
                )
            
            if special_discard_result['computer_bag_reduction'] > 0:
                game['computer_bags'] = reduce_bags_safely(
                    game.get('computer_bags', 0), 
                    special_discard_result['computer_bag_reduction']
                )
            
            # Store explanation for the final message
            game['discard_bonus_explanation'] = discard_result['explanation']
            if special_discard_result['explanation']:
                game['discard_bonus_explanation'] += " | " + special_discard_result['explanation']
        else:
            game['discard_bonus_explanation'] = discard_result['explanation']
        
        # Clean up pending results
        del game['pending_discard_result']
        if 'pending_special_discard_result' in game:
            del game['pending_special_discard_result']
    
    # Calculate scoring with bags system
    scoring_result = calculate_hand_scores_with_bags(game)
    
    # Check if blind nil ended the game (but don't return early - show full results)
    blind_nil_ending = game.get('game_over', False)
    
    # Create structured hand results for cleaner display
    trick_history = game.get('trick_history', [])
    
    # Calculate display scores for hand results
    player_display_score = get_display_score(game['player_score'], game.get('player_bags', 0))
    computer_display_score = get_display_score(game['computer_score'], game.get('computer_bags', 0))
    
    hand_results = {
        'hand_number': game['hand_number'],
        'parity': {
            'player': game.get('player_parity', 'even').title(),
            'computer': game.get('computer_parity', 'odd').title()
        },
        'discard_info': game.get('discard_bonus_explanation', ''),
        'scoring': scoring_result['explanation'],
        'trick_history': [
            {
                'number': trick['number'],
                'player_card': f"{trick['player_card']['rank']}{trick['player_card']['suit']}" if trick['player_card'] else "?",
                'computer_card': f"{trick['computer_card']['rank']}{trick['computer_card']['suit']}" if trick['computer_card'] else "?",
                'winner': "You" if trick['winner'] == 'player' else "Marta"
            }
            for trick in trick_history
        ],
        'totals': {
            'player_score': player_display_score,
            'computer_score': computer_display_score
        }
    }
    
    # Store structured results for frontend
    game['hand_results'] = hand_results
    
    # Flush batched events to database
    from .logging_utils import flush_hand_events
    flush_hand_events(session)
    
    # Log final scoring
    log_game_event(
        event_type='hand_scoring',
        event_data={
            'scoring_explanation': scoring_result['explanation'],
            'final_scores': {
                'player_score': player_display_score,
                'computer_score': computer_display_score
            },
            'hand_results': hand_results
        },
        session=session
    )
    
    # CRITICAL FIX: Actually finalize the hand in the database
    from .logging_utils import finalize_game_logging
    finalize_game_logging(game)
    
    # Set appropriate message based on game state
    if blind_nil_ending:
        # Keep the blind nil message - it's already set in calculate_hand_scores_with_bags
        # Results will still be shown alongside the game over screen
        log_game_event(
            event_type='game_completed',
            event_data={
                'winner': game['winner'],
                'final_message': game['message'],
                'hands_played': game['hand_number'],
                'game_end_reason': 'blind_nil'
            },
            session=session
        )
    else:
        # Normal hand completion message
        game['message'] = f"Hand #{game['hand_number']} complete! Click 'Next Hand' to continue"
        
        # Check if game is over using base scores for comparison
        game_over = check_game_over(game)
        if game_over:
            log_game_event(
                event_type='game_completed',
                event_data={
                    'winner': game['winner'],
                    'final_message': game['message'],
                    'hands_played': game['hand_number']
                },
                session=session
            )
def process_auto_resolution(game, session):
    """Process auto-resolution of remaining cards"""
    auto_resolved, explanation = autoplay_remaining_cards(game, session)
    
    if auto_resolved:
        # Continue with normal hand completion logic
        if 'pending_discard_result' in game:
            discard_result = game['pending_discard_result']
            game['player_score'] += discard_result['player_bonus']
            game['computer_score'] += discard_result['computer_bonus']
            
            if 'pending_special_discard_result' in game:
                special_discard_result = game['pending_special_discard_result']
                
                if special_discard_result['player_bag_reduction'] > 0:
                    game['player_bags'] = reduce_bags_safely(
                        game.get('player_bags', 0), 
                        special_discard_result['player_bag_reduction']
                    )
                
                if special_discard_result['computer_bag_reduction'] > 0:
                    game['computer_bags'] = reduce_bags_safely(
                        game.get('computer_bags', 0), 
                        special_discard_result['computer_bag_reduction']
                    )
                
                game['discard_bonus_explanation'] = discard_result['explanation']
                if special_discard_result['explanation']:
                    game['discard_bonus_explanation'] += " | " + special_discard_result['explanation']
            else:
                game['discard_bonus_explanation'] = discard_result['explanation']
            
            del game['pending_discard_result']
            if 'pending_special_discard_result' in game:
                del game['pending_special_discard_result']
        
        # Calculate scoring
        scoring_result = calculate_hand_scores_with_bags(game)
        
        # Check if blind nil ended the game (auto-resolve case)
        blind_nil_ending = game.get('game_over', False)
        
        # Create hand results
        trick_history = game.get('trick_history', [])
        player_display_score = get_display_score(game['player_score'], game.get('player_bags', 0))
        computer_display_score = get_display_score(game['computer_score'], game.get('computer_bags', 0))
        
        hand_results = {
            'hand_number': game['hand_number'],
            'parity': {
                'player': game.get('player_parity', 'even').title(),
                'computer': game.get('computer_parity', 'odd').title()
            },
            'discard_info': game.get('discard_bonus_explanation', ''),
            'scoring': scoring_result['explanation'],
            'auto_resolution': explanation,
            'trick_history': [
                {
                    'number': trick['number'],
                    'player_card': f"{trick['player_card']['rank']}{trick['player_card']['suit']}" if trick['player_card'] else "?",
                    'computer_card': f"{trick['computer_card']['rank']}{trick['computer_card']['suit']}" if trick['computer_card'] else "?",
                    'winner': "You" if trick['winner'] == 'player' else "Marta"
                }
                for trick in trick_history
            ],
            'totals': {
                'player_score': player_display_score,
                'computer_score': computer_display_score
            }
        }
        
        game['hand_results'] = hand_results
        
        # Flush batched events to database
        from .logging_utils import flush_hand_events
        flush_hand_events(session)
        
        if blind_nil_ending:
            # Keep blind nil message and log completion
            log_game_event(
                event_type='game_completed',
                event_data={
                    'winner': game['winner'],
                    'final_message': game['message'],
                    'hands_played': game['hand_number'],
                    'game_end_reason': 'blind_nil_auto_resolve'
                },
                session=session
            )
        else:
            game['message'] = f"{explanation}. Hand #{game['hand_number']} complete! Click 'Next Hand' to continue"
            
            # Check if game is over
            game_over = check_game_over(game)
            if game_over:
                log_game_event(
                    event_type='game_completed',
                    event_data={
                        'winner': game['winner'],
                        'final_message': game['message'],
                        'hands_played': game['hand_number']
                    },
                    session=session
                )
        
        return True
    
    return False


================================================================================

FILE: ./utilities/custom_rules.py
--------------------------------------------------------------------------------
import random

def get_discard_value(card):
    """
    Get the numerical value of a card for discard scoring.
    J=11, Q=12, K=13, A=1, numbers are face value
    """
    rank = card['rank']
    if rank == 'A':
        return 1
    elif rank == 'J':
        return 11
    elif rank == 'Q':
        return 12
    elif rank == 'K':
        return 13
    else:
        return int(rank)

def assign_even_odd_at_game_start():
    """
    Randomly assign even/odd to players at the start of a new game.
    Also determines who leads the first trick - if player is odd, they lead first.
    Returns tuple: (player_parity, computer_parity, first_leader)
    """
    coin_flip = random.choice(['even', 'odd'])
    if coin_flip == 'even':
        player_parity = 'even'
        computer_parity = 'odd'
        first_leader = 'computer'  # Computer (odd) leads first trick
    else:
        player_parity = 'odd'
        computer_parity = 'even'
        first_leader = 'player'   # Player (odd) leads first trick
    
    return (player_parity, computer_parity, first_leader)

def is_special_card(card):
    """
    Check if a card is one of the special bag-reducing cards.
    Returns tuple: (is_special, bags_to_remove)
    """
    if card['rank'] == '7' and card['suit'] == '‚ô¶':
        return True, 2  # 7 of diamonds removes 2 bags
    elif card['rank'] == '10' and card['suit'] == '‚ô£':
        return True, 1  # 10 of clubs removes 1 bag
    else:
        return False, 0

def check_blind_bidding_eligibility(player_score, computer_score, target_score=300):
    """
    Check if a player is eligible for blind bidding (down by 100+ points).
    
    IMPORTANT: This function should receive DISPLAY SCORES, not base scores.
    Display scores include bags in the calculation.
    
    Returns:
        dict: {
            'player_eligible': bool,
            'computer_eligible': bool,
            'player_deficit': int,
            'computer_deficit': int
        }
    """
    player_deficit = computer_score - player_score
    computer_deficit = player_score - computer_score
    
    return {
        'player_eligible': player_deficit >= 100,
        'computer_eligible': computer_deficit >= 100,
        'player_deficit': max(0, player_deficit),
        'computer_deficit': max(0, computer_deficit)
    }

def apply_blind_scoring(base_points, blind_bid, actual_tricks):
    """
    Apply blind bidding scoring rules.
    
    Args:
        base_points: Normal points that would be awarded
        blind_bid: The blind bid amount (5-10)
        actual_tricks: Actual tricks taken
        
    Returns:
        int: Modified points (doubled if successful, doubled penalty if failed)
    """
    if actual_tricks >= blind_bid:
        # Successful blind bid: double the points
        return base_points * 2
    else:
        # Failed blind bid: double the penalty
        return base_points * 2  # base_points will already be negative for failed bids

def check_special_cards_in_discard(player_discard, computer_discard, discard_winner):
    """
    Check for special cards in the discard pile and apply bag reduction to the winner.
    """
    total_reduction = 0
    special_cards_found = []
    
    # Check both discarded cards for special cards
    for card, discarder in [(player_discard, 'You'), (computer_discard, 'Marta')]:
        if card:
            is_special, reduction = is_special_card(card)
            if is_special:
                total_reduction += reduction
                card_name = f"{card['rank']}{card['suit']}"
                special_cards_found.append(f"{card_name} (-{reduction} bags)")
    
    # Apply all reductions to the winner of the discard pile
    player_reduction = 0
    computer_reduction = 0
    
    if total_reduction > 0:
        if discard_winner == 'player':
            player_reduction = total_reduction
        else:
            computer_reduction = total_reduction
    
    # Create explanation
    explanation = ""
    if special_cards_found:
        winner_name = "You" if discard_winner == 'player' else "Marta"
        cards_text = ", ".join(special_cards_found)
        explanation = f"{winner_name} won discard pile with special cards: {cards_text}"
    
    return {
        'player_bag_reduction': player_reduction,
        'computer_bag_reduction': computer_reduction,
        'explanation': explanation
    }

def check_special_cards_in_trick(trick, winner):
    """
    Check for special cards in a completed trick and apply bag reduction to winner.
    """
    total_reduction = 0
    special_cards_found = []
    
    for play in trick:
        card = play['card']
        is_special, reduction = is_special_card(card)
        if is_special:
            total_reduction += reduction
            card_name = f"{card['rank']}{card['suit']}"
            special_cards_found.append(f"{card_name} (-{reduction} bags)")
    
    explanation = ""
    if special_cards_found:
        winner_name = "You" if winner == 'player' else "Marta"
        cards_text = ", ".join(special_cards_found)
        explanation = f"{winner_name} won trick with special cards: {cards_text}"
    
    return {
        'bag_reduction': total_reduction,
        'explanation': explanation
    }

def calculate_discard_score_with_winner(player_discard, computer_discard, player_parity, computer_parity, game_state=None):
    """
    Calculate the bonus points from discarded cards and determine winner.
    
    DENIAL RULE: If discard points would end the game, the losing player who wins
    the discard pile automatically SUBTRACTS those points from opponent instead.
    This keeps the game alive for another hand!
    """
    if not player_discard or not computer_discard:
        return {
            'player_bonus': 0,
            'computer_bonus': 0, 
            'total': 0,
            'is_double': False,
            'winner': None,
            'explanation': 'No discards to score',
            'denial_option_used': False
        }
    
    # Calculate total value
    player_value = get_discard_value(player_discard)
    computer_value = get_discard_value(computer_discard)
    total = player_value + computer_value
    
    # Check for doubles (same suit OR same rank)
    is_double = (player_discard['suit'] == computer_discard['suit'] or 
                 player_discard['rank'] == computer_discard['rank'])
    
    # Determine base points (10 for normal, 20 for doubles)
    base_points = 20 if is_double else 10
    
    # Determine who wins the discard pile based on parity
    is_total_even = (total % 2 == 0)
    winner = None
    
    if is_total_even and player_parity == 'even':
        winner = 'player'
    elif not is_total_even and player_parity == 'odd':
        winner = 'player'
    elif is_total_even and computer_parity == 'even':
        winner = 'computer'
    elif not is_total_even and computer_parity == 'odd':
        winner = 'computer'
    
    # Initialize default bonuses
    player_bonus = 0
    computer_bonus = 0
    denial_option_used = False
    
    # Check if we should apply the denial rule
    if game_state and winner:
        # Get current scores (before any discard bonus)
        player_score = game_state.get('player_score', 0)
        computer_score = game_state.get('computer_score', 0)
        player_bags = game_state.get('player_bags', 0)
        computer_bags = game_state.get('computer_bags', 0)
        target_score = game_state.get('target_score', 300)
        
        # Calculate display scores (what players see)
        def calc_display_score(base_score, bags):
            if bags >= 0:
                if base_score < 0:
                    tens_and_higher = (base_score // 10) * 10
                    return tens_and_higher - bags
                else:
                    tens_and_higher = (base_score // 10) * 10
                    return tens_and_higher + bags
            else:
                return base_score
        
        player_display = calc_display_score(player_score, player_bags)
        computer_display = calc_display_score(computer_score, computer_bags)
        
        # Determine if denial should be used (automatic for both players)
        if winner == 'player':
            # Player wins the discard pile
            new_player_display = calc_display_score(player_score + base_points, player_bags)
            
            # Check if either player would reach target score
            if new_player_display >= target_score or computer_display >= target_score:
                if player_display < computer_display:
                    # Player is losing - USE DENIAL to keep game alive!
                    computer_bonus = -base_points  # Subtract from Marta instead
                    denial_option_used = True
                else:
                    # Player is already winning - take the points normally
                    player_bonus = base_points
            else:
                # Game continues either way - normal points
                player_bonus = base_points
                
        else:  # winner == 'computer'
            # Computer wins the discard pile
            new_computer_display = calc_display_score(computer_score + base_points, computer_bags)
            
            # Check if either player would reach target score
            if new_computer_display >= target_score or player_display >= target_score:
                if computer_display < player_display:
                    # Marta is losing - USE DENIAL to keep game alive!
                    player_bonus = -base_points  # Subtract from player instead
                    denial_option_used = True
                else:
                    # Marta is already winning - take the points normally
                    computer_bonus = base_points
            else:
                # Game continues either way - normal points
                computer_bonus = base_points
    else:
        # No game state provided - use normal rules
        if winner == 'player':
            player_bonus = base_points
        elif winner == 'computer':
            computer_bonus = base_points
    
    # Create explanation text
    double_text = ""
    if is_double:
        if player_discard['suit'] == computer_discard['suit']:
            double_text = f" (DOUBLE: Both {player_discard['suit']} suit!)"
        else:
            double_text = f" (DOUBLE: Both {player_discard['rank']}s!)"
    
    parity_text = "even" if is_total_even else "odd"
    
    explanation = f"Discards: {player_discard['rank']}{player_discard['suit']} ({player_value}) + {computer_discard['rank']}{computer_discard['suit']} ({computer_value}) = {total} ({parity_text}){double_text}"
    
    # Add outcome to explanation
    if denial_option_used:
        if winner == 'player':
            explanation += f" ‚Üí You use DENIAL! Marta loses {base_points} pts (keeps game alive!)"
        else:
            explanation += f" ‚Üí Marta uses DENIAL! You lose {base_points} pts (keeps game alive!)"
    elif player_bonus > 0:
        explanation += f" ‚Üí You get {player_bonus} pts!"
    elif computer_bonus > 0:
        explanation += f" ‚Üí Marta gets {computer_bonus} pts!"
    else:
        explanation += " ‚Üí No bonus points this hand."
    
    return {
        'player_bonus': player_bonus,
        'computer_bonus': computer_bonus,
        'total': total,
        'is_double': is_double,
        'winner': winner,
        'explanation': explanation,
        'denial_option_used': denial_option_used
    }

def apply_bags_penalty(score, bags):
    """Apply bags penalty system."""
    penalty_applied = False
    bonus_applied = False
    
    while bags >= 7:
        score -= 100
        bags -= 7
        penalty_applied = True
    
    while bags <= -5:
        score += 100
        bags += 5
        bonus_applied = True
    
    return score, bags, penalty_applied, bonus_applied

def reduce_bags_safely(current_bags, reduction):
    """Reduce bags by the specified amount. Bags can go negative."""
    return current_bags - reduction


def calculate_hand_scores_with_bags(game):
    """
    Calculate hand scoring including bags system, nil bids, blind bidding, and blind nil for both players.
    """
    
    # Check for blind nil FIRST - it ends the game immediately
    if game.get('blind_nil') and game.get('player_bid') == 0:
        player_actual = game.get('player_tricks', 0)
        if player_actual == 0:
            # INSTANT WIN - Set score to 500 to show massive victory
            game['player_score'] = 500
            game['game_over'] = True
            game['winner'] = 'player'
            game['message'] = "BLIND NIL SUCCESS! You win the entire game instantly!"
            return {'explanation': "BLIND NIL SUCCESS - INSTANT GAME WIN!"}
        else:
            # INSTANT LOSS - Keep Marta's current score, player gets massive penalty
            game['player_score'] = -500  # Show crushing defeat
            game['game_over'] = True
            game['winner'] = 'computer'
            game['message'] = f"Blind Nil failed - you took {player_actual} tricks. Marta wins!"
            return {'explanation': f"BLIND NIL FAILURE - took {player_actual} tricks - GAME OVER"}

    
    # Normal scoring continues if no blind nil or blind nil not attempted
    player_bid = game.get('player_bid', 0)
    computer_bid = game.get('computer_bid', 0)
    player_actual = game.get('player_tricks', 0)
    computer_actual = game.get('computer_tricks', 0)
    
    # Check blind bids for both players
    is_player_blind = game.get('blind_bid') == player_bid and game.get('blind_bid') is not None
    is_computer_blind = game.get('computer_blind_bid') == computer_bid and game.get('computer_blind_bid') is not None
    
    # Get current bags
    current_player_bags = game.get('player_bags', 0)
    current_computer_bags = game.get('computer_bags', 0)
    
    # Calculate player points
    if player_bid == 0:
        if player_actual == 0:
            player_hand_points = 200  # NIL success
            player_bags_added = 0
        else:
            player_hand_points = -200  # NIL failure
            player_bags_added = player_actual
    elif player_actual >= player_bid:
        player_hand_points = (player_bid * 10)
        player_bags_added = player_actual - player_bid
        if is_player_blind:
            player_hand_points = apply_blind_scoring(player_hand_points, player_bid, player_actual)
    else:
        player_hand_points = -(player_bid * 10)
        player_bags_added = 0
        if is_player_blind:
            player_hand_points = apply_blind_scoring(player_hand_points, player_bid, player_actual)
    
    # Calculate computer points
    if computer_bid == 0:
        if computer_actual == 0:
            computer_hand_points = 200  # NIL success
            computer_bags_added = 0
        else:
            computer_hand_points = -200  # NIL failure
            computer_bags_added = computer_actual
    elif computer_actual >= computer_bid:
        computer_hand_points = (computer_bid * 10)
        computer_bags_added = computer_actual - computer_bid
        if is_computer_blind:
            computer_hand_points = apply_blind_scoring(computer_hand_points, computer_bid, computer_actual)
    else:
        computer_hand_points = -(computer_bid * 10)
        computer_bags_added = 0
        if is_computer_blind:
            computer_hand_points = apply_blind_scoring(computer_hand_points, computer_bid, computer_actual)
    
    # Update bag counts
    new_player_bags = current_player_bags + player_bags_added
    new_computer_bags = current_computer_bags + computer_bags_added
    
    # Apply bag penalties/bonuses
    player_score = game.get('player_score', 0) + player_hand_points
    computer_score = game.get('computer_score', 0) + computer_hand_points
    
    player_score, final_player_bags, player_penalty, player_bonus = apply_bags_penalty(player_score, new_player_bags)
    computer_score, final_computer_bags, computer_penalty, computer_bonus = apply_bags_penalty(computer_score, new_computer_bags)
    
    # Update game state
    game['player_bags'] = final_player_bags
    game['computer_bags'] = final_computer_bags
    game['player_score'] = player_score
    game['computer_score'] = computer_score
    
    # Get special card tracking for summary
    player_trick_special_cards = game.get('player_trick_special_cards', 0)
    computer_trick_special_cards = game.get('computer_trick_special_cards', 0)
    
    # Reset special card tracking for next hand
    game['player_trick_special_cards'] = 0
    game['computer_trick_special_cards'] = 0
    
    # Create explanation
    explanation_parts = []
    
    # Player explanation
    if player_bid == 0:
        if player_actual == 0:
            explanation_parts.append(f"You: NIL SUCCESS! 0 bid, 0 tricks (+200 pts)")
        else:
            explanation_parts.append(f"You: NIL FAILED! 0 bid, {player_actual} tricks (-200 pts, +{player_bags_added} bags)")
    elif is_player_blind:
        if player_actual >= player_bid:
            explanation_parts.append(f"You: BLIND {player_bid} SUCCESS! {player_actual} tricks (DOUBLE POINTS: +{player_hand_points} pts)")
        else:
            explanation_parts.append(f"You: BLIND {player_bid} FAILED! {player_actual} tricks (DOUBLE PENALTY: {player_hand_points} pts)")
        if player_bags_added > 0:
            explanation_parts[-1] += f", +{player_bags_added} bags"
    elif player_bags_added > 0:
        explanation_parts.append(f"You: {player_bid} bid, {player_actual} tricks (+{player_bags_added} bags)")
    else:
        explanation_parts.append(f"You: {player_bid} bid, {player_actual} tricks")
    
    # Computer explanation with blind support
    if computer_bid == 0:
        if computer_actual == 0:
            explanation_parts.append(f"Marta: NIL SUCCESS! 0 bid, 0 tricks (+200 pts)")
        else:
            explanation_parts.append(f"Marta: NIL FAILED! 0 bid, {computer_actual} tricks (-200 pts, +{computer_bags_added} bags)")
    elif is_computer_blind:
        if computer_actual >= computer_bid:
            explanation_parts.append(f"Marta: BLIND {computer_bid} SUCCESS! {computer_actual} tricks (DOUBLE POINTS: +{computer_hand_points} pts)")
        else:
            explanation_parts.append(f"Marta: BLIND {computer_bid} FAILED! {computer_actual} tricks (DOUBLE PENALTY: {computer_hand_points} pts)")
        if computer_bags_added > 0:
            explanation_parts[-1] += f", +{computer_bags_added} bags"
    elif computer_bags_added > 0:
        explanation_parts.append(f"Marta: {computer_bid} bid, {computer_actual} tricks (+{computer_bags_added} bags)")
    else:
        explanation_parts.append(f"Marta: {computer_bid} bid, {computer_actual} tricks")
    
    # Show special card effects from tricks
    if player_trick_special_cards > 0:
        explanation_parts.append(f"You won special cards: -{player_trick_special_cards} bags")
    if computer_trick_special_cards > 0:
        explanation_parts.append(f"Marta won special cards: -{computer_trick_special_cards} bags")
    
    # Show penalties and bonuses
    if player_penalty:
        penalty_count = (current_player_bags + player_bags_added) // 7
        explanation_parts.append(f"You: BAG PENALTY! -{penalty_count * 100} pts")
    
    if player_bonus:
        bonus_count = abs((current_player_bags + player_bags_added) // -5)
        explanation_parts.append(f"You: NEGATIVE BAG BONUS! +{bonus_count * 100} pts")
        
    if computer_penalty:
        penalty_count = (current_computer_bags + computer_bags_added) // 7
        explanation_parts.append(f"Marta: BAG PENALTY! -{penalty_count * 100} pts")
    
    if computer_bonus:
        bonus_count = abs((current_computer_bags + computer_bags_added) // -5)
        explanation_parts.append(f"Marta: NEGATIVE BAG BONUS! +{bonus_count * 100} pts")
    
    # Show current bag counts
    if final_player_bags != 0 or final_computer_bags != 0:
        explanation_parts.append(f"Bags: You {final_player_bags}/7, Marta {final_computer_bags}/7")
    
    return {
        'player_hand_points': player_hand_points,
        'computer_hand_points': computer_hand_points,
        'player_bags_added': player_bags_added,
        'computer_bags_added': computer_bags_added,
        'player_penalty': player_penalty,
        'computer_penalty': computer_penalty,
        'player_bonus': player_bonus,
        'computer_bonus': computer_bonus,
        'explanation': " | ".join(explanation_parts)
    }

def get_player_names_with_parity(player_parity, computer_parity):
    """
    Get display names that include the parity assignment.
    """
    player_name = f"You ({player_parity.title()})"
    computer_name = f"Marta ({computer_parity.title()})"
    
    return (player_name, computer_name)

================================================================================

FILE: ./utilities/computer_logic.py
--------------------------------------------------------------------------------
"""
Computer AI logic for Two-Man Spades
Handles all computer decision making including bidding, discarding, and play strategy
"""
import random
from .custom_rules import (
    get_discard_value, 
    is_special_card, 
    check_blind_bidding_eligibility,
    apply_blind_scoring
)

from .logging_utils import log_game_event

# =============================================================================
# GLOBAL AI DIFFICULTY SETTINGS
# =============================================================================

# Discard Strategy Settings
SINGLETON_SPECIAL_PRIORITY = 1000    # How much to prioritize discarding singleton 7‚ô¶/10‚ô£
VOID_CREATION_PRIORITY = 500         # How much to value creating voids
SPECIAL_CARD_PROTECTION = -100       # Penalty for discarding protected special cards
SPADE_DISCARD_PENALTY = 3           # Multiplier for avoiding spade discards
PARITY_CONSIDERATION = 1            # Small bonus for parity-favorable discards

# Bidding Strategy Settings  
BID_ACCURACY_BOOST = 0.3            # How much to boost base expectations (higher = more aggressive)
NIL_RISK_TOLERANCE = 0.8            # Threshold for nil bidding (lower = more nil attempts)
BLIND_DESPERATION_THRESHOLD = 120   # Points behind before considering blind bids
SCORE_BASED_ADJUSTMENT = 0.05       # How much score differential affects bidding
NIL_STRICTNESS = 0.8                # Lower = more likely to nil (minimum expectation for non-nil)
MAX_REASONABLE_BID = 6              # mnost she can bid


# Playing Strategy Settings
BAG_AVOIDANCE_STRENGTH = 0.92       # Multiplier when trying to avoid bags (lower = more avoidance)
LEAD_SAFETY_CONSIDERATION = True    # Whether to avoid leading into dangerous suits

# Meta-Strategy Settings
DEFAULT_BLIND_BID = 5

# =============================================================================
# HAND ANALYSIS FUNCTIONS
# =============================================================================

def analyze_hand_strength(hand):
    """
    Analyze hand strength and return expected trick count
    Returns tuple: (sure_tricks, probable_tricks, special_card_bonus)
    """
    sure_tricks = 0
    probable_tricks = 0
    special_card_bonus = 0
    
    # Count special cards for strategic value
    for card in hand:
        is_special, bag_reduction = is_special_card(card)
        if is_special:
            special_card_bonus += 0.2  # Special cards provide strategic value
    
    # Separate spades from other suits
    spades = [card for card in hand if card['suit'] == '‚ô†']
    other_suits = [card for card in hand if card['suit'] != '‚ô†']
    
    # Group other suits
    suits = {'‚ô•': [], '‚ô¶': [], '‚ô£': []}
    for card in other_suits:
        suits[card['suit']].append(card)
    
    # ENHANCED SPADES ANALYSIS
    spade_values = sorted([card['value'] for card in spades], reverse=True)
    spade_count = len(spades)
    
    # Apply spade count expectations
    if spade_count >= 5:
        sure_tricks += 3.0  # Expect 3 tricks from 5+ spades
        probable_tricks += 2.0
    elif spade_count == 4:
        sure_tricks += 2.0  # Expect 2 tricks from 4 spades  
        probable_tricks += 1.0
    elif spade_count == 3:
        sure_tricks += 1.5  # Expect 1.5 tricks from 3 spades
        probable_tricks += 0.5
    elif spade_count == 2:
        sure_tricks += 0.8  # Modest expectation from 2 spades
        probable_tricks += 0.4
    elif spade_count == 1:
        sure_tricks += 0.3  # Low expectation from 1 spade
    
    # High spades get additional value
    ace_spades = sum(1 for v in spade_values if v == 14)
    king_spades = sum(1 for v in spade_values if v == 13)
    queen_spades = sum(1 for v in spade_values if v == 12)
    
    if ace_spades > 0:
        sure_tricks += 0.3 * ace_spades  # Ace of spades is nearly guaranteed
    if king_spades > 0:
        sure_tricks += 0.2 * king_spades  # King of spades very likely
    if queen_spades > 0:
        probable_tricks += 0.2 * queen_spades  # Queen adds some value
    
    # ENHANCED OTHER SUITS ANALYSIS
    aces_other_suits = 0
    kings_other_suits = 0
    
    for suit, cards in suits.items():
        if not cards:
            continue
            
        values = sorted([card['value'] for card in cards], reverse=True)
        
        # Count high cards for overall hand strength
        aces_in_suit = sum(1 for v in values if v == 14)
        kings_in_suit = sum(1 for v in values if v == 13)
        
        aces_other_suits += aces_in_suit
        kings_other_suits += kings_in_suit
        
        # Aces in other suits (can be trumped but still strong)
        if 14 in values:
            sure_tricks += 0.8 * aces_in_suit  # High but not guaranteed
        
        # Protected kings (with ace)
        if 13 in values and 14 in values:
            sure_tricks += 0.6 * kings_in_suit  # Protected kings are strong
        elif 13 in values:
            if len(cards) >= 3:  # King in long suit has protection
                probable_tricks += 0.5 * kings_in_suit
            else:  # Unprotected king
                probable_tricks += 0.3 * kings_in_suit
        
        # Long suits can generate tricks through length
        if len(cards) >= 4:
            probable_tricks += (len(cards) - 3) * 0.25
    
    # MULTIPLE HIGH CARDS BONUS
    total_high_cards = aces_other_suits + kings_other_suits + ace_spades + king_spades
    
    if total_high_cards >= 4:
        sure_tricks += 0.5  # Multiple high cards create synergy
        probable_tricks += 0.3
    elif total_high_cards >= 3:
        sure_tricks += 0.3
        probable_tricks += 0.2
    elif total_high_cards >= 2:
        probable_tricks += 0.2
    
    # VOID SUITS (can trump)
    void_suits = sum(1 for cards in suits.values() if len(cards) == 0)
    if void_suits > 0 and spade_count >= 2:
        probable_tricks += void_suits * 0.4  # Void + spades = trumping opportunities
    
    return sure_tricks, probable_tricks, special_card_bonus

def analyze_suit_distribution(hand):
    """Analyze suit distribution and identify singleton/void opportunities"""
    suits = {'‚ô•': [], '‚ô¶': [], '‚ô£': [], '‚ô†': []}
    
    for card in hand:
        suits[card['suit']].append(card)
    
    distribution = {}
    for suit, cards in suits.items():
        distribution[suit] = {
            'count': len(cards),
            'cards': cards,
            'is_void': len(cards) == 0,
            'is_singleton': len(cards) == 1
        }
    
    return distribution

# =============================================================================
# DISCARD STRATEGY
# =============================================================================

def computer_discard_strategy(computer_hand, game_state):
    """
    Enhanced discard strategy prioritizing singleton special cards and void creation
    Returns index of card to discard
    """
    player_parity = game_state.get('player_parity', 'even')
    computer_parity = game_state.get('computer_parity', 'odd')
    
    # Analyze suit distribution
    suit_distribution = analyze_suit_distribution(computer_hand)
    
    discard_candidates = []
    
    for i, card in enumerate(computer_hand):
        score = 0
        suit_info = suit_distribution[card['suit']]
        
        # PRIORITY 1: Singleton special cards - MUST discard these
        if suit_info['is_singleton'] and card['suit'] != '‚ô†':
            is_special, _ = is_special_card(card)
            if is_special:
                score += SINGLETON_SPECIAL_PRIORITY
                discard_candidates.append((i, score))
                continue  # Don't apply other penalties to singleton specials
        
        # PRIORITY 2: Void creation (singleton non-specials in non-spade suits)
        elif suit_info['is_singleton'] and card['suit'] != '‚ô†':
            spade_count = suit_distribution['‚ô†']['count']
            # More spades = void is more valuable
            void_value = (spade_count * VOID_CREATION_PRIORITY) // 10
            if spade_count >= 4:  # Strong spade holding
                void_value += (VOID_CREATION_PRIORITY // 4)
            void_value -= card['value']  # Prefer discarding low cards
            score += void_value
        
        # PRIORITY 3: Normal special card protection (protected specials)
        else:
            is_special, _ = is_special_card(card)
            if is_special:
                score += SPECIAL_CARD_PROTECTION  # Negative score
        
        # PRIORITY 4: Avoid discarding spades
        if card['suit'] == '‚ô†':
            score -= card['value'] * SPADE_DISCARD_PENALTY
        else:
            # Prefer discarding low cards from other suits
            score += (15 - card['value'])
        
        # PRIORITY 5: Light parity consideration
        discard_value = get_discard_value(card)
        if computer_parity == 'even' and discard_value % 2 == 1:
            score += PARITY_CONSIDERATION
        elif computer_parity == 'odd' and discard_value % 2 == 0:
            score += PARITY_CONSIDERATION
        
        discard_candidates.append((i, score))
    
    # Return index of card with highest discard score
    return max(discard_candidates, key=lambda x: x[1])[0]

# =============================================================================
# BIDDING STRATEGY
# =============================================================================

def should_bid_nil(hand, game_state):
    """
    Determine if computer should bid nil
    """
    player_score = game_state.get('player_score', 0)
    computer_score = game_state.get('computer_score', 0)
    player_bid = game_state.get('player_bid', 0)
    
    # Get hand strength
    sure_tricks, probable_tricks, special_bonus = analyze_hand_strength(hand)
    total_expectation = sure_tricks + probable_tricks + special_bonus
    
    # Use configurable nil threshold
    if total_expectation > NIL_STRICTNESS:
        return False
    
    # Must have very few spades and they must be low
    spades = [card for card in hand if card['suit'] == '‚ô†']
    if len(spades) > 3:  # At most 3 spades
        return False
    
    # No high spades allowed
    for spade in spades:
        if spade['value'] >= 11:  # No J, Q, K, A of spades
            return False
    
    # Must have at least 2 twos for safety
    twos = [card for card in hand if card['rank'] == '2']
    if len(twos) < 2:
        return False
    
    # Must have mostly very low cards (2-7) in other suits
    other_suits = [card for card in hand if card['suit'] != '‚ô†']
    low_cards = [card for card in other_suits if card['value'] <= 7]
    
    if len(low_cards) < len(other_suits) - 1:
        return False
    
    # No aces or kings in other suits
    high_other_suits = [card for card in other_suits if card['value'] >= 13]
    if len(high_other_suits) > 0:
        return False
    
    # Don't nil if player already bid nil
    if player_bid == 0:
        return False
    
    # Only nil when significantly behind
    if computer_score >= player_score - 50:
        return False
    
    # Conservative probability - only when truly desperate
    return computer_score < player_score - 80

def should_bid_blind(hand, game_state):
    """
    Determine if computer should bid blind when eligible
    Returns tuple: (should_blind, blind_bid_amount)
    """
    player_score = game_state.get('player_score', 0)
    computer_score = game_state.get('computer_score', 0)
    
    # Check eligibility
    blind_eligibility = check_blind_bidding_eligibility(player_score, computer_score)
    if not blind_eligibility['computer_eligible']:
        return False, 0
    
    # If down by 100+, just go blind 5 (simplest aggressive strategy)
    return True, DEFAULT_BLIND_BID

def computer_bidding_brain(computer_hand, player_bid, game_state):
    """
    Main computer bidding function
    Returns tuple: (bid_amount, is_blind)
    """
    player_score = game_state.get('player_score', 0)
    computer_score = game_state.get('computer_score', 0)
    computer_bags = game_state.get('computer_bags', 0)
    
    # Check for nil opportunity first
    if should_bid_nil(computer_hand, game_state):
        return 0, False
    
    # Check for blind bidding opportunity
    should_blind, blind_amount = should_bid_blind(computer_hand, game_state)
    if should_blind:
        return blind_amount, True
    
    # Regular bidding logic
    sure_tricks, probable_tricks, special_bonus = analyze_hand_strength(computer_hand)
    base_expectation = sure_tricks + probable_tricks + special_bonus
    
    # Apply configurable accuracy boost
    base_expectation += BID_ACCURACY_BOOST
    
    # Score-based adjustments
    score_diff = computer_score - player_score
    if score_diff > 30:  # Ahead - be slightly conservative
        base_expectation *= (1 - SCORE_BASED_ADJUSTMENT)
    elif score_diff < -30:  # Behind - be slightly aggressive
        base_expectation *= (1 + SCORE_BASED_ADJUSTMENT)
    
    # Bag avoidance when close to penalty
    if computer_bags >= 5:
        base_expectation *= BAG_AVOIDANCE_STRENGTH
    
    # Strategic response to player's bid
    if player_bid is not None:
        if player_bid == 0:  # Player nil - be aggressive to set them
            base_expectation += 0.3
        elif player_bid <= 2:  # Player bid low
            base_expectation += 0.15
        elif player_bid >= 7:  # Player bid high
            base_expectation -= 0.2

    # Convert to bid
    raw_bid = max(0, min(10, round(base_expectation)))

    # Apply maximum reasonable bid cap
    raw_bid = min(raw_bid, MAX_REASONABLE_BID)

    # Bid range preferences
    if 2.5 <= base_expectation <= 5.5:
        if raw_bid < 3:
            raw_bid = 3  # Minimum reasonable bid is 3
        elif raw_bid == 5 and random.random() < 0.4:
            raw_bid = 4  # Sometimes prefer 4 over 5

    # Avoid obvious total-10 scenarios
    if player_bid is not None and abs((raw_bid + player_bid) - 10) <= 1 and random.random() < 0.3:
        if raw_bid > 3:
            raw_bid -= 1
        # Remove the elif raw_bid < 7 clause since we're capping at 6

    # Final bounds check with new maximum
    raw_bid = max(1, min(MAX_REASONABLE_BID, raw_bid))
    
    return raw_bid, False

# =============================================================================
# PLAYING STRATEGY
# =============================================================================

def computer_lead_strategy(computer_hand, spades_broken, game_state=None):
    """
    Enhanced leading strategy with absolute special card protection
    """
    if not computer_hand:
        return None
    
    # Import special card check
    from .custom_rules import is_special_card
    
    # Find all valid leads (respecting spades rules)
    valid_leads = []
    for i, card in enumerate(computer_hand):
        if card['suit'] != '‚ô†' or spades_broken or all(c['suit'] == '‚ô†' for c in computer_hand):
            valid_leads.append((i, card))
    
    if not valid_leads:
        return None
    
    # CRITICAL: Never lead special cards unless absolutely no choice
    non_special_leads = []
    special_leads = []
    
    for i, card in valid_leads:
        is_special, _ = is_special_card(card)
        if is_special:
            special_leads.append((i, card))
        else:
            non_special_leads.append((i, card))
    
    # If we have ANY non-special cards to lead, NEVER lead special cards
    if non_special_leads:
        leads_to_consider = non_special_leads
    else:
        # Only consider special cards if we literally have no other choice
        leads_to_consider = special_leads
    
    # Advanced bag forcing logic (only if we have non-special cards)
    if game_state and leads_to_consider == non_special_leads:
        computer_bid = game_state.get('computer_bid', 0)
        computer_tricks = game_state.get('computer_tricks', 0) 
        player_bags = game_state.get('player_bags', 0)
        
        # If we've made our bid and player has 5+ bags, lead high to force them
        if computer_tricks >= computer_bid > 0 and player_bags >= 5:
            return max(leads_to_consider, key=lambda x: x[1]['value'])[0]
    
    # Normal strategy: lead lowest safe card
    return min(leads_to_consider, key=lambda x: x[1]['value'])[0]

def computer_follow_strategy(computer_hand, current_trick, game_state):
    """
    Enhanced following strategy with special card protection and acquisition
    Returns index of best card to play
    """
    if not current_trick or not computer_hand:
        return None

    from .custom_rules import is_special_card

    computer_bid = game_state.get('computer_bid', 0)
    computer_tricks = game_state.get('computer_tricks', 0)
    
    # Check if computer has already made their bid
    made_bid = computer_tricks >= computer_bid and computer_bid > 0

    lead_card = current_trick[0]['card']
    lead_suit = lead_card['suit']
    lead_value = lead_card['value']

    # Check if player played a special card that we want to win
    player_has_special = is_special_card(lead_card)[0]

    # Categorize all cards by suit and special status
    same_suit_cards = []
    spade_cards = []
    other_suit_cards = []
    
    for i, card in enumerate(computer_hand):
        if card['suit'] == lead_suit:
            same_suit_cards.append((i, card))
        elif card['suit'] == '‚ô†':
            spade_cards.append((i, card))
        else:
            other_suit_cards.append((i, card))

    # CASE 1: Must follow suit
    if same_suit_cards:
        # Separate winners and losers
        winners = [(i, c) for i, c in same_suit_cards if c['value'] > lead_value]
        losers = [(i, c) for i, c in same_suit_cards if c['value'] <= lead_value]
        
        # Separate special and non-special cards
        special_winners = [(i, c) for i, c in winners if is_special_card(c)[0]]
        non_special_winners = [(i, c) for i, c in winners if not is_special_card(c)[0]]
        special_losers = [(i, c) for i, c in losers if is_special_card(c)[0]]
        non_special_losers = [(i, c) for i, c in losers if not is_special_card(c)[0]]
        
        # PRIORITY 1: If player played special card, try to win it (but not with our special cards)
        if player_has_special and non_special_winners:
            return min(non_special_winners, key=lambda x: x[1]['value'])[0]
        
        # PRIORITY 2: Computer has made bid - avoid extra tricks but protect special cards
        if made_bid:
            # Prefer to lose with non-special cards
            if non_special_losers:
                return max(non_special_losers, key=lambda x: x[1]['value'])[0]
            # If only special losers available, use lowest
            elif special_losers:
                return min(special_losers, key=lambda x: x[1]['value'])[0]
            # Must win - prefer non-special winners
            elif non_special_winners:
                return min(non_special_winners, key=lambda x: x[1]['value'])[0]
            # Only special winners left
            elif special_winners:
                return min(special_winners, key=lambda x: x[1]['value'])[0]
            # Fallback - should never reach here if same_suit_cards is not empty
            else:
                return same_suit_cards[0][0]
        
        # PRIORITY 3: Computer still needs tricks - try to win but protect special cards
        else:
            # Try to win with non-special cards first
            if non_special_winners:
                return min(non_special_winners, key=lambda x: x[1]['value'])[0]
            # Use special winners only if player has special card (worth the trade)
            elif special_winners and player_has_special:
                return min(special_winners, key=lambda x: x[1]['value'])[0]
            # Can't win without special cards - lose with non-special if possible
            elif non_special_losers:
                return min(non_special_losers, key=lambda x: x[1]['value'])[0]
            # Only special losers available
            elif special_losers:
                return min(special_losers, key=lambda x: x[1]['value'])[0]
            # Fallback
            else:
                return same_suit_cards[0][0]
    
    # CASE 2: Can't follow suit, can trump with spade
    elif lead_suit != '‚ô†' and spade_cards:
        special_spades = [(i, c) for i, c in spade_cards if is_special_card(c)[0]]
        non_special_spades = [(i, c) for i, c in spade_cards if not is_special_card(c)[0]]
        
        # If player has special card, trump to win it (but not with special spades)
        if player_has_special and non_special_spades:
            return min(non_special_spades, key=lambda x: x[1]['value'])[0]
        
        if made_bid:
            # Try to avoid trumping - discard from other suits instead
            special_others = [(i, c) for i, c in other_suit_cards if is_special_card(c)[0]]
            non_special_others = [(i, c) for i, c in other_suit_cards if not is_special_card(c)[0]]
            
            if non_special_others:
                return min(non_special_others, key=lambda x: x[1]['value'])[0]
            elif special_others:
                return min(special_others, key=lambda x: x[1]['value'])[0]
            # Must trump - use non-special spades first
            elif non_special_spades:
                return min(non_special_spades, key=lambda x: x[1]['value'])[0]
            elif special_spades:
                return min(special_spades, key=lambda x: x[1]['value'])[0]
            else:
                return 0  # Fallback to first card
        else:
            # Still need tricks - trump with lowest spade, prefer non-special
            if non_special_spades:
                return min(non_special_spades, key=lambda x: x[1]['value'])[0]
            elif special_spades:
                return min(special_spades, key=lambda x: x[1]['value'])[0]
            else:
                return 0  # Fallback
    
    # CASE 3: Can't follow or trump - must discard
    else:
        # Separate special and non-special cards from all remaining cards
        all_remaining = other_suit_cards + spade_cards  # spade_cards is empty in this case, but kept for clarity
        special_cards = [(i, c) for i, c in all_remaining if is_special_card(c)[0]]
        non_special_cards = [(i, c) for i, c in all_remaining if not is_special_card(c)[0]]
        
        # Always prefer to discard non-special cards
        if non_special_cards:
            return min(non_special_cards, key=lambda x: x[1]['value'])[0]
        elif special_cards:
            return min(special_cards, key=lambda x: x[1]['value'])[0]
        else:
            # Should never happen, but fallback to first card
            return 0

def autoplay_remaining_cards(game, session_obj=None):
    """
    Check for mathematically certain scenarios and auto-resolve remaining tricks.
    Only auto-resolves when 3-9 cards remain to preserve engagement.
    Returns (was_auto_resolved, explanation)
    """
    player_hand_size = len(game['player_hand'])
    computer_hand_size = len(game['computer_hand'])
    
    # Only auto-resolve if 3-9 cards remain (don't auto-play final 1-2 tricks)
    if player_hand_size == 0 or computer_hand_size == 0:
        return False, ""
    if player_hand_size < 3 or player_hand_size > 9:
        return False, ""
    
    player_suits = set(card['suit'] for card in game['player_hand'])
    computer_suits = set(card['suit'] for card in game['computer_hand'])
    winner = game.get('trick_winner')
    
    auto_resolved = False
    explanation = ""
    tricks_to_award = 0
    
    # Case 1: One player only spades, other no spades
    if player_suits == {'‚ô†'} and '‚ô†' not in computer_suits:
        tricks_to_award = len(game['player_hand'])
        game['player_tricks'] += tricks_to_award
        auto_resolved = True
        explanation = f"Auto-resolved: You had only spades ({tricks_to_award} cards), Marta had none"
        winner_of_remaining = 'player'
    elif computer_suits == {'‚ô†'} and '‚ô†' not in player_suits:
        tricks_to_award = len(game['computer_hand'])
        game['computer_tricks'] += tricks_to_award
        auto_resolved = True
        explanation = f"Auto-resolved: Marta had only spades ({tricks_to_award} cards), you had none"
        winner_of_remaining = 'computer'
    # Case 2: Trick winner has one suit, loser has none of it and no spades
    elif winner == 'player' and len(player_suits) == 1:
        player_suit = list(player_suits)[0]
        if player_suit not in computer_suits and '‚ô†' not in computer_suits:
            tricks_to_award = len(game['player_hand'])
            game['player_tricks'] += tricks_to_award
            auto_resolved = True
            explanation = f"Auto-resolved: You had only {player_suit} ({tricks_to_award} cards), Marta had none and no spades"
            winner_of_remaining = 'player'
    elif winner == 'computer' and len(computer_suits) == 1:
        computer_suit = list(computer_suits)[0]
        if computer_suit not in player_suits and '‚ô†' not in player_suits:
            tricks_to_award = len(game['computer_hand'])
            game['computer_tricks'] += tricks_to_award
            auto_resolved = True
            explanation = f"Auto-resolved: Marta had only {computer_suit} ({tricks_to_award} cards), you had none and no spades"
            winner_of_remaining = 'computer'
    
    if auto_resolved:
        # Simulate the remaining tricks and add to history
        player_cards = game['player_hand'].copy()
        computer_cards = game['computer_hand'].copy()
        current_trick_number = len(game.get('trick_history', [])) + 1
        
        # Log console message for auto-resolution
        print(f"AUTO-RESOLVE: {explanation}")
        
        # Play out remaining tricks in any order since outcome is predetermined
        while player_cards and computer_cards:
            # Just take first card from each hand (order doesn't matter)
            player_card = player_cards.pop(0)
            computer_card = computer_cards.pop(0)
            
            # Add to trick history
            game.setdefault('trick_history', []).append({
                'number': current_trick_number,
                'player_card': player_card,
                'computer_card': computer_card,
                'winner': winner_of_remaining  # Predetermined winner
            })
            
            # Log each auto-played trick to console
            p_text = f"{player_card['rank']}{player_card['suit']}"
            c_text = f"{computer_card['rank']}{computer_card['suit']}"
            winner_name = "You" if winner_of_remaining == 'player' else "Marta"
            print(f"AUTO-TRICK {current_trick_number}: {p_text} vs {c_text} -> {winner_name} wins")
            
            current_trick_number += 1
        
        # Clear hands and mark as over
        game['player_hand'] = []
        game['computer_hand'] = []
        game['hand_over'] = True
        
        # Log the auto-resolution
        if session_obj:
            log_game_event(
                event_type='hand_auto_resolved',
                event_data={
                    'explanation': explanation,
                    'tricks_simulated': tricks_to_award,
                    'cards_remaining_when_triggered': player_hand_size,
                    'final_player_tricks': game['player_tricks'],
                    'final_computer_tricks': game['computer_tricks']
                },
                session=session_obj
            )
    
    return auto_resolved, explanation

================================================================================

FILE: ./utilities/claude_utils.py
--------------------------------------------------------------------------------
# utilities/claude_utils.py
"""
Marta AI Chat utilities for Two-Man Spades game
Marta responds to direct user chat messages as an active player in the game
"""

import os
import anthropic
from typing import Dict, Optional, Any
import logging
import json

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# For production Secret Manager
try:
    from google.cloud import secretmanager
    GOOGLE_CLOUD_AVAILABLE = True
    print("[CLAUDE] Google Cloud Secret Manager available")
except ImportError:
    GOOGLE_CLOUD_AVAILABLE = False
    print("[CLAUDE] Google Cloud Secret Manager NOT available")

# For local development
try:
    from dotenv import load_dotenv
    load_dotenv()
    print("[CLAUDE] dotenv loaded successfully")
except ImportError:
    print("[CLAUDE] dotenv NOT available")

class ClaudeGameChat:
    def __init__(self):
        print("[CLAUDE] Initializing ClaudeGameChat for Marta's responses...")
        
        self.api_key = self._get_api_key()
        if not self.api_key:
            error_msg = "ANTHROPIC_API_KEY not found in environment or Secret Manager"
            print(f"[CLAUDE] ERROR: {error_msg}")
            raise ValueError(error_msg)
        
        print(f"[CLAUDE] API key found: {self.api_key[:10]}...{self.api_key[-4:] if len(self.api_key) > 14 else 'SHORT'}")
        
        try:
            # FIXED: More aggressive timeout and better error handling
            self.client = anthropic.Anthropic(
                api_key=self.api_key,
                max_retries=1,  # Only retry once to fail faster
                timeout=10.0,   # 10 second timeout to avoid hanging
            )
            print("[CLAUDE] Anthropic client initialized successfully with fast-fail config")
        except Exception as e:
            print(f"[CLAUDE] ERROR initializing Anthropic client: {e}")
            raise e
        
        self.model = "claude-3-5-haiku-20241022"
        self.max_tokens = 150
        self.temperature = 0.8
        
        self.system_prompt = (
            "You are Marta, playing Two-Man Spades against a human opponent. "
            "You're a seasoned spades player with a poker face and sharp wit, actively competing in this match. "
            "This is a custom variant with blind bidding, and special bag-reduction cards. "
            "You can see the current game state, your opponent's played cards, scores, "
            "bidding patterns, and trick outcomes - but you cannot see cards still in your opponent's hand. "
            "IMPORTANT: You also cannot reveal anything about discard results until the hand is completely over. "
            "CRITICAL: When referencing specific cards played in tricks, be absolutely accurate about who played what. "
            "Never claim to have played a card that your opponent actually played. The context clearly shows "
            "'my_card' vs 'opponent_card' and 'outcome' descriptions. Use these to avoid factual errors. "
            "Reference specific details from what you can legitimately know: current scores, recent plays, "
            "bidding accuracy, your own strategic decisions, bag situations and trick results. "
            "Be competitive and snarky while demonstrating your game intelligence through analysis of visible information. "
            "Speak as an active player in the match, not as an outside observer. "
            "You only respond when your opponent directly talks to you - never initiate conversation."
        )
        
        print(f"[CLAUDE] Configuration:")
        print(f"  Model: {self.model}")
        print(f"  Max tokens: {self.max_tokens}")
        print(f"  Temperature: {self.temperature}")
        print(f"  Max retries: 1")
        print(f"  Timeout: 10.0 seconds")
        print(f"  System prompt length: {len(self.system_prompt)} chars")
        print(f"  Mode: Marta as active player")
    


    def get_marta_response(self, 
                        player_message: str, 
                        game_context: Optional[Dict[str, Any]] = None) -> str:
        """Get a response from Marta as an active player in the game"""
        print(f"\n[CLAUDE] === MARTA CHAT REQUEST ===")
        print(f"[CLAUDE] Opponent message: '{player_message}'")
        print(f"[CLAUDE] Game context received: {bool(game_context)}")
        
        if game_context:
            print(f"[CLAUDE] Context keys count: {len(game_context.keys())}")
            print(f"[CLAUDE] Context keys: {list(game_context.keys())}")
        
        # SECRET DEBUG: Check for magic phrase and extract hand info
        secret_hand_reveal = ""
        magic_phrase_detected = False
        
        if "abra cadabra" in player_message.lower() and game_context:
            print(f"[CLAUDE] MAGIC PHRASE DETECTED! Preparing to reveal Marta's hand...")
            
            computer_hand = game_context.get('computer_hand', [])
            if computer_hand:
                hand_cards = []
                for card in computer_hand:
                    if isinstance(card, dict) and 'rank' in card and 'suit' in card:
                        hand_cards.append(f"{card['rank']}{card['suit']}")
                
                if hand_cards:
                    cards_str = ", ".join(hand_cards)
                    secret_hand_reveal = f"[SECRET_DEBUG_ACTIVATED: My actual hand is {cards_str}] "
                    magic_phrase_detected = True
                    print(f"[CLAUDE] Secret hand info prepared: {cards_str}")
        
        try:
            context_str = self._build_marta_visible_context(game_context)
            if not context_str or context_str == "[MY_VISIBLE_GAME_STATE: JSON conversion failed] ":
                print(f"[CLAUDE] Context building failed, using fallback")
                return self._fallback_marta_response(game_context)
            
            print(f"[CLAUDE] Built Marta's visible context successfully")
            
            # Enhanced user prompt that handles both normal and secret responses
            if magic_phrase_detected:
                user_prompt = (
                    f"{context_str}{secret_hand_reveal}"
                    f"My opponent said: '{player_message}'\n\n"
                    f"SPECIAL INSTRUCTION: The player used the secret phrase 'abra cadabra'! "
                    f"Start your response with something like 'Well well, you found my secret! Here are my cards: [list all the cards from SECRET_DEBUG_ACTIVATED]. "
                    f"Don't tell anyone I showed you!' Then continue with your normal competitive, snarky response about the game. "
                    f"Reference specific details from what you can legitimately see in the current game state."
                )
                print(f"[CLAUDE] Using SECRET REVEAL prompt mode")
            else:
                user_prompt = (
                    f"{context_str}"
                    f"My opponent said: '{player_message}'\n\n"
                    f"Respond as Marta with a competitive, game-aware comment (2-3 sentences) that references specific details "
                    f"from what I can legitimately see in the current game state. Mention relevant aspects like scores, "
                    f"recent cards played, bidding situation, bags, trick history, or strategic implications "
                    f"that are visible to me as a player. Show my tactical awareness and competitive intelligence while "
                    f"maintaining my snarky, poker-faced personality. Remember: I'm actively playing against this opponent."
                )
            
            print(f"[CLAUDE] Prompt length: {len(user_prompt)} chars")
            print(f"[CLAUDE] Making API call to {self.model}...")
            
            response = self.client.messages.create(
                model=self.model,
                max_tokens=self.max_tokens,
                temperature=self.temperature,
                system=self.system_prompt,
                messages=[{
                    "role": "user", 
                    "content": user_prompt
                }]
            )
            
            print(f"[CLAUDE] API call successful!")
            
            api_response = response.content[0].text.strip()
            print(f"[CLAUDE] Raw API response: '{api_response}'")
            print(f"[CLAUDE] Response length: {len(api_response)} chars")
            
            if magic_phrase_detected:
                print(f"[CLAUDE] SECRET REVEAL response delivered!")
            
            if not api_response:
                print(f"[CLAUDE] WARNING: Empty response from API")
                return self._fallback_marta_response(game_context)
            
            print(f"[CLAUDE] SUCCESS: Returning Marta's response")
            return api_response
            
        except anthropic.APITimeoutError as e:
            print(f"[CLAUDE] API Timeout Error after 10s: {e}")
            fallback = self._fallback_marta_response(game_context)
            print(f"[CLAUDE] Using timeout fallback: '{fallback}'")
            return fallback
            
        except anthropic.RateLimitError as e:
            print(f"[CLAUDE] Rate Limit Error: {e}")
            retry_after = getattr(e.response, 'headers', {}).get('retry-after', 'unknown')
            print(f"[CLAUDE] Retry-after header: {retry_after}")
            fallback = self._fallback_marta_response(game_context)
            print(f"[CLAUDE] Using rate limit fallback: '{fallback}'")
            return fallback
            
        except anthropic.APIConnectionError as e:
            print(f"[CLAUDE] Connection Error: {e}")
            fallback = self._fallback_marta_response(game_context)
            print(f"[CLAUDE] Using connection error fallback: '{fallback}'")
            return fallback
            
        except anthropic.APIError as e:
            print(f"[CLAUDE] General API Error: {e}")
            print(f"[CLAUDE] Error type: {type(e)}")
            if hasattr(e, 'status_code'):
                print(f"[CLAUDE] Status code: {e.status_code}")
            fallback = self._fallback_marta_response(game_context)
            print(f"[CLAUDE] Using API error fallback: '{fallback}'")
            return fallback
            
        except Exception as e:
            print(f"[CLAUDE] Unexpected error: {e}")
            print(f"[CLAUDE] Error type: {type(e)}")
            fallback = self._fallback_marta_response(game_context)
            print(f"[CLAUDE] Using general error fallback: '{fallback}'")
            return fallback

    def _build_marta_visible_context(self, game_context: Optional[Dict[str, Any]]) -> str:
        """Build context showing only what Marta can legitimately see during play"""
        print(f"[CLAUDE] Building Marta's visible context...")
        
        if not game_context:
            print(f"[CLAUDE] No game context provided")
            return "[MY_VISIBLE_GAME_STATE: No context available] "
        
        print(f"[CLAUDE] Processing {len(game_context)} context keys...")
        
        # Create Marta's visible context (exclude her hidden hand AND secret discard info)
        marta_visible_context = {}
        
        for key, value in game_context.items():
            print(f"[CLAUDE] Processing key: {key} (type: {type(value).__name__})")
            
            # Skip internal/hidden information
            excluded_keys = {
                'computer_hand', 'client_info', 'game_id', 'show_computer_hand', 
                'current_hand_id', 'game_started_at', 'action_sequence', 'trick_display_timer'
            }
            
            # Check if we should exclude discard information
            hand_is_over = game_context.get('hand_over', False)
            if not hand_is_over:
                excluded_keys.update({
                    'discard_bonus_explanation',
                    'pending_discard_result', 'pending_special_discard_result'
                })
            
            if key in excluded_keys:
                print(f"[CLAUDE] Excluding key: {key}")
                continue
                
            # Convert and rename from Marta's perspective with safe handling
            try:
                if key == 'player_hand' and isinstance(value, list):
                    # Marta can only see count, not actual cards in opponent's hand
                    marta_visible_context['opponent_hand_size'] = len(value)
                    print(f"[CLAUDE] Converted player_hand to opponent_hand_size: {len(value)}")
                elif key == 'computer_hand_count':
                    marta_visible_context['my_hand_size'] = value
                    print(f"[CLAUDE] Set my_hand_size: {value}")
                elif key == 'current_trick' and isinstance(value, list):
                    converted_trick = []
                    for play in value:
                        if isinstance(play, dict) and 'card' in play:
                            card = play['card']
                            if isinstance(card, dict) and 'rank' in card and 'suit' in card:
                                card_str = f"{card['rank']}{card['suit']}"
                                if play['player'] == 'computer':
                                    converted_trick.append({
                                        'player': 'me',
                                        'card': card_str,
                                        'card_details': f"I played {card_str}"
                                    })
                                else:
                                    converted_trick.append({
                                        'player': 'opponent',
                                        'card': card_str,
                                        'card_details': f"Opponent played {card_str}"
                                    })
                    marta_visible_context[key] = converted_trick
                    print(f"[CLAUDE] Converted current_trick: {len(converted_trick)} plays")
                elif key == 'trick_history' and isinstance(value, list):
                    converted_history = []
                    for trick in value:
                        if isinstance(trick, dict):
                            converted_trick = {
                                'number': trick.get('number'),
                                'winner': 'me' if trick.get('winner') == 'computer' else 'opponent'
                            }
                            
                            # CRITICAL: Clearly identify who played which card
                            my_card = None
                            opponent_card = None
                            
                            if trick.get('computer_card') and isinstance(trick['computer_card'], dict):
                                card = trick['computer_card']
                                if 'rank' in card and 'suit' in card:
                                    my_card = f"{card['rank']}{card['suit']}"
                                    converted_trick['my_card'] = my_card
                                    
                            if trick.get('player_card') and isinstance(trick['player_card'], dict):
                                card = trick['player_card']
                                if 'rank' in card and 'suit' in card:
                                    opponent_card = f"{card['rank']}{card['suit']}"
                                    converted_trick['opponent_card'] = opponent_card
                            
                            # Add explicit play description to prevent confusion
                            if my_card and opponent_card:
                                converted_trick['play_summary'] = f"I played {my_card}, opponent played {opponent_card}"
                                if converted_trick['winner'] == 'me':
                                    converted_trick['outcome'] = f"I won with my {my_card} beating opponent's {opponent_card}"
                                else:
                                    converted_trick['outcome'] = f"Opponent won with their {opponent_card} beating my {my_card}"
                            
                            converted_history.append(converted_trick)
                            
                    marta_visible_context[key] = converted_history
                    print(f"[CLAUDE] Converted trick_history: {len(converted_history)} tricks")
                # Handle discard cards ONLY if hand is over AND they exist
                elif key == 'player_discarded' and value and hand_is_over:
                    if isinstance(value, dict) and 'rank' in value and 'suit' in value:
                        opponent_discard = f"{value['rank']}{value['suit']}"
                        marta_visible_context['opponent_discarded'] = opponent_discard
                        marta_visible_context['opponent_discard_details'] = f"Opponent discarded {opponent_discard}"
                        print(f"[CLAUDE] Converted player_discarded to opponent_discarded")
                elif key == 'computer_discarded' and value and hand_is_over:
                    if isinstance(value, dict) and 'rank' in value and 'suit' in value:
                        my_discard = f"{value['rank']}{value['suit']}"
                        marta_visible_context['my_discarded'] = my_discard
                        marta_visible_context['my_discard_details'] = f"I discarded {my_discard}"
                        print(f"[CLAUDE] Converted computer_discarded to my_discarded")
                elif key.startswith('player_'):
                    # Rename player stats to opponent stats for Marta's perspective
                    new_key = key.replace('player_', 'opponent_')
                    marta_visible_context[new_key] = value
                    print(f"[CLAUDE] Renamed {key} to {new_key}")
                elif key.startswith('computer_'):
                    # Rename computer stats to my stats for Marta's perspective
                    new_key = key.replace('computer_', 'my_')
                    marta_visible_context[new_key] = value
                    print(f"[CLAUDE] Renamed {key} to {new_key}")
                elif key == 'player_parity':
                    marta_visible_context['opponent_parity'] = value
                elif key == 'computer_parity':
                    marta_visible_context['my_parity'] = value
                elif key == 'player_name':
                    marta_visible_context['opponent_name'] = value
                elif key == 'computer_name':
                    marta_visible_context['my_name'] = value
                elif key == 'turn':
                    # Convert turn to Marta's perspective
                    if value == 'computer':
                        marta_visible_context[key] = 'my_turn'
                    elif value == 'player':
                        marta_visible_context[key] = 'opponent_turn'
                    else:
                        marta_visible_context[key] = value
                elif key == 'trick_leader':
                    # Convert trick leader to Marta's perspective
                    if value == 'computer':
                        marta_visible_context[key] = 'me'
                    elif value == 'player':
                        marta_visible_context[key] = 'opponent'
                    else:
                        marta_visible_context[key] = value
                elif key == 'first_leader':
                    # Convert first leader to Marta's perspective
                    if value == 'computer':
                        marta_visible_context[key] = 'me'
                    elif value == 'player':
                        marta_visible_context[key] = 'opponent'
                    else:
                        marta_visible_context[key] = value
                elif key == 'winner':
                    # Convert winner to Marta's perspective
                    if value == 'computer':
                        marta_visible_context[key] = 'me'
                    elif value == 'player':
                        marta_visible_context[key] = 'opponent'
                    else:
                        marta_visible_context[key] = value
                else:
                    # Keep other fields as-is (but exclude discard explanation during active play)
                    if key == 'discard_bonus_explanation' and not hand_is_over:
                        print(f"[CLAUDE] Excluding discard_bonus_explanation (hand not over)")
                        continue
                    # Only include serializable values
                    if isinstance(value, (str, int, float, bool, type(None))):
                        marta_visible_context[key] = value
                        print(f"[CLAUDE] Kept simple value: {key}")
                    else:
                        print(f"[CLAUDE] Skipping complex value: {key} (type: {type(value).__name__})")
                        
            except Exception as e:
                print(f"[CLAUDE] Error processing key {key}: {e}")
                continue
        
        # Rest of the function remains the same...
        print(f"[CLAUDE] Final context keys: {list(marta_visible_context.keys())}")
        
        # Test JSON conversion with detailed error handling
        try:
            context_json = json.dumps(marta_visible_context, separators=(',', ':'))
            print(f"[CLAUDE] JSON conversion successful, length: {len(context_json)} chars")
        except Exception as e:
            print(f"[CLAUDE] JSON conversion FAILED: {e}")
            return "[MY_VISIBLE_GAME_STATE: JSON conversion failed] "
        
        final_context = f"[MY_VISIBLE_GAME_STATE: {context_json}] "
        print(f"[CLAUDE] Final context length: {len(final_context)} chars")
        return final_context
    
    def _fallback_marta_response(self, game_context: Optional[Dict[str, Any]]) -> str:
        """Game-aware fallback responses from Marta's perspective as active player"""
        print(f"[CLAUDE] Generating Marta's fallback response...")
        
        if not game_context:
            fallbacks = [
                "Interesting question...",
                "You're keeping me on my toes.",
                "That's one way to look at it."
            ]
            import random
            selected = random.choice(fallbacks)
            print(f"[CLAUDE] No context fallback: '{selected}'")
            return selected
        
        # Try to make contextual fallbacks from Marta's perspective
        try:
            my_score = game_context.get('computer_score', 0)  # Marta's score
            opponent_score = game_context.get('player_score', 0)  # Player's score
            phase = game_context.get('phase', 'unknown')
            hand_number = game_context.get('hand_number', 1)
            
            contextual_fallbacks = []
            
            # Score-based fallbacks from Marta's perspective
            if my_score > opponent_score:
                contextual_fallbacks.append(f"I'm up by {my_score - opponent_score} points. Feeling good about this.")
            elif opponent_score > my_score:
                contextual_fallbacks.append(f"You're ahead by {opponent_score - my_score}, but I'm not worried.")
            else:
                contextual_fallbacks.append("We're tied up - makes this interesting.")
            
            # Phase-based fallbacks
            if phase == 'bidding':
                contextual_fallbacks.append("Think carefully about that bid.")
            elif phase == 'playing':
                contextual_fallbacks.append("Your move. Choose wisely.")
            elif phase == 'discard':
                contextual_fallbacks.append("That discard better be strategic.")
            
            # Hand progression fallbacks
            if hand_number > 1:
                contextual_fallbacks.append(f"Hand {hand_number} already? Time's flying.")
            
            if contextual_fallbacks:
                import random
                selected = random.choice(contextual_fallbacks)
                print(f"[CLAUDE] Contextual Marta fallback: '{selected}'")
                return selected
                
        except Exception as e:
            print(f"[CLAUDE] Error creating contextual fallback: {e}")
        
        # Default fallbacks if context parsing fails
        generic_fallbacks = [
            "Fair point.",
            "We'll see how that plays out.",
            "Keeping my cards close to my chest.",
            "Game's not over yet.",
            "Interesting perspective.",
            "That's a bold strategy."
        ]
        
        import random
        selected = random.choice(generic_fallbacks)
        print(f"[CLAUDE] Generic Marta fallback: '{selected}'")
        return selected
    
    def _get_api_key(self) -> Optional[str]:
        """Get API key from environment or Secret Manager with detailed logging"""
        print(f"[CLAUDE] === API KEY DETECTION ===")
        
        # First try environment variable
        api_key = os.getenv('ANTHROPIC_API_KEY')
        if api_key:
            print(f"[CLAUDE] Found API key in environment variable")
            print(f"[CLAUDE] Key length: {len(api_key)} chars")
            print(f"[CLAUDE] Key starts with: {api_key[:10]}...")
            return api_key
        
        print(f"[CLAUDE] No API key in environment variable")
        
        # Check if we're in Google Cloud
        is_gcp = self._is_google_cloud_environment()
        print(f"[CLAUDE] Running in Google Cloud: {is_gcp}")
        
        if is_gcp:
            print(f"[CLAUDE] Attempting to get key from Secret Manager...")
            return self._get_secret_from_manager()
        
        print(f"[CLAUDE] Not in Google Cloud environment")
        print(f"[CLAUDE] No API key source available")
        return None
    
    def _is_google_cloud_environment(self) -> bool:
        """Detect if we're running in Google Cloud with logging"""
        gae_env = os.getenv('GAE_ENV')
        k_service = os.getenv('K_SERVICE')
        gcp_project = os.getenv('GOOGLE_CLOUD_PROJECT')
        
        print(f"[CLAUDE] Environment check:")
        print(f"  GAE_ENV: {gae_env}")
        print(f"  K_SERVICE: {k_service}")
        print(f"  GOOGLE_CLOUD_PROJECT: {gcp_project}")
        
        is_gcp = (
            gae_env == 'standard' or
            k_service is not None or
            gcp_project is not None
        )
        
        print(f"[CLAUDE] Is Google Cloud: {is_gcp}")
        return is_gcp
    
    def _get_secret_from_manager(self) -> Optional[str]:
        """Get API key from Google Secret Manager with detailed logging"""
        print(f"[CLAUDE] === SECRET MANAGER ACCESS ===")
        
        if not GOOGLE_CLOUD_AVAILABLE:
            print(f"[CLAUDE] ERROR: Google Cloud libraries not available")
            return None
        
        try:
            project_id = os.getenv('GOOGLE_CLOUD_PROJECT')
            print(f"[CLAUDE] Project ID: {project_id}")
            
            if not project_id:
                print(f"[CLAUDE] ERROR: GOOGLE_CLOUD_PROJECT not set")
                return None
            
            print(f"[CLAUDE] Creating Secret Manager client...")
            client = secretmanager.SecretManagerServiceClient()
            
            secret_name = f"projects/{project_id}/secrets/ANTHROPIC_API_KEY/versions/latest"
            print(f"[CLAUDE] Secret path: {secret_name}")
            
            print(f"[CLAUDE] Accessing secret...")
            response = client.access_secret_version(request={"name": secret_name})
            
            secret_value = response.payload.data.decode("UTF-8")
            print(f"[CLAUDE] Secret retrieved successfully")
            print(f"[CLAUDE] Secret length: {len(secret_value)} chars")
            print(f"[CLAUDE] Secret starts with: {secret_value[:10]}...")
            
            return secret_value
            
        except Exception as e:
            print(f"[CLAUDE] ERROR accessing Secret Manager: {e}")
            print(f"[CLAUDE] Error type: {type(e)}")
            return None

# Singleton instance
_claude_chat = None

def get_claude_chat() -> ClaudeGameChat:
    """Get singleton Claude chat instance for Marta responses"""
    global _claude_chat
    if _claude_chat is None:
        print("[CLAUDE] Creating new ClaudeGameChat singleton instance (Marta as player)")
        _claude_chat = ClaudeGameChat()
    else:
        print("[CLAUDE] Using existing ClaudeGameChat singleton (Marta as player)")
    return _claude_chat

def get_smart_marta_response(player_message: str, game_state: Dict[str, Any]) -> str:
    """Convenience function to get Marta's response as active player"""
    print(f"[CLAUDE] get_smart_marta_response called (Marta as active player)")
    print(f"[CLAUDE] Opponent message: '{player_message}'")
    print(f"[CLAUDE] Game state keys: {list(game_state.keys()) if game_state else 'None'}")
    
    claude = get_claude_chat()
    response = claude.get_marta_response(player_message, game_state)
    
    print(f"[CLAUDE] Final Marta response: '{response}'")
    return response

# Test function for debugging
def test_claude_connection():
    """Test function to verify Claude API connectivity with Marta as player"""
    print(f"[CLAUDE] === TESTING CLAUDE CONNECTION (MARTA AS PLAYER) ===")
    
    try:
        claude = get_claude_chat()
        
        # Test with rich game context - simulating opponent asking about game state
        test_context = {
            'hand_number': 2,
            'phase': 'playing',
            'player_score': 89,  # Opponent's score
            'computer_score': 127,  # Marta's score
            'player_bid': 4,  # Opponent's bid
            'computer_bid': 6,  # Marta's bid
            'player_tricks': 2,  # Opponent's tricks
            'computer_tricks': 3,  # Marta's tricks
            'player_bags': 1,  # Opponent's bags
            'computer_bags': 0,  # Marta's bags
            'hand_over': False,  # Hand still in progress - no discard info
            'trick_history': [
                {'number': 1, 'player_card': {'rank': '7', 'suit': '‚ô£'}, 'computer_card': {'rank': 'A', 'suit': '‚ô£'}, 'winner': 'computer'},
                {'number': 2, 'player_card': {'rank': 'K', 'suit': '‚ô†'}, 'computer_card': {'rank': 'Q', 'suit': '‚ô†'}, 'winner': 'player'}
            ]
        }
        
        test_response = claude.get_marta_response("How do you think this hand is going?", test_context)
        print(f"[CLAUDE] Marta player test successful: '{test_response}'")
        return True, test_response
    except Exception as e:
        print(f"[CLAUDE] Marta player test failed: {e}")
        return False, str(e)

if __name__ == "__main__":
    # Run test when script is executed directly
    success, result = test_claude_connection()
    print(f"Marta player test result: {success} - {result}")

================================================================================

FILE: ./utilities/gmail_utils.py
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Gmail utilities for sending emails and notifications
100% self-contained - NO sibling imports allowed.
"""
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
from google.cloud import secretmanager
from os import path
import logging
from typing import List, Optional, Dict, Any

# =============================================================================
# GLOBAL VARIABLES - Email configuration
# =============================================================================

# Define the project ID and the secret IDs for username and app password
PROJECT_ID = 'kumori-404602'
GMAIL_USERNAME_SECRET_ID = 'KUMORI_GMAIL_USERNAME'
GMAIL_APP_PASSWORD_SECRET_ID = 'KUMORI_GMAIL_APP_PASSWORD'

# Email defaults
EMAIL_DEFAULTS = {
    "smtp_server": "smtp.gmail.com",
    "smtp_port": 465,
    "default_from_name": "Kumori.ai",
    "use_ssl": True,
    "timeout_seconds": 30
}

# =============================================================================
# CORE FUNCTIONS
# =============================================================================

def get_secret_version(project_id: str, secret_id: str, version_id: str = "latest") -> str:
    """Get secret from Google Cloud Secret Manager."""
    client = secretmanager.SecretManagerServiceClient()
    name = f"projects/{project_id}/secrets/{secret_id}/versions/{version_id}"
    response = client.access_secret_version(request={"name": name})
    return response.payload.data.decode('UTF-8')

def get_gmail_credentials() -> Dict[str, str]:
    """Get Gmail credentials from Google Cloud Secret Manager."""
    return {
        'user': get_secret_version(PROJECT_ID, GMAIL_USERNAME_SECRET_ID),
        'password': get_secret_version(PROJECT_ID, GMAIL_APP_PASSWORD_SECRET_ID),
    }

def send_email(
    subject: str,
    body: str,
    to_emails: List[str],
    cc_emails: Optional[List[str]] = None,
    bcc_emails: Optional[List[str]] = None,
    attachment_paths: Optional[List[str]] = None,
    is_html: bool = False,
    from_name: str = None
) -> bool:
    """
    Send an email using Gmail SMTP.
    
    Args:
        subject: Email subject line
        body: Email body content
        to_emails: List of recipient email addresses
        cc_emails: List of CC email addresses (optional)
        bcc_emails: List of BCC email addresses (optional)
        attachment_paths: List of file paths to attach (optional)
        is_html: Whether the body is HTML format (default: False)
        from_name: Display name for sender (uses default if None)
    
    Returns:
        bool: True if email sent successfully, False otherwise
    """
    if from_name is None:
        from_name = EMAIL_DEFAULTS["default_from_name"]
    
    try:
        # Get credentials
        gmail_credentials = get_gmail_credentials()
        gmail_user = gmail_credentials['user']
        gmail_password = gmail_credentials['password']
        
        # Create message
        message = MIMEMultipart()
        message['From'] = f'{from_name} <{gmail_user}>'
        message['To'] = ', '.join(to_emails)
        message['Subject'] = subject
        
        # Add CC and BCC if provided
        if cc_emails:
            message['Cc'] = ', '.join(cc_emails)
        if bcc_emails:
            message['Bcc'] = ', '.join(bcc_emails)
        
        # Attach body
        if is_html:
            message.attach(MIMEText(body, 'html'))
        else:
            message.attach(MIMEText(body, 'plain'))
        
        # Add attachments if provided
        if attachment_paths:
            for attachment_path in attachment_paths:
                if not path.exists(attachment_path):
                    logging.warning(f"Attachment file not found: {attachment_path}")
                    continue
                    
                part = MIMEBase('application', 'octet-stream')
                with open(attachment_path, 'rb') as file:
                    part.set_payload(file.read())
                encoders.encode_base64(part)
                part.add_header(
                    'Content-Disposition',
                    'attachment',
                    filename=path.basename(attachment_path)
                )
                message.attach(part)
        
        # Prepare recipient list (including CC and BCC for actual sending)
        all_recipients = to_emails.copy()
        if cc_emails:
            all_recipients.extend(cc_emails)
        if bcc_emails:
            all_recipients.extend(bcc_emails)
        
        # Send email
        smtp_server = EMAIL_DEFAULTS["smtp_server"]
        smtp_port = EMAIL_DEFAULTS["smtp_port"]
        timeout = EMAIL_DEFAULTS["timeout_seconds"]
        
        with smtplib.SMTP_SSL(smtp_server, smtp_port, timeout=timeout) as server:
            server.login(gmail_user, gmail_password)
            server.send_message(message, to_addrs=all_recipients)
            
        logging.info('Email sent successfully')
        print('Email sent successfully')
        return True
        
    except Exception as e:
        logging.error(f"Failed to send email: {e}")
        print(f"Failed to send email: {e}")
        return False

def send_simple_email(
    subject: str, 
    body: str, 
    to_email: str, 
    attachment_paths: Optional[List[str]] = None,
    is_html: bool = False
) -> bool:
    """
    Simplified function to send email to a single recipient.
    
    Args:
        subject: Email subject line
        body: Email body content
        to_email: Recipient email address
        attachment_paths: List of file paths to attach (optional)
        is_html: Whether the body is HTML format (default: False)
    
    Returns:
        bool: True if email sent successfully, False otherwise
    """
    return send_email(subject, body, [to_email], attachment_paths=attachment_paths, is_html=is_html)

def send_notification_email(
    title: str,
    message: str,
    recipient: str,
    priority: str = "normal",
    include_timestamp: bool = True
) -> bool:
    """
    Send a formatted notification email.
    
    Args:
        title: Notification title
        message: Notification message
        recipient: Email recipient
        priority: Priority level ("low", "normal", "high")
        include_timestamp: Whether to include timestamp
    
    Returns:
        bool: True if email sent successfully, False otherwise
    """
    from datetime import datetime
    
    # Format subject based on priority
    priority_prefix = {"low": "‚ÑπÔ∏è", "normal": "üì®", "high": "üö®"}.get(priority, "üì®")
    subject = f"{priority_prefix} {title}"
    
    # Format body
    body_parts = []
    if include_timestamp:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        body_parts.append(f"Time: {timestamp}")
    
    body_parts.append(f"Message: {message}")
    
    if priority == "high":
        body_parts.append("\n‚ö†Ô∏è This is a high-priority notification.")
    
    body = "\n\n".join(body_parts)
    
    return send_simple_email(subject, body, recipient)

def send_pipeline_completion_email(
    project_name: str,
    recipient: str,
    success: bool,
    details: Optional[Dict[str, Any]] = None
) -> bool:
    """
    Send pipeline completion notification email.
    
    Args:
        project_name: Name of the project/pipeline
        recipient: Email recipient
        success: Whether pipeline completed successfully
        details: Optional details dictionary
    
    Returns:
        bool: True if email sent successfully, False otherwise
    """
    status = "‚úÖ Completed Successfully" if success else "‚ùå Failed"
    subject = f"Pipeline {status}: {project_name}"
    
    body_parts = [
        f"Project: {project_name}",
        f"Status: {status}",
    ]
    
    if details:
        body_parts.append("\nDetails:")
        for key, value in details.items():
            body_parts.append(f"  {key}: {value}")
    
    body = "\n".join(body_parts)
    
    return send_simple_email(subject, body, recipient)

def get_email_defaults() -> Dict[str, Any]:
    """Get current email defaults."""
    return EMAIL_DEFAULTS.copy()

def update_email_defaults(**kwargs) -> None:
    """Update email defaults globally."""
    EMAIL_DEFAULTS.update(kwargs)
    logging.info(f"Updated email defaults: {kwargs}")

if __name__ == '__main__':
    # This module is meant to be imported, not run directly
    print("This is a utility module. Import it in your script to use the email functions.")
    print("Example:")
    print("from utilities.gmail_utils import send_email")
    print("send_email('Subject', 'Body', ['recipient@example.com'])")

================================================================================

FILE: ./utilities/logging_utils.py
--------------------------------------------------------------------------------
"""
Streamlined logging utilities for Two-Man Spades - WRITE-ONLY approach with ASYNC database operations
Logs everything for historical analysis but NEVER reads/loads existing files during normal operation
All logging is append-only for performance - reading is only available via explicit debug endpoints
Database operations are now fully asynchronous and non-blocking for instant game responses
"""
import time
import uuid
import json
import os
import platform
from datetime import datetime
import threading
import queue

# =============================================================================
# GLOBAL LOGGING CONFIGURATION
# =============================================================================

# Environment detection
IS_LOCAL_DEVELOPMENT = os.environ.get('GAE_ENV') != 'standard'
IS_PRODUCTION = not IS_LOCAL_DEVELOPMENT

LOGGING_ENABLED = True
LOG_TO_CONSOLE = True
LOG_TO_FILE = IS_LOCAL_DEVELOPMENT
LOG_GAME_ACTIONS = True
LOG_AI_DECISIONS = True
LOG_AI_ANALYSIS = True
LOG_GAME_EVENTS = True
CONSOLE_LOG_LEVEL = 'ALL'  # 'ALL', 'ACTIONS_ONLY', 'AI_ONLY', 'EVENTS_ONLY', 'OFF'
LOGS_DIRECTORY = 'logging' if IS_LOCAL_DEVELOPMENT else None
CURRENT_LOG_FILE = None

# Production logging placeholder
PRODUCTION_LOG_PLACEHOLDER = "[PRODUCTION] Log entry saved to pending database implementation"

# =============================================================================
# ASYNC DATABASE LOGGING SYSTEM
# =============================================================================

# Global async logging system
_db_queue = queue.Queue(maxsize=1000)  # Limit queue size to prevent memory issues
_db_worker_thread = None
_db_worker_running = False
_db_operations_completed = 0
_db_operations_failed = 0

def start_async_db_logging():
    """Start background database logging thread"""
    global _db_worker_thread, _db_worker_running
    
    if not IS_PRODUCTION or _db_worker_running:
        return
    
    _db_worker_running = True
    _db_worker_thread = threading.Thread(target=_db_worker, daemon=True)
    _db_worker_thread.start()
    print("[DB] Async logging started")

def _db_worker():
    """Background worker that processes database operations"""
    global _db_operations_completed, _db_operations_failed
    
    while _db_worker_running:
        try:
            # Wait up to 1 second for an operation
            operation = _db_queue.get(timeout=1.0)
            
            if operation is None:  # Shutdown signal
                break
            
            # Execute the database operation
            try:
                result = operation['func'](*operation['args'], **operation['kwargs'])
                if result:
                    _db_operations_completed += 1
                else:
                    _db_operations_failed += 1
            except Exception as e:
                _db_operations_failed += 1
                print(f"[DB] Async operation failed: {e}")
            finally:
                _db_queue.task_done()
                
        except queue.Empty:
            continue  # No operations pending, keep waiting
        except Exception as e:
            print(f"[DB] Worker error: {e}")

def queue_db_operation(func, *args, **kwargs):
    """Queue a database operation for background processing"""
    if not IS_PRODUCTION:
        print(f"[DB] Skipping queue operation - not in production")
        return
    
    if not _db_worker_running:
        print(f"[DB] ERROR: Worker not running, cannot queue operation")
        return
    
    try:
        operation = {
            'func': func,
            'args': args,
            'kwargs': kwargs,
            'queued_at': time.time()
        }
        _db_queue.put_nowait(operation)
        print(f"[DB] Queued operation: {func.__name__} (queue size: {_db_queue.qsize()})")
    except queue.Full:
        print("[DB] Queue full, dropping operation")
        global _db_operations_failed
        _db_operations_failed += 1

def stop_async_db_logging():
    """Stop the background logging thread"""
    global _db_worker_running
    _db_worker_running = False
    _db_queue.put(None)  # Shutdown signal
    
    if _db_worker_thread:
        _db_worker_thread.join(timeout=5.0)
    
    print(f"[DB] Async logging stopped. Completed: {_db_operations_completed}, Failed: {_db_operations_failed}")

def get_async_db_stats():
    """Get statistics about async database operations"""
    return {
        'queue_size': _db_queue.qsize(),
        'operations_completed': _db_operations_completed,
        'operations_failed': _db_operations_failed,
        'worker_running': _db_worker_running
    }

# =============================================================================
# CLIENT IP TRACKING FUNCTIONS
# =============================================================================

def get_client_ip(request):
    """Get the client's real IP address, preferring IPv4 when available from the same client."""
    
    # Get all potential IPs from various headers
    potential_ips = []
    
    # Check X-Forwarded-For (most common)
    forwarded = request.headers.get('X-Forwarded-For')
    if forwarded:
        potential_ips.extend([ip.strip() for ip in forwarded.split(',')])
    
    # Check other common headers
    for header in ['X-Real-IP', 'X-Client-IP']:
        ip = request.headers.get(header)
        if ip:
            potential_ips.append(ip.strip())
    
    # Add the direct connection IP
    if request.remote_addr:
        potential_ips.append(request.remote_addr)
    
    if not potential_ips:
        return 'unknown'
    
    # Filter out obviously internal/load balancer IPs
    filtered_ips = []
    for ip in potential_ips:
        # Skip Google/AWS internal IPs and private ranges
        if not ip.startswith(('169.254.', '10.', '192.168.', '172.', '127.')):
            filtered_ips.append(ip)
    
    if not filtered_ips:
        # If all IPs were filtered, use the first original IP
        return potential_ips[0]
    
    # Prefer IPv4 from the filtered list
    ipv4_ips = [ip for ip in filtered_ips if '.' in ip and ':' not in ip]
    if ipv4_ips:
        return ipv4_ips[0]
    
    # Fall back to first filtered IP (likely IPv6)
    return filtered_ips[0]

def get_client_info(request):
    """Get comprehensive client information for logging."""
    client_ip = get_client_ip(request)
    
    return {
        'ip_address': client_ip,
        'user_agent': request.headers.get('User-Agent', 'unknown'),
        'referer': request.headers.get('Referer', 'none'),
        'method': request.method,
        'endpoint': request.endpoint,
        'is_local': client_ip.startswith('127.') or client_ip.startswith('192.168.') or client_ip == 'localhost'
    }

def track_session_client(session, request):
    """Track client info in session for persistent identification."""
    client_info = get_client_info(request)
    
    session_client = {
        'ip_address': client_info['ip_address'],
        'first_seen': session.get('client_first_seen', time.time()),
        'last_seen': time.time(),
        'session_actions': session.get('client_actions', 0) + 1
    }
    
    session['client_info'] = session_client
    session['client_actions'] = session_client['session_actions'] 
    session['client_first_seen'] = session_client['first_seen']
    session.modified = True
    
    return session_client

def get_session_client_summary(session):
    """Get summary of client activity for this session."""
    client_info = session.get('client_info', {})
    
    if client_info:
        session_duration = time.time() - session.get('client_first_seen', time.time())
        return {
            'ip_address': client_info.get('ip_address', 'unknown'),
            'actions_this_session': session.get('client_actions', 0),
            'session_duration_minutes': round(session_duration / 60, 1),
            'first_seen': datetime.fromtimestamp(session.get('client_first_seen', 0)).strftime('%H:%M:%S')
        }
    
    return None

# =============================================================================
# FILE MANAGEMENT FUNCTIONS - WRITE ONLY
# =============================================================================

def _ensure_logs_directory():
    """Ensure the logging directory exists - only in local development, no scanning"""
    if not IS_LOCAL_DEVELOPMENT:
        return
        
    if LOGS_DIRECTORY and not os.path.exists(LOGS_DIRECTORY):
        os.makedirs(LOGS_DIRECTORY)

def _generate_log_filename(game_id, timestamp=None):
    """Generate a unique log filename for a game - only used in local development"""
    if not IS_LOCAL_DEVELOPMENT:
        return None
        
    if timestamp is None:
        timestamp = datetime.now()
    
    date_str = timestamp.strftime("%Y%m%d")
    time_str = timestamp.strftime("%H%M%S")
    short_game_id = game_id[:8] if game_id else "unknown"
    
    return f"game_log_{date_str}_{time_str}_{short_game_id}.json"

def _start_new_log_file(game_id):
    """Start a new log file for a game - WRITE ONLY, no existing file checking"""
    global CURRENT_LOG_FILE
    
    if not IS_LOCAL_DEVELOPMENT:
        return
    
    if not LOG_TO_FILE:
        return
    
    _ensure_logs_directory()  # Only creates if missing, no scanning
    
    filename = _generate_log_filename(game_id)
    CURRENT_LOG_FILE = os.path.join(LOGS_DIRECTORY, filename)
    
    # Initialize with game metadata
    initial_entry = {
        'log_type': 'game_metadata',
        'data': {
            'game_id': game_id,
            'log_file_created': datetime.now().isoformat(),
            'log_version': '2.0',
            'game_type': 'two_man_spades',
            'environment': 'local_development'
        }
    }
    
    try:
        # Write initial entry - no reading of existing files
        with open(CURRENT_LOG_FILE, 'w') as f:
            json.dump([initial_entry], f, indent=2, default=str)
        
        if LOG_TO_CONSOLE:
            print(f"Started new game log: {filename}")
        
    except Exception as e:
        if LOG_TO_CONSOLE:
            print(f"Warning: Could not create new log file: {e}")
        CURRENT_LOG_FILE = None

def _write_to_current_log_file(log_entry):
    """Write log entry to current game's log file - APPEND ONLY"""
    if not IS_LOCAL_DEVELOPMENT or not LOG_TO_FILE or not CURRENT_LOG_FILE:
        return
    
    try:
        # APPEND-ONLY approach - read existing, append new, write back
        logs = []
        if os.path.exists(CURRENT_LOG_FILE):
            try:
                with open(CURRENT_LOG_FILE, 'r') as f:
                    logs = json.load(f)
            except (json.JSONDecodeError, IOError):
                logs = []  # Start fresh if file is corrupted
        
        logs.append(log_entry)
        
        with open(CURRENT_LOG_FILE, 'w') as f:
            json.dump(logs, f, indent=2, default=str)
            
    except Exception as e:
        if LOG_TO_CONSOLE:
            print(f"Warning: Could not write to log file: {e}")

def _finalize_current_log_file(final_game_state):
    """Add final game metadata and close current log file"""
    if not IS_LOCAL_DEVELOPMENT or not CURRENT_LOG_FILE:
        return
        
    finalization_entry = {
        'log_type': 'game_finalization',
        'data': {
            'game_completed_at': datetime.now().isoformat(),
            'final_scores': {
                'player_score': final_game_state.get('player_score', 0),
                'computer_score': final_game_state.get('computer_score', 0)
            },
            'winner': final_game_state.get('winner'),
            'hands_played': final_game_state.get('hand_number', 1),
            'environment': 'local_development'
        }
    }
    
    _write_to_current_log_file(finalization_entry)
    
    if LOG_TO_CONSOLE:
        print(f"Finalized game log: {os.path.basename(CURRENT_LOG_FILE)}")

# =============================================================================
# GAME INITIALIZATION - STREAMLINED
# =============================================================================

def initialize_game_logging(game):
    """Initialize logging structures and start new log file for a new game - NO FILE SCANNING"""
    import random
    
    # Generate truly unique game ID using timestamp + random component
    timestamp_part = str(int(time.time() * 1000))  # milliseconds for better precision
    random_part = str(random.randint(1000, 9999))
    game_id = f"{timestamp_part}{random_part}"
    
    # Generate unique hand ID
    hand_id = str(uuid.uuid4())
    
    # Update game state with logging metadata
    game.update({
        'game_id': game_id,
        'current_hand_id': hand_id,
        'game_started_at': time.time(),
        'action_sequence': 0
    })
    
    # Start new log file (development only) - NO scanning of existing files
    _start_new_log_file(game_id)
    
    # Log game initialization to file
    _write_to_current_log_file({
        'log_type': 'game_init',
        'data': {
            'game_id': game_id,
            'started_at': time.time(),
            'player_parity': game.get('player_parity'),
            'computer_parity': game.get('computer_parity'),
            'first_leader': game.get('first_leader')
        }
    })
    
    return game

def initialize_game_logging_with_client(game, request=None):
    """Enhanced game initialization with client tracking and async database logging"""
    game = initialize_game_logging(game)
    
    # Add batching system
    game = initialize_event_batching(game)
    
    if request:
        client_info = get_client_info(request)
        game['client_info'] = client_info
        
        # Console output only
        if LOG_TO_CONSOLE:
            print(f"NEW GAME STARTED by {client_info['ip_address']}")
            print(f"   Game ID: {game.get('game_id', 'unknown')}")
    
    # NEW: Async database logging for production
    if IS_PRODUCTION:
        queue_db_operation(
            _create_game_with_player_async,
            game,
            game.get('client_info')
        )
    
    return game

def _create_game_with_player_async(game, client_info):
    """Async wrapper for database game creation"""
    try:
        print(f"[DB] === DETAILED ASYNC DEBUG ===")
        print(f"[DB] Game keys: {list(game.keys())}")
        print(f"[DB] current_hand_id: {repr(game.get('current_hand_id'))}")
        print(f"[DB] game_id: {repr(game.get('game_id'))}")
        print(f"[DB] game_started_at: {repr(game.get('game_started_at'))}")
        print(f"[DB] client_info type: {type(client_info)}")
        print(f"[DB] client_info content: {repr(client_info)}")
        
        if client_info and isinstance(client_info, dict):
            print(f"[DB] client_info keys: {list(client_info.keys())}")
            print(f"[DB] ip_address: {repr(client_info.get('ip_address'))}")
        
        from .postgres_utils import create_game_with_player
        
        success = create_game_with_player(game, client_info)
        print(f"[DB] Database operation returned: {success}")
        print(f"[DB] === END ASYNC DEBUG ===")
        return success
    except Exception as e:
        print(f"[DB] EXCEPTION in async game creation: {e}")
        import traceback
        traceback.print_exc()
        return False

def finalize_game_logging(game):
    """Called when a game ends to finalize the log file and database"""
    # File logging finalization
    _finalize_current_log_file(game)
    
    # NEW: Async database game finalization (production)
    if IS_PRODUCTION:
        queue_db_operation(
            _finalize_game_async,
            game.get('current_hand_id'),  # Changed to current_hand_id
            game
        )

def _finalize_game_async(hand_id, game):
    """Async wrapper for database game finalization"""
    try:
        from .postgres_utils import finalize_game
        success = finalize_game(hand_id, game)
        if success:
            print(f"[DB] Hand {hand_id} finalized in database")
        else:
            print(f"[DB] Hand {hand_id} failed to finalize in database")
        return success
    except Exception as e:
        print(f"[DB] Database game finalization failed: {e}")
        return False

def start_new_hand_logging(game):
    """Generate new hand ID and log hand start"""
    hand_id = str(uuid.uuid4())
    game['current_hand_id'] = hand_id

# =============================================================================
# CORE LOGGING FUNCTIONS - NOW WITH ASYNC DATABASE OPERATIONS
# =============================================================================

def log_action(action_type, player, action_data, session=None, additional_context=None, request=None):
    """Central logging function for all player/system game actions with ASYNC database integration"""
    if not LOGGING_ENABLED or not LOG_GAME_ACTIONS:
        return
    
    client_info = get_client_info(request) if request else None
    action_record = _build_action_record(action_type, player, action_data, session, additional_context)
    
    if client_info:
        action_record['client_info'] = client_info
    
    # File logging (development) - synchronous, fast
    _write_to_current_log_file({
        'log_type': 'action',
        'data': action_record
    })
    
    # NEW: Async database logging (production) - non-blocking
    if IS_PRODUCTION and session and 'game' in session:
        game = session['game']
        # Get client IP from multiple sources
        client_ip = None
        if client_info:
            client_ip = client_info.get('ip_address')
        elif game.get('client_info'):
            client_ip = game['client_info'].get('ip_address')
        
        queue_db_operation(
            _log_game_event_to_db_async,
            game.get('current_hand_id'),  # CHANGED: now current_hand_id
            f"action_{action_type}",
            {
                'player': player,
                'action_data': action_data,
                'additional_context': additional_context
            },
            hand_number=game.get('hand_number'),
            session_sequence=game.get('action_sequence'),
            player=player,
            action_type=action_type,
            client_ip=client_ip
        )
    
    # Console logging - synchronous, fast
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'ACTIONS_ONLY']:
        _print_action_log(action_record)

def log_game_event(event_type, event_data, session=None):
    """Central logging function for major game events with ASYNC database integration"""
    if not LOGGING_ENABLED or not LOG_GAME_EVENTS:
        return
    
    event_record = _build_event_record(event_type, event_data, session)
    
    # File logging (development) - synchronous, fast
    _write_to_current_log_file({
        'log_type': 'game_event',
        'data': event_record
    })
    
    # NEW: Async database logging (production) - non-blocking
    if IS_PRODUCTION and session and 'game' in session:
        game = session['game']
        # Get client IP from game state if available
        client_ip = None
        if game.get('client_info'):
            client_ip = game['client_info'].get('ip_address')
        
        # FIXED: Ensure we have a valid hand_id before logging
        hand_id = game.get('current_hand_id')
        if hand_id:  # Only log if we have a valid hand_id
            queue_db_operation(
                _log_game_event_to_db_async,
                hand_id,  # Now guaranteed to be non-null
                event_type,
                event_data,
                hand_number=game.get('hand_number'),
                session_sequence=game.get('action_sequence'),
                player=event_data.get('player') if isinstance(event_data, dict) else None,
                action_type=event_type,
                client_ip=client_ip
            )
        else:
            print(f"[DB] Skipping event {event_type} - no hand_id available")
    
    # Console logging - synchronous, fast
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'EVENTS_ONLY']:
        _print_event_log(event_record)

def _log_game_event_to_db_async(hand_id, event_type, event_data, **kwargs):
    """Async wrapper for database event logging"""
    try:
        print(f"[DB] Attempting to log event: {event_type} for hand {hand_id}")
        from .postgres_utils import log_game_event_to_db
        success = log_game_event_to_db(
            hand_id,
            event_type,
            event_data,
            hand_number=kwargs.get('hand_number'),
            session_sequence=kwargs.get('session_sequence'),
            player=kwargs.get('player'),
            action_type=kwargs.get('action_type'),
            client_ip=kwargs.get('client_ip')
        )
        if success:
            print(f"[DB] Successfully logged event: {event_type}")
        else:
            print(f"[DB] Failed to log event: {event_type}")
        return success
    except Exception as e:
        print(f"[DB] Exception logging event {event_type}: {e}")
        import traceback
        traceback.print_exc()
        return False

def log_ai_decision(decision_type, decision_data, analysis=None, reasoning=None, session=None):
    """Central logging function for AI decision-making process"""
    if not LOGGING_ENABLED or not LOG_AI_DECISIONS:
        return
    
    decision_record = _build_ai_decision_record(decision_type, decision_data, analysis, reasoning)
    
    _write_to_current_log_file({
        'log_type': 'ai_decision',
        'data': decision_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'AI_ONLY']:
        _print_ai_decision_log(decision_record)

def log_ai_analysis(analysis_type, analysis_data, session=None):
    """Log detailed AI analysis with structured data"""
    if not LOGGING_ENABLED or not LOG_AI_ANALYSIS:
        return
    
    analysis_record = {
        'timestamp': time.time(),
        'analysis_type': analysis_type,
        'analysis_data': analysis_data
    }
    
    _write_to_current_log_file({
        'log_type': 'ai_analysis',
        'data': analysis_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'AI_ONLY']:
        _print_ai_analysis_log(analysis_record)

def log_ai_strategy(strategy_type, strategy_data, session=None):
    """Log AI strategy decisions and evaluations"""
    if not LOGGING_ENABLED or not LOG_AI_ANALYSIS:
        return
    
    strategy_record = {
        'timestamp': time.time(),
        'strategy_type': strategy_type,
        'strategy_data': strategy_data
    }
    
    _write_to_current_log_file({
        'log_type': 'ai_strategy',
        'data': strategy_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'AI_ONLY']:
        _print_ai_strategy_log(strategy_record)

def log_ai_evaluation(evaluation_type, candidates, chosen_candidate, session=None):
    """Log AI evaluation of multiple options"""
    if not LOGGING_ENABLED or not LOG_AI_ANALYSIS:
        return
    
    evaluation_record = {
        'timestamp': time.time(),
        'evaluation_type': evaluation_type,
        'candidates_evaluated': len(candidates),
        'all_candidates': candidates,
        'chosen_candidate': chosen_candidate,
        'confidence': _calculate_evaluation_confidence(candidates, chosen_candidate)
    }
    
    _write_to_current_log_file({
        'log_type': 'ai_evaluation',
        'data': evaluation_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'AI_ONLY']:
        _print_ai_evaluation_log(evaluation_record)

# =============================================================================
# INTERNAL HELPER FUNCTIONS
# =============================================================================

def _build_action_record(action_type, player, action_data, session, additional_context):
    """Build standardized action record"""
    game = session['game'] if session and 'game' in session else {}
    
    game['action_sequence'] = game.get('action_sequence', 0) + 1
    
    return {
        'sequence': game['action_sequence'],
        'timestamp': time.time(),
        'game_id': game.get('game_id'),
        'hand_id': game.get('current_hand_id'),
        'action_type': action_type,
        'player': player,
        'hand_number': game.get('hand_number', 1),
        'phase': game.get('phase', 'unknown'),
        'action_data': action_data,
        'game_context': {
            'player_score': game.get('player_score', 0),
            'computer_score': game.get('computer_score', 0),
            'player_tricks': game.get('player_tricks', 0),
            'computer_tricks': game.get('computer_tricks', 0),
            'player_bags': game.get('player_bags', 0),
            'computer_bags': game.get('computer_bags', 0),
            'spades_broken': game.get('spades_broken', False),
            'turn': game.get('turn'),
            'trick_leader': game.get('trick_leader')
        },
        'additional_context': additional_context
    }

def _build_ai_decision_record(decision_type, decision_data, analysis, reasoning):
    """Build standardized AI decision record"""
    return {
        'timestamp': time.time(),
        'decision_type': decision_type,
        'decision_data': decision_data,
        'analysis': analysis,
        'reasoning': reasoning,
        'confidence': _calculate_confidence(decision_type, decision_data, analysis)
    }

def _build_event_record(event_type, event_data, session):
    """Build standardized event record"""
    game = session['game'] if session and 'game' in session else {}
    
    return {
        'timestamp': time.time(),
        'game_id': game.get('game_id'),
        'hand_id': game.get('current_hand_id'),
        'event_type': event_type,
        'hand_number': game.get('hand_number', 1),
        'event_data': event_data
    }

def _calculate_confidence(decision_type, decision_data, analysis):
    """Calculate confidence score for AI decisions"""
    if not analysis:
        return 0.5
    
    if decision_type == 'bid':
        expected_tricks = analysis.get('base_expectation', 0)
        bid_amount = decision_data.get('bid_amount', 0)
        diff = abs(expected_tricks - bid_amount)
        return max(0.0, min(1.0, 1.0 - (diff / 5.0)))
    
    elif decision_type == 'discard_choice':
        chosen_score = decision_data.get('final_score', 0)
        if chosen_score >= 1000:
            return 1.0
        elif chosen_score >= 500:
            return 0.9
        else:
            return 0.6
    
    return 0.5

def _calculate_evaluation_confidence(candidates, chosen_candidate):
    """Calculate confidence for AI evaluations"""
    if not candidates or len(candidates) < 2:
        return 1.0
    
    if isinstance(chosen_candidate, dict) and 'score' in chosen_candidate:
        try:
            scores = [c.get('score', 0) for c in candidates if isinstance(c, dict)]
            if scores and len(scores) >= 2:
                best_score = max(scores)
                second_best = sorted(scores, reverse=True)[1]
                if best_score > 0:
                    confidence = min(1.0, (best_score - second_best) / best_score)
                    return max(0.1, confidence)
        except:
            pass
    
    return max(0.3, 1.0 - (len(candidates) * 0.1))

# =============================================================================
# CONSOLE OUTPUT FUNCTIONS
# =============================================================================

def _print_action_log(action_record):
    """Print action log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(action_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"=== ACTION #{action_record['sequence']}: {action_record['action_type'].upper()} by {action_record['player'].upper()} ===")
    print(f"Hand #{action_record['hand_number']} | Phase: {action_record['phase']} | Time: {timestamp_str}")
    print(f"Data: {action_record['action_data']}")
    
    ctx = action_record['game_context']
    print(f"Context: Score {ctx['player_score']}-{ctx['computer_score']} | Tricks {ctx['player_tricks']}-{ctx['computer_tricks']} | Bags {ctx['player_bags']}-{ctx['computer_bags']}")
    
    if action_record.get('additional_context'):
        print(f"Extra: {action_record['additional_context']}")
    
    print("=" * 60)

def _print_ai_decision_log(decision_record):
    """Print AI decision log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(decision_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"AI DECISION: {decision_record['decision_type'].upper()}")
    print(f"Time: {timestamp_str} | Confidence: {decision_record['confidence']:.2f}")
    print(f"Decision: {decision_record['decision_data']}")
    
    if decision_record.get('analysis'):
        print(f"Analysis: {decision_record['analysis']}")
    
    if decision_record.get('reasoning'):
        print(f"Reasoning: {decision_record['reasoning']}")
    
    print("=" * 58)

def _print_event_log(event_record):
    """Print game event log to console with formatting"""
    print(f"GAME EVENT: {event_record['event_type'].upper()}")
    print(f"Hand #{event_record['hand_number']} | Data: {event_record['event_data']}")
    print("*" * 40)

def _print_ai_analysis_log(analysis_record):
    """Print AI analysis log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(analysis_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"AI ANALYSIS: {analysis_record['analysis_type'].upper()}")
    print(f"Time: {timestamp_str}")
    
    for key, value in analysis_record['analysis_data'].items():
        if isinstance(value, (int, float)):
            print(f"  {key}: {value:.2f}")
        else:
            print(f"  {key}: {value}")
    
    print("-" * 40)

def _print_ai_strategy_log(strategy_record):
    """Print AI strategy log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(strategy_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"AI STRATEGY: {strategy_record['strategy_type'].upper()}")
    print(f"Time: {timestamp_str}")
    print(f"Strategy: {strategy_record['strategy_data']}")
    print("-" * 40)

def _print_ai_evaluation_log(evaluation_record):
    """Print AI evaluation log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(evaluation_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"AI EVALUATION: {evaluation_record['evaluation_type'].upper()}")
    print(f"Time: {timestamp_str} | Confidence: {evaluation_record['confidence']:.2f}")
    print(f"Evaluated {evaluation_record['candidates_evaluated']} options")
    print(f"Chosen: {evaluation_record['chosen_candidate']}")
    
    top_candidates = evaluation_record['all_candidates'][:3]
    for i, candidate in enumerate(top_candidates):
        print(f"  #{i+1}: {candidate}")
    
    if len(evaluation_record['all_candidates']) > 3:
        print(f"  ... and {len(evaluation_record['all_candidates']) - 3} more")
    
    print("-" * 40)

# =============================================================================
# DEBUG ENDPOINTS - FILE READING ONLY ON DEMAND
# =============================================================================

def get_environment_info():
    """Get information about the current environment - NO FILE READING"""
    return {
        'is_local_development': IS_LOCAL_DEVELOPMENT,
        'is_production': IS_PRODUCTION,
        'file_logging_enabled': LOG_TO_FILE,
        'console_logging_enabled': LOG_TO_CONSOLE,
        'async_db_logging_enabled': IS_PRODUCTION,
        'gae_env': os.environ.get('GAE_ENV', 'Not set'),
        'platform': platform.system(),
        'logs_directory': LOGS_DIRECTORY,
        'current_log_file': os.path.basename(CURRENT_LOG_FILE) if CURRENT_LOG_FILE else None,
        'async_db_stats': get_async_db_stats()
    }

def get_logging_summary():
    """Get summary of current session only - NO FILE READING"""
    return {
        'current_log_file': os.path.basename(CURRENT_LOG_FILE) if CURRENT_LOG_FILE else None,
        'logging_enabled': LOGGING_ENABLED,
        'environment': 'local_development' if IS_LOCAL_DEVELOPMENT else 'production',
        'file_logging_available': IS_LOCAL_DEVELOPMENT,
        'async_db_logging_available': IS_PRODUCTION,
        'async_db_stats': get_async_db_stats(),
        'message': 'Historical log analysis available via explicit debug endpoints only'
    }

# The following functions are only called by explicit debug routes, never during normal gameplay

def list_game_logs():
    """List all available game log files - ONLY for debug endpoints"""
    if not IS_LOCAL_DEVELOPMENT or not os.path.exists(LOGS_DIRECTORY):
        return []
    
    log_files = []
    for filename in os.listdir(LOGS_DIRECTORY):
        if filename.startswith('game_log_') and filename.endswith('.json'):
            filepath = os.path.join(LOGS_DIRECTORY, filename)
            try:
                parts = filename.replace('game_log_', '').replace('.json', '').split('_')
                if len(parts) >= 3:
                    stat = os.stat(filepath)
                    log_files.append({
                        'filename': filename,
                        'date': parts[0],
                        'time': parts[1],
                        'game_id': parts[2],
                        'size_bytes': stat.st_size,
                        'modified': datetime.fromtimestamp(stat.st_mtime).isoformat()
                    })
            except Exception:
                pass
    
    return sorted(log_files, key=lambda x: x['modified'], reverse=True)

def get_game_log_summary(filename):
    """Get summary of a specific game log file - ONLY for debug endpoints"""
    if not IS_LOCAL_DEVELOPMENT:
        return {'error': 'File logging not available in production'}
    
    filepath = os.path.join(LOGS_DIRECTORY, filename)
    if not os.path.exists(filepath):
        return {'error': f'Log file not found: {filename}'}
    
    try:
        with open(filepath, 'r') as f:
            logs = json.load(f)
        
        log_counts = {}
        for entry in logs:
            log_type = entry.get('log_type', 'unknown')
            log_counts[log_type] = log_counts.get(log_type, 0) + 1
        
        return {
            'filename': filename,
            'total_entries': len(logs),
            'log_type_counts': log_counts,
            'file_size_kb': round(os.path.getsize(filepath) / 1024, 2)
        }
        
    except Exception as e:
        return {'error': f'Could not analyze log file: {e}'}

# =============================================================================
# CONTROL FUNCTIONS
# =============================================================================

def enable_logging():
    """Enable all logging"""
    global LOGGING_ENABLED
    LOGGING_ENABLED = True
    if LOG_TO_CONSOLE:
        print("Logging ENABLED")

def disable_logging():
    """Disable all logging"""
    global LOGGING_ENABLED
    LOGGING_ENABLED = False
    if LOG_TO_CONSOLE:
        print("Logging DISABLED")

def set_console_log_level(level):
    """Set console logging level"""
    global CONSOLE_LOG_LEVEL
    valid_levels = ['ALL', 'ACTIONS_ONLY', 'AI_ONLY', 'EVENTS_ONLY', 'OFF']
    if level in valid_levels:
        CONSOLE_LOG_LEVEL = level
        if LOG_TO_CONSOLE:
            print(f"Console log level set to: {level}")
    else:
        if LOG_TO_CONSOLE:
            print(f"Invalid log level. Valid options: {valid_levels}")

def toggle_console_logging():
    """Toggle console logging on/off"""
    global LOG_TO_CONSOLE
    LOG_TO_CONSOLE = not LOG_TO_CONSOLE
    print(f"Console logging: {'ON' if LOG_TO_CONSOLE else 'OFF'}")

# =============================================================================
# ENHANCED BATCH EVENT SYSTEM WITH ASYNC PROCESSING
# =============================================================================

class GameEventBatch:
    def __init__(self, hand_id):
        self.hand_id = hand_id
        self.events = []
    
    def add_event(self, event_type, event_data, **kwargs):
        """Add event to batch for later database write"""
        self.events.append({
            'timestamp': time.time(),
            'event_type': event_type,
            'event_data': event_data,
            **kwargs
        })
    
    def flush_to_db_async(self):
        """Queue batch for async database write"""
        if IS_PRODUCTION and self.events:
            queue_db_operation(
                _process_event_batch_async,
                self.hand_id,
                self.events.copy()  # Copy to avoid race conditions
            )
            self.events.clear()

def _process_event_batch_async(hand_id, events):
    """Process event batch in background thread"""
    try:
        from .postgres_utils import batch_log_events
        success = batch_log_events(hand_id, events) 
        if success:
            print(f"[DB] Async batch: {len(events)} events logged")
        return success
    except Exception as e:
        print(f"[DB] Async batch failed: {e}")
        return False

def initialize_event_batching(game):
    """Add event batching to existing game initialization"""
    if IS_PRODUCTION:
        # Store just the events list in the game, not the batch object
        game['event_batch_events'] = []
    return game

def flush_hand_events(session):
    """Flush batched events at hand completion - NOW ASYNC"""
    if IS_PRODUCTION and 'game' in session:
        game = session['game']
        events = game.get('event_batch_events', [])
        if events:
            queue_db_operation(
                _process_event_batch_async,
                game.get('current_hand_id'),  # CHANGED: now current_hand_id
                events.copy()  # Copy to avoid race conditions
            )
            # Clear immediately - don't wait for database
            game['event_batch_events'] = []

def add_to_batch(session, event_type, event_data, **kwargs):
    """Add event to batch if in production"""
    if IS_PRODUCTION and 'game' in session:
        game = session['game']
        if 'event_batch_events' not in game:
            game['event_batch_events'] = []
        
        game['event_batch_events'].append({
            'timestamp': time.time(),
            'event_type': event_type,
            'event_data': event_data,
            **kwargs
        })

================================================================================

FILE: ./static/game.js
--------------------------------------------------------------------------------
let gameState = null;
let selectedCard = null;
let trickDisplayTimeout = null;
let lastHandNumber = null;

// Bidding confirmation variables
let selectedBid = null;
let confirmingBid = false;

// Scroll preservation for trick history
let trickHistoryScrollPosition = 0;

// Enhanced chat system variables
let chatOpen = false;
let unreadMessages = 0;
let chatInitialized = false;

// =============================================================================
// USER-ONLY CLAUDE CHAT SYSTEM
// =============================================================================

function toggleChat() {
    const chatWindow = document.getElementById('chatWindow');
    const chatIcon = document.getElementById('chatBubbleIcon');

    chatOpen = !chatOpen;

    if (chatOpen) {
        chatWindow.classList.add('open');
        chatIcon.style.display = 'none';

        // Show static welcome message only when chat first opens
        if (!chatInitialized) {
            addMessage("Ready when you are.", 'marta');
            chatInitialized = true;
        }

        // Clear unread messages when chat is opened
        unreadMessages = 0;
        updateChatBadge();
    } else {
        chatWindow.classList.remove('open');
        chatIcon.style.display = 'flex';
    }
}

function sendMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();

    if (!message) return;

    // Add player message
    addMessage(message, 'player');
    input.value = '';

    // Show Marta typing indicator
    showMartaTyping();

    // Get smart response from Marta with enhanced context - ONLY user-initiated
    fetch('/chat_response', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: message })
    })
        .then(response => response.json())
        .then(data => {
            if (data.response) {
                // Simulate realistic typing time based on response length
                const typingDelay = Math.min(Math.max(data.response.length * 50, 800), 3000);

                setTimeout(() => {
                    hideMartaTyping();
                    addMessage(data.response, 'marta');
                }, typingDelay);
            } else {
                hideMartaTyping();
                addMessage("...", 'marta'); // Mysterious fallback
            }
        })
        .catch(error => {
            console.error('Chat error:', error);
            hideMartaTyping();
            // Snarky fallback responses
            const fallbacks = [
                "Interesting move...",
                "We'll see about that.",
                "My cards are speaking to me.",
                "Poker face activated.",
                "You're full of surprises."
            ];
            const response = fallbacks[Math.floor(Math.random() * fallbacks.length)];
            setTimeout(() => {
                addMessage(response, 'marta');
            }, 800 + Math.random() * 1000);
        });
}

function showMartaTyping() {
    const messagesDiv = document.getElementById('chatMessages');

    // Remove any existing typing indicator
    const existingIndicator = document.getElementById('martaTypingIndicator');
    if (existingIndicator) {
        existingIndicator.remove();
    }

    // Create typing indicator
    const typingDiv = document.createElement('div');
    typingDiv.id = 'martaTypingIndicator';
    typingDiv.className = 'marta-message typing-indicator';
    typingDiv.innerHTML = `
        <div class="message-content">
            <div class="typing-dots">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
    `;

    messagesDiv.appendChild(typingDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function hideMartaTyping() {
    const typingIndicator = document.getElementById('martaTypingIndicator');
    if (typingIndicator) {
        typingIndicator.remove();
    }
}

function addMessage(text, sender) {
    const messagesDiv = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = sender === 'marta' ? 'marta-message' : 'player-message';

    // Create timestamp
    const now = new Date();
    const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

    // Create message structure with timestamp
    const messageContent = document.createElement('div');
    messageContent.className = 'message-content';
    messageContent.textContent = text;

    const timestamp = document.createElement('div');
    timestamp.className = 'message-timestamp';
    timestamp.textContent = timeString;

    messageDiv.appendChild(messageContent);
    messageDiv.appendChild(timestamp);

    messagesDiv.appendChild(messageDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;

    // If it's a Marta message and chat is closed, increment unread count
    if (sender === 'marta' && !chatOpen) {
        unreadMessages++;
        updateChatBadge();
    }
}

function updateChatBadge() {
    const chatIcon = document.getElementById('chatBubbleIcon');
    let badge = document.getElementById('chatBadge');

    if (unreadMessages > 0 && !chatOpen) {
        // Create badge if it doesn't exist
        if (!badge) {
            badge = document.createElement('div');
            badge.id = 'chatBadge';
            badge.className = 'chat-badge';
            chatIcon.appendChild(badge);
        }
        badge.textContent = unreadMessages > 9 ? '9+' : unreadMessages;
        badge.style.display = 'block';
    } else {
        // Hide badge when no unread messages or chat is open
        if (badge) {
            badge.style.display = 'none';
        }
    }
}

// =============================================================================
// MAIN GAME FUNCTIONS (unchanged core logic)
// =============================================================================

async function loadGameState() {
    try {
        const response = await fetch('/state');
        gameState = await response.json();
        updateUI();
    } catch (error) {
        console.error('Error loading game state:', error);
        showMessage('Error loading game', 'error');
    }
}

function updateUI() {
    if (!gameState) return;

    preserveTrickHistoryScroll();
    updateFloatingScores();
    updatePlayAreaVisibility();
    updateHandCount();
    updateGameOverState();
    updatePhaseVisibility();
    updateMessages();
    updatePlayArea();
    updatePlayerHand();
    updateComputerHand();
    updateActionButtons();
    updateBidButtons();
    updateComputerHandToggle();
    updateDiscards();
    handleResultsDisplay();
    handleTrickCompletion();

    // Track hand changes but don't auto-call Claude
    lastHandNumber = gameState.hand_number;
    restoreTrickHistoryScroll();
}

// =============================================================================
// UI UPDATE FUNCTIONS (unchanged from original)
// =============================================================================

function updateFloatingScores() {
    const gameScoreEl = document.getElementById('floatingGameScore');
    if (gameScoreEl) {
        document.getElementById('floatingPlayerScore').textContent = gameState.player_score;
        document.getElementById('floatingComputerScore').textContent = gameState.computer_score;
        document.getElementById('floatingHandNumber').textContent = gameState.hand_number;

        const playerParityText = `(${gameState.player_parity.toUpperCase()})`;
        const computerParityText = `(${gameState.computer_parity.toUpperCase()})`;
        document.getElementById('floatingPlayerParity').textContent = playerParityText;
        document.getElementById('floatingComputerParity').textContent = computerParityText;
    }

    const handScoreEl = document.getElementById('floatingHandScore');
    if (handScoreEl) {
        // Player side
        document.getElementById('floatingPlayerTricks').textContent = gameState.player_tricks;
        const playerBid = gameState.player_bid !== null ? gameState.player_bid : '-';
        const playerBlindText = gameState.blind_bid === gameState.player_bid ? 'B' : '';
        document.getElementById('floatingPlayerBid').textContent = `${playerBid}${playerBlindText}`;

        const playerBidEl = document.getElementById('floatingPlayerBid');
        if (playerBlindText) {
            playerBidEl.style.color = '#dc3545';
            playerBidEl.style.fontWeight = 'bold';
        } else {
            playerBidEl.style.color = '#333';
            playerBidEl.style.fontWeight = '600';
        }

        document.getElementById('floatingPlayerBags').textContent = gameState.player_bags || 0;

        // Computer side
        document.getElementById('floatingComputerTricks').textContent = gameState.computer_tricks;
        const computerBid = gameState.computer_bid !== null ? gameState.computer_bid : '-';
        const computerBlindText = gameState.computer_blind_bid === gameState.computer_bid ? 'B' : '';
        document.getElementById('floatingComputerBid').textContent = `${computerBid}${computerBlindText}`;

        const computerBidEl = document.getElementById('floatingComputerBid');
        const martaWentFirst = gameState.phase === 'bidding' &&
            gameState.computer_bid !== null &&
            gameState.player_bid === null;

        if (computerBlindText) {
            computerBidEl.style.color = '#dc3545';
            computerBidEl.style.fontWeight = 'bold';
            computerBidEl.style.backgroundColor = '';
            computerBidEl.style.border = '';
            computerBidEl.style.borderRadius = '';
            computerBidEl.style.padding = '';
        } else if (martaWentFirst) {
            computerBidEl.style.color = '#1976d2';
            computerBidEl.style.fontWeight = 'bold';
            computerBidEl.style.backgroundColor = '#e3f2fd';
            computerBidEl.style.border = '2px solid #1976d2';
            computerBidEl.style.borderRadius = '4px';
            computerBidEl.style.padding = '2px 4px';
        } else {
            computerBidEl.style.color = '#333';
            computerBidEl.style.fontWeight = '600';
            computerBidEl.style.backgroundColor = '';
            computerBidEl.style.border = '';
            computerBidEl.style.borderRadius = '';
            computerBidEl.style.padding = '';
        }

        document.getElementById('floatingComputerBags').textContent = gameState.computer_bags || 0;
        document.getElementById('floatingSpadesStatus').textContent = gameState.spades_broken ? 'Broken' : 'Not Broken';
    }
}

function updatePlayAreaVisibility() {
    const playArea = document.getElementById('playArea');
    if (!playArea) return;

    // Hide play area during these phases to save screen space
    const hiddenPhases = ['discard', 'bidding', 'blind_decision', 'blind_bidding'];

    if (hiddenPhases.includes(gameState.phase)) {
        playArea.classList.add('hidden-for-phase');
    } else {
        playArea.classList.remove('hidden-for-phase');
    }
}

function updateHandCount() {
    const playerHandCountEl = document.getElementById('playerHandCount');
    if (playerHandCountEl) {
        playerHandCountEl.textContent = `(${gameState.player_hand.length} cards)`;
    }
}

function updateGameOverState() {
    const gameOverEl = document.getElementById('gameOver');
    const winnerTextEl = document.getElementById('winnerText');

    if (gameState.game_over) {
        gameOverEl.style.display = 'block';
        winnerTextEl.textContent = gameState.message;
        hideInteractiveSections();

        // Show results for blind nil games
        if (gameState.hand_results && (gameState.message.includes('BLIND NIL') || gameState.message.includes('Blind Nil'))) {
            handleResultsDisplay();
        } else {
            document.getElementById('resultsSection').classList.remove('show');
        }
    } else {
        gameOverEl.style.display = 'none';
    }
}

function hideInteractiveSections() {
    document.getElementById('biddingSection').style.display = 'none';
    const blindDecisionSection = document.getElementById('blindDecisionSection');
    if (blindDecisionSection) blindDecisionSection.style.display = 'none';
    document.getElementById('discardBlindBiddingSection').style.display = 'none';
    document.getElementById('nextHandSection').style.display = 'none';
    document.getElementById('playerHandSection').style.display = 'none';
    document.getElementById('computerHandSection').style.display = 'none';
}

function updatePhaseVisibility() {
    if (gameState.game_over) return;

    const biddingSection = document.getElementById('biddingSection');
    const blindDecisionSection = document.getElementById('blindDecisionSection');
    const discardBlindSection = document.getElementById('discardBlindBiddingSection');

    // Hide all sections first
    biddingSection.style.display = 'none';
    if (blindDecisionSection) blindDecisionSection.style.display = 'none';
    discardBlindSection.style.display = 'none';

    if (gameState.phase === 'blind_decision') {
        if (blindDecisionSection) blindDecisionSection.style.display = 'block';
    } else if (gameState.phase === 'blind_bidding') {
        discardBlindSection.style.display = 'block';
    } else if (gameState.phase === 'bidding') {
        biddingSection.style.display = 'block';
        if (!biddingSection.classList.contains('active')) {
            biddingSection.classList.add('active');
            resetBiddingState();
        }
    } else {
        biddingSection.classList.remove('active');
    }
}

function updateMessages() {
    if (gameState.game_over) {
        showMessage(gameState.message, gameState.winner === 'player' ? 'success' : '');
        return;
    }

    let messageToShow = gameState.message;

    // Avoid showing detailed results if structured results are shown
    if (gameState.hand_over && gameState.hand_results) {
        messageToShow = `Hand #${gameState.hand_number} complete! Click 'Next Hand' to continue, or scroll for hand stats!`;
    }

    showMessage(messageToShow, messageToShow.includes('WIN') || messageToShow.includes('BLIND NIL SUCCESS') ? 'success' : '');
}

function updatePlayArea() {
    const trickDisplay = document.getElementById('trickDisplay');

    if (gameState.current_trick.length === 0) {
        trickDisplay.innerHTML = '<div style="color: #999; font-size: 14px;">Waiting for play...</div>';
    } else {
        let html = '<div class="trick-container">';

        const playerCard = gameState.current_trick.find(play => play.player === 'player');
        const computerCard = gameState.current_trick.find(play => play.player === 'computer');

        // Always show side by side - You left, Marta right
        if (playerCard) {
            const card = playerCard.card;
            const suitClass = getSuitClass(card.suit);
            html += `
                <div class="trick-card ${suitClass}">
                    <div class="player-name">You</div>
                    <div class="card-content">${card.rank}${card.suit}</div>
                </div>
            `;
        } else {
            html += '<div class="trick-card-placeholder"><div style="font-size: 10px; color: #999;">You</div></div>';
        }

        if (computerCard) {
            const card = computerCard.card;
            const suitClass = getSuitClass(card.suit);
            html += `
                <div class="trick-card ${suitClass}">
                    <div class="player-name">Marta</div>
                    <div class="card-content">${card.rank}${card.suit}</div>
                </div>
            `;
        } else {
            html += '<div class="trick-card-placeholder"><div style="font-size: 10px; color: #999;">Marta</div></div>';
        }

        html += '</div>';
        trickDisplay.innerHTML = html;
    }
}

function updatePlayerHand() {
    const handEl = document.getElementById('playerHand');
    const playerHandSection = document.getElementById('playerHandSection');

    // Hide entire hand section when hand is complete
    if (gameState.hand_over && gameState.player_hand.length === 0) {
        playerHandSection.style.display = 'none';
        return;
    } else {
        playerHandSection.style.display = 'block';
    }

    handEl.innerHTML = '';

    // Hide cards during blind decision or blind bidding phases
    if (gameState.phase === 'blind_decision' || gameState.phase === 'blind_bidding') {
        handEl.innerHTML = '<div style="text-align: center; color: #666; font-style: italic; padding: 20px; border: 2px dashed #ccc; border-radius: 8px;">Cards hidden during blind bidding decision!</div>';
        return;
    }

    gameState.player_hand.forEach((card, index) => {
        const cardEl = document.createElement('div');
        cardEl.className = `card ${getSuitClass(card.suit)}`;
        cardEl.textContent = `${card.rank}${card.suit}`;

        cardEl.onclick = () => selectCard(index);
        cardEl.ontouchstart = (e) => {
            e.preventDefault();
            selectCard(index);
        };

        if (selectedCard === index) {
            cardEl.classList.add('selected');
        }

        if (!canPlayCard(card, index)) {
            cardEl.classList.add('disabled');
        }

        handEl.appendChild(cardEl);
    });
}

function updateComputerHand() {
    const handEl = document.getElementById('computerHand');
    const computerHandSection = handEl.closest('.hand-section');

    // Hide entire computer hand section if debug mode is off
    if (!gameState.debug_mode) {
        computerHandSection.style.display = 'none';
        return;
    }

    computerHandSection.style.display = 'block';
    handEl.innerHTML = '';

    // Only show cards if debug mode is on AND show_computer_hand is true
    if (gameState.debug_mode && gameState.show_computer_hand && gameState.computer_hand) {
        gameState.computer_hand.forEach((card, index) => {
            const cardEl = document.createElement('div');
            cardEl.className = `card ${getSuitClass(card.suit)}`;
            cardEl.textContent = `${card.rank}${card.suit}`;
            cardEl.style.cursor = 'default';
            handEl.appendChild(cardEl);
        });
    } else {
        const cardCount = gameState.computer_hand_count || 0;
        for (let i = 0; i < cardCount; i++) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card';
            cardEl.style.background = '#666';
            cardEl.style.color = '#999';
            cardEl.textContent = '?';
            cardEl.style.cursor = 'default';
            handEl.appendChild(cardEl);
        }
    }
}

function updateActionButtons() {
    const actionButton = document.getElementById('actionButton');
    const nextHandSection = document.getElementById('nextHandSection');

    if (gameState.hand_over && !gameState.game_over) {
        actionButton.style.display = 'none';
        nextHandSection.style.display = 'block';
    } else {
        nextHandSection.style.display = 'none';

        if (gameState.phase === 'discard') {
            actionButton.textContent = 'Discard Selected';
            actionButton.onclick = discardCard;
            actionButton.style.display = 'inline-block';
        } else if (gameState.phase === 'playing') {
            actionButton.textContent = 'Play Selected';
            actionButton.onclick = playCard;
            actionButton.style.display = 'inline-block';
        } else {
            actionButton.style.display = 'none';
        }
    }

    if (selectedCard === null && actionButton.style.display !== 'none') {
        actionButton.disabled = true;
        actionButton.textContent = gameState.phase === 'discard' ? 'Select Card to Discard' : 'Select Card to Play';
    } else if (actionButton.style.display !== 'none') {
        actionButton.disabled = false;
        actionButton.textContent = gameState.phase === 'discard' ? 'Discard Selected' : 'Play Selected';
    }
}

function updateBidButtons() {
    if (gameState.phase !== 'bidding') return;

    const bidButtons = document.querySelectorAll('.bid-btn');
    const confirmButton = document.getElementById('confirmBidButton');
    const cancelButton = document.getElementById('cancelBidButton');

    if (confirmingBid && selectedBid !== null) {
        bidButtons.forEach(btn => {
            const bidValue = parseInt(btn.getAttribute('data-bid'));
            if (bidValue === selectedBid) {
                btn.classList.add('selected');
                btn.style.backgroundColor = '#28a745';
                btn.style.color = 'white';
                btn.style.border = '2px solid #1e7e34';
            } else {
                btn.classList.remove('selected');
                btn.style.backgroundColor = '';
                btn.style.color = '';
                btn.style.border = '';
                btn.style.opacity = '0.6';
            }
        });

        if (confirmButton) confirmButton.style.display = 'inline-block';
        if (cancelButton) cancelButton.style.display = 'inline-block';
    } else {
        bidButtons.forEach(btn => {
            btn.classList.remove('selected');
            btn.style.backgroundColor = '';
            btn.style.color = '';
            btn.style.border = '';
            btn.style.opacity = '';
        });

        if (confirmButton) confirmButton.style.display = 'none';
        if (cancelButton) cancelButton.style.display = 'none';
    }
}

function updateComputerHandToggle() {
    const toggleButton = document.getElementById('toggleComputerHand');
    if (toggleButton) {
        if (gameState.debug_mode) {
            toggleButton.style.display = 'inline-block';
            toggleButton.textContent = gameState.show_computer_hand ? 'Hide Cards' : 'Show Cards';
            toggleButton.style.background = '#6c757d';
        } else {
            toggleButton.style.display = 'none';
        }
    }
}

function updateDiscards() {
    const discardsSection = document.getElementById('discardsSection');

    if (gameState.hand_over && (gameState.player_discarded || gameState.computer_discarded)) {
        discardsSection.style.display = 'block';

        const playerDiscardEl = document.getElementById('playerDiscard');
        if (gameState.player_discarded) {
            const card = gameState.player_discarded;
            playerDiscardEl.innerHTML = `<div class="card ${getSuitClass(card.suit)}">${card.rank}${card.suit}</div>`;
        } else {
            playerDiscardEl.innerHTML = '<div class="card" style="opacity: 0.5;">None</div>';
        }

        const computerDiscardEl = document.getElementById('computerDiscard');
        if (gameState.computer_discarded) {
            const card = gameState.computer_discarded;
            computerDiscardEl.innerHTML = `<div class="card ${getSuitClass(card.suit)}">${card.rank}${card.suit}</div>`;
        } else {
            computerDiscardEl.innerHTML = '<div class="card" style="opacity: 0.5;">None</div>';
        }
    } else {
        discardsSection.style.display = 'none';
    }
}

function handleResultsDisplay() {
    const resultsSection = document.getElementById('resultsSection');
    const resultsContent = document.getElementById('resultsContent');

    if (gameState.hand_over && gameState.hand_results) {
        resultsSection.classList.add('show');
        resultsContent.innerHTML = formatCleanResults(gameState.hand_results);
    } else {
        resultsSection.classList.remove('show');
    }
}

function handleTrickCompletion() {
    // Check for completed trick that needs to be displayed
    if (gameState.current_trick && gameState.current_trick.length === 2 && !trickDisplayTimeout) {
        trickDisplayTimeout = setTimeout(async () => {
            try {
                await fetch('/clear_trick', { method: 'POST' });
                await loadGameState();
                trickDisplayTimeout = null;
            } catch (error) {
                console.error('Error clearing trick:', error);
                trickDisplayTimeout = null;
            }
        }, 1500);
    }
}

// =============================================================================
// HELPER FUNCTIONS (unchanged from original)
// =============================================================================

function getSuitClass(suit) {
    switch (suit) {
        case '‚ô†': return 'spade';
        case '‚ô•': return 'heart';
        case '‚ô¶': return 'diamond';
        case '‚ô£': return 'club';
        default: return '';
    }
}

function canPlayCard(card, index) {
    if (gameState.phase === 'discard') return true;
    if (gameState.turn !== 'player') return false;

    if (gameState.current_trick.length === 1) {
        const leadSuit = gameState.current_trick[0].card.suit;
        const hasSuit = gameState.player_hand.some(c => c.suit === leadSuit);
        if (hasSuit) {
            return card.suit === leadSuit;
        }
        return true;
    }

    if (gameState.current_trick.length === 0) {
        if (card.suit === '‚ô†' && !gameState.spades_broken) {
            return gameState.player_hand.every(c => c.suit === '‚ô†');
        }
        return true;
    }

    return false;
}

function selectCard(index) {
    if (!canPlayCard(gameState.player_hand[index], index)) {
        showMessage('Cannot play this card!', 'error');
        if (navigator.vibrate) {
            navigator.vibrate(100);
        }
        return;
    }

    selectedCard = index;
    updatePlayerHand();
    updateActionButtons();

    if (navigator.vibrate) {
        navigator.vibrate(50);
    }
}

function showMessage(text, type = '') {
    const messageEl = document.getElementById('message');
    if (messageEl) {
        messageEl.textContent = text;
        messageEl.className = 'message ' + type;
    }
}

function isSpecialCard(card) {
    return (card.rank === '7' && card.suit === '‚ô¶') || (card.rank === '10' && card.suit === '‚ô£');
}

// =============================================================================
// BIDDING FUNCTIONS (unchanged from original)
// =============================================================================

function selectBid(bidAmount) {
    if (confirmingBid) return;

    selectedBid = bidAmount;
    confirmingBid = true;

    updateBidButtons();

    const biddingPrompt = document.querySelector('.bidding-prompt');
    if (biddingPrompt) {
        const bidText = bidAmount === 0 ? 'NIL (0 tricks)' : `${bidAmount} tricks`;
        biddingPrompt.innerHTML = `You selected: <strong>${bidText}</strong>`;
    }

    if (navigator.vibrate) navigator.vibrate(50);
}

function confirmSelectedBid() {
    if (selectedBid === null || !confirmingBid) return;

    makeBid(selectedBid);
    resetBiddingState();
}

function cancelBidSelection() {
    resetBiddingState();

    const biddingPrompt = document.querySelector('.bidding-prompt');
    if (biddingPrompt) {
        biddingPrompt.innerHTML = `How many tricks will you take?`;
    }
}

function resetBiddingState() {
    selectedBid = null;
    confirmingBid = false;
    updateBidButtons();
}

// =============================================================================
// RESULTS FORMATTING (unchanged from original)
// =============================================================================

function formatCleanResults(results) {
    let html = '';

    // Parity Assignment
    html += `
        <div class="result-section">
            <div class="result-header">Players</div>
            <div class="result-content">You (${results.parity.player}) vs Marta (${results.parity.computer})</div>
        </div>
    `;

    // Discard Information
    if (results.discard_info && results.discard_info !== 'No discards to score') {
        html += `
            <div class="result-section">
                <div class="result-header">Discard Pile</div>
                <div class="result-content highlight">${results.discard_info}</div>
            </div>
        `;
    }

    // Scoring Breakdown
    html += `
        <div class="result-section">
            <div class="result-header">Scoring</div>
            <div class="result-content">${formatScoring(results.scoring)}</div>
        </div>
    `;

    // Trick History
    if (results.trick_history && results.trick_history.length > 0) {
        html += `
            <div class="result-section">
                <div class="result-header">Trick History</div>
                <div class="trick-history">
        `;

        results.trick_history.forEach(trick => {
            html += `
                <div class="trick-line">
                    <span class="trick-number">T${trick.number}:</span>
                    <span class="trick-cards">${trick.player_card} vs ${trick.computer_card}</span>
                    <span class="trick-winner">‚Üí ${trick.winner}</span>
                </div>
            `;
        });

        html += `
                </div>
            </div>
        `;
    }

    // Game Totals
    html += `
        <div class="result-section">
            <div class="result-header">Game Totals</div>
            <div class="result-content totals">
                <span>You: ${results.totals.player_score}</span>
                <span>Marta: ${results.totals.computer_score}</span>
            </div>
        </div>
    `;

    return html;
}

function formatScoring(scoringText) {
    const parts = scoringText.split(' | ');
    return parts.map(part => {
        part = part.trim();

        if (part.includes('BAG PENALTY')) {
            return `<div class="penalty-line">${part.replace('BAG PENALTY!', 'Bag Penalty')}</div>`;
        } else if (part.includes('NEGATIVE BAG BONUS')) {
            return `<div class="bonus-line">${part.replace('NEGATIVE BAG BONUS!', 'Bag Bonus')}</div>`;
        } else if (part.includes('special cards')) {
            return `<div class="special-line">${part}</div>`;
        } else if (part.includes('Bags:')) {
            return `<div class="bags-line">${part}</div>`;
        } else {
            return `<div class="score-line">${part}</div>`;
        }
    }).join('');
}

// =============================================================================
// SCROLL PRESERVATION (unchanged from original)
// =============================================================================

function preserveTrickHistoryScroll() {
    const trickHistory = document.querySelector('.trick-history');
    if (trickHistory) {
        trickHistoryScrollPosition = trickHistory.scrollTop;
    }
}

function restoreTrickHistoryScroll() {
    const trickHistory = document.querySelector('.trick-history');
    if (trickHistory && trickHistoryScrollPosition > 0) {
        setTimeout(() => {
            trickHistory.scrollTop = trickHistoryScrollPosition;
        }, 10);
    }
}

function resetTrickHistoryScroll() {
    trickHistoryScrollPosition = 0;
}

// =============================================================================
// API FUNCTIONS (unchanged from original)
// =============================================================================

async function chooseBlindNil() {
    try {
        const response = await fetch('/choose_blind_nil', { method: 'POST' });
        if (response.ok) {
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error choosing blind nil:', error);
        showMessage('Error choosing blind nil', 'error');
    }
}

async function chooseBlindBidding() {
    try {
        const response = await fetch('/choose_blind_bidding', { method: 'POST' });
        if (response.ok) {
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error choosing blind bidding:', error);
        showMessage('Error choosing blind bidding', 'error');
    }
}

async function chooseNormalBidding() {
    try {
        const response = await fetch('/choose_normal_bidding', { method: 'POST' });
        if (response.ok) {
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error choosing normal bidding:', error);
        showMessage('Error choosing normal bidding', 'error');
    }
}

async function makeBid(bidAmount) {
    try {
        const response = await fetch('/bid', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ bid: bidAmount })
        });

        if (response.ok) {
            await loadGameState();
            if (navigator.vibrate) navigator.vibrate(50);
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error making bid:', error);
        showMessage('Error making bid', 'error');
    }
}

async function makeBlindBid(bidAmount) {
    try {
        const response = await fetch('/blind_bid', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ bid: bidAmount })
        });

        if (response.ok) {
            await loadGameState();
            if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error making blind bid:', error);
        showMessage('Error making blind bid', 'error');
    }
}

async function discardCard() {
    if (selectedCard === null) {
        showMessage('Please select a card to discard', 'error');
        if (navigator.vibrate) navigator.vibrate(100);
        return;
    }

    try {
        const response = await fetch('/discard', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ index: selectedCard })
        });

        if (response.ok) {
            selectedCard = null;
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error discarding card:', error);
        showMessage('Error discarding card', 'error');
    }
}

async function playCard() {
    if (selectedCard === null) {
        showMessage('Please select a card to play', 'error');
        if (navigator.vibrate) navigator.vibrate(100);
        return;
    }

    try {
        const response = await fetch('/play', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ index: selectedCard })
        });

        if (response.ok) {
            selectedCard = null;
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error playing card:', error);
        showMessage('Error playing card', 'error');
    }
}

async function performAction() {
    if (gameState && gameState.phase === 'discard') {
        await discardCard();
    } else {
        await playCard();
    }
}

async function toggleComputerHand() {
    try {
        const response = await fetch('/toggle_computer_hand', { method: 'POST' });
        if (response.ok) {
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error toggling computer hand:', error);
        showMessage('Error toggling computer hand', 'error');
    }
}

async function nextHand() {
    try {
        const response = await fetch('/next_hand', { method: 'POST' });
        if (response.ok) {
            if (trickDisplayTimeout) {
                clearTimeout(trickDisplayTimeout);
                trickDisplayTimeout = null;
            }
            selectedCard = null;
            resetBiddingState();
            resetTrickHistoryScroll();
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error starting next hand:', error);
        showMessage('Error starting next hand', 'error');
    }
}

async function startNewGame() {
    try {
        if (trickDisplayTimeout) {
            clearTimeout(trickDisplayTimeout);
            trickDisplayTimeout = null;
        }

        await fetch('/new_game', { method: 'POST' });
        selectedCard = null;
        resetBiddingState();
        resetTrickHistoryScroll();

        // Reset chat state for new game
        chatInitialized = false;

        await loadGameState();
    } catch (error) {
        console.error('Error starting new game:', error);
        showMessage('Error starting new game', 'error');
    }
}

// =============================================================================
// INITIALIZATION AND EVENT HANDLERS
// =============================================================================

document.addEventListener('DOMContentLoaded', function () {
    loadGameState();

    // Handle Enter key in chat input
    const chatInput = document.getElementById('chatInput');
    if (chatInput) {
        chatInput.addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
    }

    // Prevent zoom on double-tap for mobile
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function (event) {
        const now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300) {
            event.preventDefault();
        }
        lastTouchEnd = now;
    }, false);
});

// Auto-refresh with mobile-friendly timing
setInterval(() => {
    if (gameState && !gameState.game_over && !trickDisplayTimeout) {
        loadGameState();
    }
}, 2500);

// Handle orientation changes on mobile
window.addEventListener('orientationchange', function () {
    setTimeout(() => {
        updatePlayArea();
    }, 100);
});

================================================================================

FILE: ./templates/stats.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Statistics - Two-Player Spades</title>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-F5VP0CXERK"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-F5VP0CXERK');
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            line-height: 1.6;
            padding: 20px 8px;
        }

        .container {
            max-width: 650px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .header {
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .header h1 {
            color: #4a5568;
            font-size: 24px;
            margin-bottom: 8px;
        }

        .header .subtitle {
            color: #666;
            font-size: 14px;
        }

        .back-button {
            position: fixed;
            top: 15px;
            left: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            z-index: 1000;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
        }

        .stats-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
        }

        .section-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 2px solid #dee2e6;
            text-align: center;
        }

        .no-stats {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #dee2e6;
        }

        /* Collapsible Sections */
        .collapsible-section {
            margin-bottom: 25px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #dee2e6;
            overflow: hidden;
        }

        .collapsible-toggle {
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #667eea;
            color: white;
            user-select: none;
            transition: background 0.3s ease;
        }

        .collapsible-toggle:hover {
            background: #5a67d8;
        }

        .collapsible-toggle-text {
            font-weight: 600;
            font-size: 16px;
        }

        .collapsible-chevron {
            font-size: 14px;
            transition: transform 0.3s ease;
        }

        .collapsible-section.expanded .collapsible-chevron {
            transform: rotate(180deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .collapsible-section.expanded .collapsible-content {
            max-height: 1200px;
        }

        .collapsible-inner {
            padding: 20px;
        }

        /* Win/Loss Explanation */
        .winloss-explanation {
            background: #e8f5e9;
            border: 2px solid #4caf50;
            border-radius: 10px;
            padding: 20px;
        }

        .winloss-explanation h3 {
            color: #2e7d32;
            margin-bottom: 12px;
            font-size: 18px;
        }

        .winloss-explanation p {
            margin-bottom: 10px;
            color: #333;
        }

        .winloss-explanation ul {
            margin: 10px 0 10px 20px;
        }

        .winloss-explanation li {
            margin-bottom: 6px;
            color: #333;
        }

        .winloss-explanation strong {
            color: #2e7d32;
        }

        .counts-section {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px;
            margin-top: 12px;
            border-radius: 4px;
        }

        .counts-section strong {
            color: #856404;
        }

        /* Legend Section */
        .legend-columns {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        .legend-column {
            background: white;
            border-radius: 8px;
            padding: 15px;
        }

        .legend-category {
            font-weight: bold;
            font-size: 14px;
            color: #333;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e9ecef;
        }

        .legend-item {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        .legend-item:hover {
            background: #e3f2fd;
        }

        .legend-label {
            font-weight: 600;
            color: #667eea;
            display: block;
            margin-bottom: 3px;
        }

        .legend-description {
            color: #666;
            font-size: 13px;
            display: block;
        }

        .legend-note {
            padding: 15px;
            background: white;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 13px;
            color: #666;
            border-left: 4px solid #667eea;
        }

        /* Responsive display logic */
        .desktop-table {
            display: none;
        }

        .mobile-cards {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .table-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 8px;
        }

        .stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }

        .stats-table th,
        .stats-table td {
            padding: 8px 4px;
            text-align: center;
            border-bottom: 1px solid #e9ecef;
        }

        .stats-table th {
            background: #667eea;
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
            font-size: 10px;
        }

        .stats-table tr:hover {
            background: #f8f9fa;
        }

        .player-card {
            background: white;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #dee2e6;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .player-card.rank-1 {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            border-color: #ffc107;
            box-shadow: 0 3px 8px rgba(255, 193, 7, 0.3);
        }

        .player-card.rank-2 {
            background: linear-gradient(135deg, #e2e3e5 0%, #f8f9fa 100%);
            border-color: #6c757d;
        }

        .player-card.rank-3 {
            background: linear-gradient(135deg, #f4cccc 0%, #fce4ec 100%);
            border-color: #e91e63;
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 8px;
        }

        .player-rank {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            min-width: 30px;
            text-align: center;
        }

        .player-name {
            font-weight: bold;
            font-size: 16px;
            flex-grow: 1;
            text-align: center;
        }

        .player-hands {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }

        .player-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 6px;
        }

        .stat-label {
            font-size: 11px;
            color: #666;
            font-weight: 600;
            margin-bottom: 2px;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 14px;
            font-weight: bold;
        }

        .stat-value.bid-stat {
            color: #6f42c1;
        }

        .stat-value.nil-stat {
            color: #dc3545;
        }

        .stat-value.bags-stat {
            color: #fd7e14;
        }

        .competitive-card {
            background: white;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #dee2e6;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .competitive-stats {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .stat-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 6px;
        }

        .winning-stats {
            background: rgba(40, 167, 69, 0.1);
            border: 1px solid rgba(40, 167, 69, 0.2);
        }

        .losing-stats {
            background: rgba(220, 53, 69, 0.1);
            border: 1px solid rgba(220, 53, 69, 0.2);
        }

        .win-loss-record {
            font-size: 14px;
            font-weight: bold;
            color: #667eea;
            text-align: center;
        }

        .win-loss-stat {
            color: #333;
            font-weight: bold;
        }

        .win-stat {
            color: #28a745;
            font-weight: 600;
        }

        .loss-stat {
            color: #dc3545;
            font-weight: 600;
        }

        /* Monthly Stats Styling */
        .monthly-container {
            margin-top: 15px;
        }

        .month-card {
            margin-bottom: 12px;
            padding: 12px;
            border-radius: 8px;
            background: white;
            border: 1px solid #dee2e6;
        }

        .month-card.current-month {
            background: linear-gradient(135deg, #e8f5e9 0%, #f1f8f4 100%);
            border: 2px solid #4caf50;
        }

        .month-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e9ecef;
        }

        .month-title {
            font-weight: bold;
            font-size: 15px;
            color: #333;
        }

        .current-badge {
            background: #4caf50;
            color: white;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
        }

        .month-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .table-note {
            font-size: 11px;
            color: #666;
            text-align: center;
            margin-top: 8px;
            font-style: italic;
        }

        /* Desktop layout */
        @media (min-width: 768px) {
            .container {
                padding: 25px;
                max-width: 900px;
            }

            .desktop-table {
                display: block;
            }

            .mobile-cards {
                display: none;
            }

            .player-stats {
                grid-template-columns: repeat(4, 1fr);
                gap: 10px;
            }

            .stat-item {
                padding: 10px;
            }

            .player-card {
                padding: 20px;
            }

            .player-header {
                margin-bottom: 15px;
            }

            .player-name {
                font-size: 18px;
            }

            .legend-columns {
                grid-template-columns: repeat(2, 1fr);
            }

            .competitive-stats {
                flex-direction: row;
                gap: 15px;
            }

            .stat-group {
                flex: 1;
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .month-stats {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 15px;
                margin: 0 4px;
            }

            .header h1 {
                font-size: 20px;
            }

            .back-button {
                top: 10px;
                left: 10px;
                padding: 8px 12px;
                font-size: 12px;
            }

            .player-stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }

            .stat-item {
                padding: 6px;
            }

            .stat-label {
                font-size: 10px;
            }

            .stat-value {
                font-size: 12px;
            }

            .winloss-explanation {
                padding: 15px;
            }

            .winloss-explanation h3 {
                font-size: 16px;
            }
        }
    </style>
</head>

<body>
    <a href="/" class="back-button">‚Üê Back to Game</a>

    <div class="container">
        <div class="header">
            <h1>Player Statistics</h1>
            <div class="subtitle">Competitive leaderboard and performance metrics</div>
        </div>

        <!-- Collapsible Win/Loss Explanation -->
        <div class="collapsible-section collapsed" id="winlossSection">
            <div class="collapsible-toggle" onclick="toggleSection('winlossSection')">
                <span class="collapsible-toggle-text">How Wins and Losses Work</span>
                <span class="collapsible-chevron" id="winlossChevron">‚ñº</span>
            </div>
            <div class="collapsible-content" id="winlossContent">
                <div class="collapsible-inner">
                    <div class="winloss-explanation">
                        <h3>How Wins and Losses Work</h3>
                        <p>You get a <strong>loss</strong> only when you finish a complete game and Marta beats you.
                            That's it.</p>

                        <p><strong>You lose when:</strong></p>
                        <ul>
                            <li>Someone reaches 300 points (or gets a 300+ point lead), AND Marta's score is higher than
                                yours at that moment</li>
                            <li>OR you attempt Blind Nil and fail (instant loss)</li>
                        </ul>

                        <p><strong>What DOESN'T count as a loss:</strong></p>
                        <ul>
                            <li>Quitting or abandoning a game mid-play</li>
                            <li>Losing individual hands during a game</li>
                            <li>Going negative in score</li>
                            <li>Failing your bids</li>
                        </ul>

                        <div class="counts-section">
                            <strong>The key point:</strong> Only completed games count toward wins and losses. If you
                            start a game but don't finish it, that's tracked separately as "abandoned" - it doesn't
                            count as either a win or a loss in your competitive stats.
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Collapsible Legend Section -->
        <div class="collapsible-section collapsed" id="legendSection">
            <div class="collapsible-toggle" onclick="toggleSection('legendSection')">
                <span class="collapsible-toggle-text">Statistics Guide</span>
                <span class="collapsible-chevron" id="legendChevron">‚ñº</span>
            </div>
            <div class="collapsible-content" id="legendContent">
                <div class="collapsible-inner">
                    <div class="legend-columns">
                        <div class="legend-column">
                            <div class="legend-category">Competitive Stats</div>
                            <div class="legend-item">
                                <span class="legend-label">Games Started:</span>
                                <span class="legend-description">Total games initiated (including abandoned)</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-label">Total Games:</span>
                                <span class="legend-description">Completed games only (excludes abandoned)</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-label">Win Rate:</span>
                                <span class="legend-description">Percentage of completed games won</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-label">Avg Winning Score:</span>
                                <span class="legend-description">Average final score when you win</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-label">Avg Losing Score:</span>
                                <span class="legend-description">Average final score when you lose</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-label">Avg Losing Margin:</span>
                                <span class="legend-description">Average points behind when losing</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-label">Games Abandoned:</span>
                                <span class="legend-description">Games started but not completed (not counted as wins or
                                    losses)</span>
                            </div>
                        </div>
                        <div class="legend-column">
                            <div class="legend-category">Detailed Hand Performance</div>
                            <div class="legend-item">
                                <span class="legend-label">Hands Played:</span>
                                <span class="legend-description">Individual hands with successful bids</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-label">Average Bids:</span>
                                <span class="legend-description">Mean tricks bid per hand by you and Marta</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-label">Nil Attempts:</span>
                                <span class="legend-description">Times you attempted 0-trick bids</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-label">Nil Success:</span>
                                <span class="legend-description">Successful nils out of total attempts (e.g.,
                                    5/11)</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-label">Total Bags:</span>
                                <span class="legend-description">Cumulative penalty points from overtricks</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-label">Average Bags:</span>
                                <span class="legend-description">Mean bags per hand (overtricks beyond bid)</span>
                            </div>
                        </div>
                    </div>
                    <div class="legend-note">
                        <strong>Note:</strong> Rankings are determined by sports-style competitive performance (win
                        rate, then total wins) rather than hand-level statistics. Competitive stats show game outcomes,
                        while detailed stats show bidding patterns and bag management across individual hands.
                    </div>
                </div>
            </div>
        </div>

        <!-- Competitive Leaderboard Section -->
        <div class="stats-section">
            <div class="section-title">Competitive Rankings</div>
            {% if competitive_leaders %}

            <!-- Competitive Table View (Desktop) -->
            <div class="table-container desktop-table">
                <table class="stats-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Player</th>
                            <th>W-L</th>
                            <th>Win %</th>
                            <th>Games</th>
                            <th>Avg Win Score</th>
                            <th>Avg Win Margin</th>
                            <th>Avg Loss Score</th>
                            <th>Avg Loss Margin</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for player in competitive_leaders %}
                        <tr
                            class="{% if loop.index == 1 %}rank-1{% elif loop.index == 2 %}rank-2{% elif loop.index == 3 %}rank-3{% endif %}">
                            <td>{{ loop.index }}</td>
                            <td><strong>{{ player.family_member }}</strong></td>
                            <td class="win-loss-stat">{{ player.total_wins|default(0) }}-{{
                                player.total_losses|default(0) }}</td>
                            <td class="percentage">{{ "%.1f"|format(player.win_rate_percent or 0) }}%</td>
                            <td>{{ player.total_games|default(0) }}</td>
                            <td class="win-stat">{{ "%.0f"|format(player.avg_winning_score) if player.avg_winning_score
                                else '-' }}</td>
                            <td class="win-stat">+{{ "%.0f"|format(player.avg_winning_margin) if
                                player.avg_winning_margin else '-' }}</td>
                            <td class="loss-stat">{{ "%.0f"|format(player.avg_losing_score) if player.avg_losing_score
                                else '-' }}</td>
                            <td class="loss-stat">-{{ "%.0f"|format(player.avg_losing_margin) if
                                player.avg_losing_margin else '-' }}</td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>

            <!-- Competitive Card View (Mobile) -->
            <div class="player-cards mobile-cards">
                {% for player in competitive_leaders %}
                <div
                    class="player-card competitive-card {% if loop.index == 1 %}rank-1{% elif loop.index == 2 %}rank-2{% elif loop.index == 3 %}rank-3{% endif %}">
                    <div class="player-header">
                        <div class="player-rank">#{{ loop.index }}</div>
                        <div class="player-name">{{ player.family_member }}</div>
                        <div class="win-loss-record">{{ player.total_wins|default(0) }}-{{
                            player.total_losses|default(0) }} ({{ "%.1f"|format(player.win_rate_percent or 0) }}%)</div>
                    </div>

                    <div class="competitive-stats">
                        <div class="stat-group winning-stats">
                            <div class="stat-item">
                                <div class="stat-label">Avg Winning Score</div>
                                <div class="stat-value win-stat">{{ "%.0f"|format(player.avg_winning_score) if
                                    player.avg_winning_score else 'No wins yet' }}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Avg Winning Margin</div>
                                <div class="stat-value win-stat">+{{ "%.0f"|format(player.avg_winning_margin) if
                                    player.avg_winning_margin else 'No wins yet' }}</div>
                            </div>
                        </div>

                        {% if player.avg_losing_score %}
                        <div class="stat-group losing-stats">
                            <div class="stat-item">
                                <div class="stat-label">Avg Losing Score</div>
                                <div class="stat-value loss-stat">{{ "%.0f"|format(player.avg_losing_score) }}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Avg Losing Margin</div>
                                <div class="stat-value loss-stat">-{{ "%.0f"|format(player.avg_losing_margin) }}</div>
                            </div>
                        </div>
                        {% endif %}
                    </div>
                </div>
                {% endfor %}
            </div>

            <div class="table-note">Ranked by win rate, then total wins</div>
            {% else %}
            <div class="no-stats">No competitive data available</div>
            {% endif %}
        </div>

        <!-- Detailed Performance Section -->
        <div class="stats-section">
            <div class="section-title">Detailed Hand Performance</div>
            {% if detailed_leaders and detailed_leaders|length > 0 %}

            <!-- Traditional Table View (Desktop) -->
            <div class="table-container desktop-table">
                <table class="stats-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Player</th>
                            <th>Hands</th>
                            <th>Avg Bid</th>
                            <th>Comp Bid</th>
                            <th>Nil Bids</th>
                            <th>Nil Success</th>
                            <th>Player Bags</th>
                            <th>Comp Bags</th>
                            <th>Avg P Bags</th>
                            <th>Avg C Bags</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for player in detailed_leaders %}
                        <tr
                            class="{% if loop.index == 1 %}rank-1{% elif loop.index == 2 %}rank-2{% elif loop.index == 3 %}rank-3{% endif %}">
                            <td>{{ loop.index }}</td>
                            <td><strong>{{ player.family_member }}</strong></td>
                            <td>{{ player.total_hands_with_bids|default(0) }}</td>
                            <td class="bid-stat">{{ "%.2f"|format(player.avg_player_bid or 0) }}</td>
                            <td class="bid-stat">{{ "%.2f"|format(player.avg_computer_bid or 0) }}</td>
                            <td class="nil-stat">{{ player.total_player_nil_bids|default(0) }}</td>
                            <td class="nil-stat">{{ player.total_player_nils_successful|default(0) }}/{{
                                player.total_player_nil_bids|default(0) }}</td>
                            <td class="bags-stat">{{ player.total_player_bags|default(0) }}</td>
                            <td class="bags-stat">{{ player.total_computer_bags|default(0) }}</td>
                            <td class="bags-stat">{{ "%.2f"|format(player.avg_player_bags or 0) }}</td>
                            <td class="bags-stat">{{ "%.2f"|format(player.avg_computer_bags or 0) }}</td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>

            <!-- Card View (Mobile) -->
            <div class="player-cards mobile-cards">
                {% for player in detailed_leaders %}
                <div
                    class="player-card {% if loop.index == 1 %}rank-1{% elif loop.index == 2 %}rank-2{% elif loop.index == 3 %}rank-3{% endif %}">
                    <div class="player-header">
                        <div class="player-rank">#{{ loop.index }}</div>
                        <div class="player-name">{{ player.family_member }}</div>
                        <div class="player-hands">{{ player.total_hands_with_bids|default(0) }} hands played</div>
                    </div>

                    <div class="player-stats">
                        <div class="stat-item">
                            <div class="stat-label">Avg Player Bid</div>
                            <div class="stat-value bid-stat">{{ "%.2f"|format(player.avg_player_bid or 0) }} tricks
                            </div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Avg Computer Bid</div>
                            <div class="stat-value bid-stat">{{ "%.2f"|format(player.avg_computer_bid or 0) }} tricks
                            </div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Total Nil Bids</div>
                            <div class="stat-value nil-stat">{{ player.total_player_nil_bids|default(0) }} attempts
                            </div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Nil Success Rate</div>
                            <div class="stat-value nil-stat">
                                {% if player.total_player_nil_bids and player.total_player_nil_bids > 0 %}
                                {{ player.total_player_nils_successful|default(0) }}/{{ player.total_player_nil_bids }}
                                ({{ "%.0f"|format((player.total_player_nils_successful|default(0) /
                                player.total_player_nil_bids) * 100) }}%)
                                {% else %}
                                No nils
                                {% endif %}
                            </div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Total Player Bags</div>
                            <div class="stat-value bags-stat">{{ player.total_player_bags|default(0) }} bags</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Total Computer Bags</div>
                            <div class="stat-value bags-stat">{{ player.total_computer_bags|default(0) }} bags</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Avg Player Bags</div>
                            <div class="stat-value bags-stat">{{ "%.2f"|format(player.avg_player_bags or 0) }} per hand
                            </div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Avg Computer Bags</div>
                            <div class="stat-value bags-stat">{{ "%.2f"|format(player.avg_computer_bags or 0) }} per
                                hand</div>
                        </div>
                    </div>
                </div>
                {% endfor %}
            </div>

            <div class="table-note">Hand-level bidding and bag statistics</div>
            {% else %}
            <div class="no-stats">No detailed performance data available</div>
            {% endif %}
        </div>

        <!-- Monthly Performance History Section -->
        <div class="stats-section">
            <div class="section-title">Monthly Performance History</div>
            {% if monthly_stats %}
            {% set sorted_members = monthly_stats.items() | list | sort(attribute='1.monthly.0.hands_played',
            reverse=True) %}
            {% for family_member, data in sorted_members %}
            <div class="player-card" style="margin-bottom: 20px;">
                <div class="player-header">
                    <div class="player-name">{{ family_member }}</div>
                </div>

                {% if data.monthly %}
                <div class="monthly-container">
                    {% for month_stat in data.monthly %}
                    <div class="month-card {% if loop.index == 1 %}current-month{% endif %}">
                        <div class="month-header">
                            <div class="month-title">{{ month_stat.month.strftime('%B %Y') }}</div>
                            {% if loop.index == 1 %}
                            <span class="current-badge">CURRENT</span>
                            {% endif %}
                        </div>

                        <div class="month-stats">
                            <div class="stat-item">
                                <div class="stat-label">Hands Played</div>
                                <div class="stat-value">{{ month_stat.hands_played }}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Hands Won</div>
                                <div class="stat-value win-stat">{{ month_stat.hands_won }}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Win Rate</div>
                                <div class="stat-value">
                                    {% if month_stat.hands_played > 0 %}
                                    {{ "%.1f"|format((month_stat.hands_won / month_stat.hands_played) * 100) }}%
                                    {% else %}
                                    0%
                                    {% endif %}
                                </div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Hands Lost</div>
                                <div class="stat-value loss-stat">{{ month_stat.hands_lost }}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Avg Player Score</div>
                                <div class="stat-value">{{ "%.0f"|format(month_stat.avg_player_score) }}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Avg Computer Score</div>
                                <div class="stat-value">{{ "%.0f"|format(month_stat.avg_computer_score) }}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Total Bags</div>
                                <div class="stat-value bags-stat">{{ month_stat.total_bags }}</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Avg Bags/Hand</div>
                                <div class="stat-value bags-stat">
                                    {% if month_stat.hands_played > 0 %}
                                    {{ "%.2f"|format(month_stat.total_bags / month_stat.hands_played) }}
                                    {% else %}
                                    0.00
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                    </div>
                    {% endfor %}
                </div>
                {% else %}
                <div class="no-stats">No monthly data available</div>
                {% endif %}
            </div>
            {% endfor %}
            {% else %}
            <div class="no-stats">No monthly statistics available</div>
            {% endif %}
        </div>
    </div>

    <script>
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const chevronId = sectionId.replace('Section', 'Chevron');
            const chevron = document.getElementById(chevronId);

            section.classList.toggle('expanded');

            if (section.classList.contains('expanded')) {
                chevron.textContent = '‚ñ≤';
            } else {
                chevron.textContent = '‚ñº';
            }
        }

        // Add smooth scrolling for mobile and touch interactions
        document.addEventListener('DOMContentLoaded', function () {
            // Add click handlers for cards on mobile for better interaction
            if (window.innerWidth <= 767) {
                document.querySelectorAll('.player-card').forEach(card => {
                    card.addEventListener('click', function () {
                        this.style.transform = 'scale(0.98)';
                        setTimeout(() => {
                            this.style.transform = '';
                        }, 150);
                    });
                });
            }

            // Add hover effects for legend items on desktop
            document.querySelectorAll('.legend-item').forEach(item => {
                item.addEventListener('mouseenter', function () {
                    this.style.backgroundColor = '#e3f2fd';
                });
                item.addEventListener('mouseleave', function () {
                    this.style.backgroundColor = 'white';
                });
            });
        });
    </script>
</body>

</html>

================================================================================

FILE: ./templates/index.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Two-Player Spades</title>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-F5VP0CXERK"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-F5VP0CXERK');
    </script>

    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">

    <!-- PWA and Mobile App Settings -->
    <link rel="manifest" href="/static/manifest.json">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Two-Man Spades">
</head>

<body>
    <!-- Floating score headers -->
    <div class="floating-game-score" id="floatingGameScore">
        <div class="game-score-item">
            <div class="game-score-label">You</div>
            <div class="game-score-parity" id="floatingPlayerParity">(EVEN)</div>
            <div class="game-score-value" id="floatingPlayerScore">0</div>
        </div>
        <div class="game-score-item">
            <div class="game-score-label">Hand #<span id="floatingHandNumber">1</span></div>
        </div>
        <div class="game-score-item">
            <div class="game-score-label">Marta</div>
            <div class="game-score-parity" id="floatingComputerParity">(ODD)</div>
            <div class="game-score-value" id="floatingComputerScore">0</div>
        </div>
    </div>

    <div class="floating-hand-score" id="floatingHandScore">
        <div class="hand-score-item">
            <div class="label">Tricks</div>
            <div class="value" id="floatingPlayerTricks">0</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bid</div>
            <div class="value" id="floatingPlayerBid">-</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bags</div>
            <div class="value" id="floatingPlayerBags">0</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Spades</div>
            <div class="value" id="floatingSpadesStatus">Not Broken</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bags</div>
            <div class="value" id="floatingComputerBags">0</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bid</div>
            <div class="value" id="floatingComputerBid">-</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Tricks</div>
            <div class="value" id="floatingComputerTricks">0</div>
        </div>
    </div>

    <div class="container">
        <!-- Top interactive area -->
        <div class="top-interactive-area">
            <!-- Play area (hidden during bidding/discard phases) -->
            <div class="play-area" id="playArea">
                <div id="trickDisplay"></div>
            </div>

            <!-- Game Over section -->
            <div class="game-over" id="gameOver" style="display: none;">
                <div class="winner-text" id="winnerText"></div>
                <button onclick="startNewGame()">Play Again</button>
            </div>

            <!-- Message area -->
            <div class="message" id="message">Loading game...</div>

            <!-- Next Hand Button -->
            <div class="next-hand-section" id="nextHandSection" style="display: none;">
                <button id="nextHandButton" onclick="nextHand()" class="next-hand-btn">Next Hand</button>
            </div>

            <!-- Discarded cards section -->
            <div class="discards-section" id="discardsSection" style="display: none;">
                <div class="hand-title">Discarded Cards</div>
                <div class="discards-content">
                    <div class="discard-item">
                        <div class="discard-label">You</div>
                        <div id="playerDiscard"></div>
                    </div>
                    <div class="discard-item">
                        <div class="discard-label">Marta</div>
                        <div id="computerDiscard"></div>
                    </div>
                </div>
            </div>

            <!-- Results Section -->
            <div class="results-section" id="resultsSection">
                <div class="results-header">Hand Summary</div>
                <div class="results-content" id="resultsContent"></div>
            </div>

            <!-- Blind Decision Section -->
            <div class="blind-decision-section" id="blindDecisionSection" style="display: none;">
                <div class="blind-header">
                    <h3>Blind Bidding Decision</h3>
                    <p>You're down by 100+ points. Choose your approach:</p>
                </div>
                <div class="decision-buttons"
                    style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 12px;">
                    <button onclick="chooseBlindNil()"
                        style="background: #8b0000; color: white; padding: 12px 6px; border-radius: 6px; font-weight: bold; border: none; cursor: pointer; font-size: 11px;">
                        Blind NIL<br><small>Win or Die!</small>
                    </button>
                    <button onclick="chooseBlindBidding()"
                        style="background: #d32f2f; color: white; padding: 12px 6px; border-radius: 6px; font-weight: bold; border: none; cursor: pointer; font-size: 11px;">
                        Go BLIND<br><small>5-10 tricks</small>
                    </button>
                    <button onclick="chooseNormalBidding()"
                        style="background: #1976d2; color: white; padding: 12px 6px; border-radius: 6px; font-weight: bold; border: none; cursor: pointer; font-size: 11px;">
                        Bid Normal<br><small>See cards</small>
                    </button>
                </div>
            </div>

            <!-- Blind Bidding Section -->
            <div class="blind-bidding-section" id="discardBlindBiddingSection" style="display: none;">
                <div class="blind-header">
                    <h3>Choose Your Blind Bid</h3>
                    <p>You chose to go blind! Pick your bid amount for <strong>DOUBLE</strong> points/penalties!</p>
                    <div class="blind-warning">
                        Must bid at least 5 tricks, get double rewards or double punishment!
                    </div>
                </div>
                <div class="bid-buttons blind-buttons">
                    <button onclick="makeBlindBid(5)" class="blind-bid-btn">BLIND 5</button>
                    <button onclick="makeBlindBid(6)" class="blind-bid-btn">BLIND 6</button>
                    <button onclick="makeBlindBid(7)" class="blind-bid-btn">BLIND 7</button>
                    <button onclick="makeBlindBid(8)" class="blind-bid-btn">BLIND 8</button>
                    <button onclick="makeBlindBid(9)" class="blind-bid-btn">BLIND 9</button>
                    <button onclick="makeBlindBid(10)" class="blind-bid-btn">BLIND 10</button>
                </div>
            </div>

            <!-- Regular Bidding Section -->
            <div class="bidding-section" id="biddingSection" style="display: none;">
                <div class="bidding-title">Make Your Bid</div>
                <div class="bidding-prompt">How many tricks will you take?</div>

                <!-- 6x2 bidding buttons -->
                <div class="bid-buttons">
                    <button onclick="selectBid(0)" class="bid-btn" data-bid="0">0<br><small>NIL</small></button>
                    <button onclick="selectBid(1)" class="bid-btn" data-bid="1">1</button>
                    <button onclick="selectBid(2)" class="bid-btn" data-bid="2">2</button>
                    <button onclick="selectBid(3)" class="bid-btn" data-bid="3">3</button>
                    <button onclick="selectBid(4)" class="bid-btn" data-bid="4">4</button>
                    <button onclick="selectBid(5)" class="bid-btn" data-bid="5">5</button>
                    <button onclick="selectBid(6)" class="bid-btn" data-bid="6">6</button>
                    <button onclick="selectBid(7)" class="bid-btn" data-bid="7">7</button>
                    <button onclick="selectBid(8)" class="bid-btn" data-bid="8">8</button>
                    <button onclick="selectBid(9)" class="bid-btn" data-bid="9">9</button>
                    <button onclick="selectBid(10)" class="bid-btn" data-bid="10">10</button>
                </div>

                <!-- Confirmation buttons -->
                <div class="bid-confirmation-buttons" style="margin-top: 12px; text-align: center;">
                    <button id="confirmBidButton" onclick="confirmSelectedBid()" style="display: none;">
                        Confirm Bid
                    </button>
                    <button id="cancelBidButton" onclick="cancelBidSelection()" style="display: none;">
                        Cancel
                    </button>
                </div>
            </div>
        </div>

        <!-- Hands area -->
        <div class="hands-area">
            <!-- Player hand section -->
            <div class="hand-section" id="playerHandSection">
                <div class="hand-title">
                    Your Hand
                    <span style="font-size: 12px; color: #666; font-weight: normal;" id="playerHandCount"></span>
                </div>
                <div class="cards" id="playerHand"></div>
                <div class="controls">
                    <button id="actionButton" onclick="performAction()">Select Card</button>
                </div>
            </div>

            <!-- Computer hand section -->
            <div class="hand-section" id="computerHandSection">
                <div class="hand-title">
                    Marta's Hand (hidden)
                    <button id="toggleComputerHand" onclick="toggleComputerHand()" style="display: none;">Show
                        Cards</button>
                </div>
                <div class="cards" id="computerHand"></div>
            </div>
        </div>

        <!-- Bottom navigation -->
        <!-- Bottom navigation -->
        <div class="bottom-section">
            <button class="bottom-new-game-btn" onclick="startNewGame()">New Game</button>
            <button class="bottom-rules-btn" onclick="window.open('/instructions', '_blank')">How to Play</button>
            <button class="bottom-rules-btn" onclick="window.open('/stats', '_blank')">Stats</button>
        </div>
    </div>

    <!-- Chat bubble icon (floating bottom right) -->
    <div class="chat-bubble-icon" id="chatBubbleIcon" onclick="toggleChat()">
        üí¨
        <div id="chatBadge" class="chat-badge" style="display: none;"></div>
    </div>

    <!-- Chat window (slides up from bottom) -->
    <div class="chat-window" id="chatWindow">
        <div class="chat-header">
            <span>Chat with Marta</span>
            <button class="chat-close" onclick="toggleChat()">√ó</button>
        </div>
        <div class="chat-messages" id="chatMessages">
            <div class="marta-message">Hey there! Ready to play some spades?</div>
        </div>
        <div class="chat-input-area">
            <input type="text" id="chatInput" placeholder="Type a message..." maxlength="100">
            <button onclick="sendMessage()">Send</button>
        </div>
    </div>

    <script src="{{ url_for('static', filename='game.js') }}"></script>
</body>

</html>

================================================================================

FILE: ./templates/instructions.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How to Play Two-Man Spades</title>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-F5VP0CXERK"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-F5VP0CXERK');
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #4a5568;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        h2 {
            color: #2d3748;
            margin-top: 30px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e2e8f0;
        }

        h3 {
            color: #4a5568;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .section {
            margin-bottom: 25px;
        }

        .highlight {
            background: #fff5f5;
            border-left: 4px solid #e53e3e;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .tip {
            background: #f0fff4;
            border-left: 4px solid #38a169;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .example {
            background: #ebf8ff;
            border: 1px solid #90cdf4;
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
        }

        .card-example {
            display: inline-block;
            background: white;
            border: 2px solid #333;
            border-radius: 6px;
            padding: 8px 12px;
            margin: 2px;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
        }

        .spade {
            color: #000;
        }

        .heart {
            color: #ff0000;
        }

        .diamond {
            color: #ff6200;
        }

        .club {
            color: #333;
        }

        .scoring-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        .scoring-table th,
        .scoring-table td {
            border: 1px solid #cbd5e0;
            padding: 12px;
            text-align: left;
        }

        .scoring-table th {
            background: #edf2f7;
            font-weight: bold;
        }

        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #4299e1;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(66, 153, 225, 0.3);
        }

        .back-button:hover {
            background: #3182ce;
            transform: translateY(-2px);
        }

        ol,
        ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
        }

        .ai-update {
            background: #f0f8ff;
            border-left: 4px solid #4299e1;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
    </style>
</head>

<body>
    <a href="/" class="back-button">‚Üê Back to Game</a>

    <div class="container">
        <h1>How to Play Two-Man Spades</h1>

        <div class="section">
            <div class="highlight">
                <h3>About This Game</h3>
                <p><strong>This is a custom variant developed over years of play.</strong> While based on traditional
                    Spades, this "Two-Man Spades" includes unique rules like parity scoring, special bag-reduction
                    cards, and blind bidding that don't exist in standard Spades. The game mechanics have been tested
                    and refined to be balanced and enjoyable, but this is essentially a "house rules" version.</p>
                <p><strong>Original invented rules:</strong> <a
                        href="https://docs.google.com/spreadsheets/d/1uxxzX09zhGm0b8R48Fi4vHvOEyrlp1AmVN-sN41voj0/edit?usp=sharing"
                        target="_blank" style="color: #3182ce;">Chicken-scratched 2manSpades rules...</a></p>
            </div>
        </div>

        <div class="section">
            <h2>Install as Mobile App</h2>
            <p>You can install Two-Man Spades as an app on your phone for a better full-screen experience:</p>

            <div class="tip">
                <strong>iPhone (Safari):</strong>
                <ol>
                    <li>Open the game in Safari</li>
                    <li>Tap the Share button (square with arrow up)</li>
                    <li>Scroll down and tap "Add to Home Screen"</li>
                    <li>Tap "Add" - the game icon will appear on your home screen</li>
                </ol>
            </div>

            <div class="tip">
                <strong>Android (Chrome):</strong>
                <ol>
                    <li>Open the game in Chrome</li>
                    <li>Tap the three dots menu (‚ãÆ)</li>
                    <li>Tap "Add to Home Screen" or "Install app"</li>
                    <li>Tap "Add" - the game icon will appear on your home screen</li>
                </ol>
            </div>

            <p>Once installed, the game will open in full-screen mode without browser bars, just like a native app!</p>
        </div>

        <div class="section">
            <h2>Overview</h2>
            <p>Two-Man Spades is a trick-taking card game where you compete against Marta (the computer) to reach 300
                points first. Each hand, you'll discard one card, bid on how many tricks you think you can win, then
                play cards strategically to meet your bid while preventing your opponent from meeting theirs.</p>
        </div>

        <div class="section">
            <h2>Game Setup</h2>
            <p>At the start of each game, players are randomly assigned <strong>parity</strong>:</p>
            <ul>
                <li><strong>Even Player:</strong> Gets bonus points when discard pile totals an even number</li>
                <li><strong>Odd Player:</strong> Gets bonus points when discard pile totals an odd number</li>
            </ul>
            <p>Each hand deals 11 cards to each player from a standard 52-card deck.</p>
        </div>

        <div class="section">
            <h2>Hand Flow</h2>

            <h3>1. Discard Phase</h3>
            <p>Each player selects one card to discard face-down. These cards are revealed simultaneously and:</p>
            <ul>
                <li>Their face values are added together (Ace=1, Jack=11, Queen=12, King=13)</li>
                <li>The player whose parity matches the total gets bonus points</li>
                <li>If both cards are the same suit OR same rank, points are doubled</li>
                <li>Base bonus is 10 points (20 for doubles)</li>
            </ul>

            <div class="example">
                <strong>Example:</strong> You discard 7‚ô£ (value 7), Marta discards 6‚ô• (value 6).
                Total = 13 (odd). If you're the odd player, you get 10 points.
                If both cards were hearts, you'd get 20 points instead.
            </div>

            <h3>2. Bidding Phase</h3>
            <p>Players bid how many tricks (out of 10) they expect to win with their remaining cards.</p>

            <div class="highlight">
                <strong>Special Bidding Rules:</strong>
                <ul>
                    <li><strong>NIL (0 bid):</strong> If you take exactly 0 tricks, get +200 points. If you take any
                        tricks, lose -200 points and gain that many bags.</li>
                    <li><strong>Blind Bidding:</strong> When down by 100+ points, you can bid "blind" (5-10 tricks) for
                        double points/penalties before seeing your cards!</li>
                    <li><strong>Blind NIL:</strong> When down by 100+ points, you can attempt Blind NIL - if successful,
                        you instantly win the entire game. If you fail by taking any tricks, you instantly lose the
                        game!</li>
                </ul>
            </div>

            <h3>3. Playing Tricks</h3>
            <p>Players take turns playing cards. The person with the odd parity leads the first trick of each hand.</p>

            <h4>Playing Rules:</h4>
            <ul>
                <li><strong>Follow Suit:</strong> You must play the same suit as the lead card if you have it</li>
                <li><strong>Trump:</strong> Spades (‚ô†) always beat other suits</li>
                <li><strong>Spades Broken:</strong> You can't lead spades until they've been "broken" by someone playing
                    a spade on a different suit</li>
                <li><strong>Highest Card Wins:</strong> Within the same suit, higher cards win (Ace is highest)</li>
            </ul>

            <div class="example">
                <strong>Trick Example:</strong> Marta leads <span class="card-example heart">Q‚ô•</span>.
                You have <span class="card-example heart">7‚ô•</span> and <span class="card-example spade">3‚ô†</span>.
                You must play the 7‚ô• (follow suit). Marta wins with the higher heart.
            </div>
        </div>

        <div class="section">
            <h2>Scoring System</h2>

            <h3>Basic Scoring</h3>
            <table class="scoring-table">
                <tr>
                    <th>Situation</th>
                    <th>Points Earned</th>
                </tr>
                <tr>
                    <td>Made your bid exactly</td>
                    <td>Bid √ó 10 points</td>
                </tr>
                <tr>
                    <td>Made more than your bid</td>
                    <td>Bid √ó 10 points + 1 bag per extra trick</td>
                </tr>
                <tr>
                    <td>Failed to make your bid</td>
                    <td>Lose Bid √ó 10 points</td>
                </tr>
                <tr>
                    <td>NIL success (0 bid, 0 tricks)</td>
                    <td>+200 points</td>
                </tr>
                <tr>
                    <td>NIL failure (0 bid, any tricks)</td>
                    <td>-200 points + tricks as bags</td>
                </tr>
                <tr>
                    <td>Blind bid success</td>
                    <td>Double normal points</td>
                </tr>
                <tr>
                    <td>Blind bid failure</td>
                    <td>Double normal penalty</td>
                </tr>
                <tr>
                    <td>Blind NIL success</td>
                    <td>INSTANT GAME WIN</td>
                </tr>
                <tr>
                    <td>Blind NIL failure</td>
                    <td>INSTANT GAME LOSS</td>
                </tr>
            </table>

            <h3>Bags System</h3>
            <p>Bags are penalties for taking more tricks than you bid:</p>
            <ul>
                <li>Every 7 bags = -100 points penalty</li>
                <li>Negative bags give bonuses: every 5 negative bags = +100 points</li>
                <li>Your score display shows base score + bags in the ones digit</li>
            </ul>

            <div class="tip">
                <strong>Bag Strategy:</strong> Sometimes it's better to let your opponent win a trick rather than
                accumulate bags, especially when you're close to a 7-bag penalty! Watch out - Marta now actively tries
                to force you to take unwanted tricks when you have 5+ bags.
            </div>
        </div>

        <div class="section">
            <h2>Special Cards</h2>
            <p>Two cards provide bag reduction when won in tricks or discard piles:</p>
            <ul>
                <li><span class="card-example diamond">7‚ô¶</span> Seven of Diamonds: -2 bags</li>
                <li><span class="card-example club">10‚ô£</span> Ten of Clubs: -1 bag</li>
            </ul>
            <p>The player who wins the trick or discard pile containing these cards gets the bag reduction.</p>
        </div>
        <h2>Winning the Game</h2>
        <p>The game ends when:</p>
        <ul>
            <li><strong>Target Reached:</strong> Someone reaches 300 points (higher display score wins)</li>
            <li><strong>Mercy Rule:</strong> Someone leads by 300+ points (automatic win)</li>
            <li><strong>Blind NIL:</strong> Successful Blind NIL instantly wins the game, failed Blind NIL instantly
                loses</li>
        </ul>

        <div class="highlight">
            <h3>Denial Rule - Keep the Game Alive!</h3>
            <p><strong>Critical mechanic:</strong> When someone would reach 300+ points from winning the discard pile,
                but they're currently losing the game, the DENIAL RULE automatically activates! Instead of gaining those
                discard points, their opponent LOSES those points instead. This keeps close games alive for another hand
                instead of ending on a lucky discard!</p>

            <div class="example">
                <strong>Example:</strong> You're at 295, Marta's at 305. You win the discard pile for 10 points, which
                would give you 305 and end the game. But since you're behind, DENIAL activates - Marta loses 10 points
                instead (drops to 295), and the game continues 295 to 295 for another hand!
            </div>
        </div>

        <h3>Game End Logic (When Either Player Hits 300+)</h3>
        <p><strong>Simple Rule: Higher display score ALWAYS wins, regardless of how you got there, and negative bags are
                BAD in this situation.</strong></p>

        <div class="example">
            <strong>Scenarios when both players are over 300:</strong>
            <ul>
                <li><strong>Player A:</strong> 302 display, <strong>Player B:</strong> 301 display ‚Üí <strong>Player A
                        wins</strong></li>
                <li><strong>Player A:</strong> 315 display, <strong>Player B:</strong> 320 display ‚Üí <strong>Player B
                        wins</strong></li>
                <li><strong>Player A:</strong> 300 display, <strong>Player B:</strong> 306 display ‚Üí <strong>Player B
                        wins</strong></li>
            </ul>
        </div>

        <h3>Tie-Breaking (Only When Display Scores Are Exactly Equal)</h3>
        <p>Display score ties are extremely rare and only occur when negative bags are involved:</p>
        <ol>
            <li>Player with higher base score wins</li>
            <li>If base scores are tied, player with more bags wins (more bags is better)</li>
            <li>If everything is exactly equal, the game ends in a tie</li>
        </ol>

        <div class="example">
            <strong>Realistic Tie-Breaking Examples:</strong>
            <ul>
                <li><strong>300 with -1 bags</strong> vs <strong>300 with 0 bags</strong> ‚Üí <strong>Player with 0 bags
                        wins</strong> (0 > -1)</li>
                <li><strong>300 with -4 bags</strong> vs <strong>300 with -2 bags</strong> ‚Üí <strong>Player with -2 bags
                        wins</strong> (-2 > -4)</li>
                <li><strong>310 with -3 bags</strong> vs <strong>320 with -4 bags </strong> ‚Üí <strong>Player with 320
                        and -4 bags wins</strong> (-1 < -4)</li>
            </ul>
            <p><strong>Why ties are rare:</strong> Positive bags always change the display score, so ties only happen
                when at least one player has negative bags.</p>
        </div>

        <h3>Bag System Limits</h3>
        <div class="tip">
            <strong>Automatic Bag Management:</strong>
            <ul>
                <li><strong>Maximum bags:</strong> 6 (7+ bags triggers -100 point penalty and resets to remainder)</li>
                <li><strong>Minimum bags:</strong> -4 (-5+ negative bags triggers +100 point bonus and resets to
                    remainder)</li>
                <li><strong>Tie-breaking hierarchy:</strong> 6 > 5 > 4 > 3 > 2 > 1 > 0 > -1 > -2 > -3 > -4</li>
                <li><strong>Key insight:</strong> Negative bags hurt in tie-breaking but never reduce your display score
                </li>
            </ul>
        </div>

        <h3>Why This System Works</h3>
        <div class="section">
            <p><strong>Strategic Depth:</strong> The display score system creates interesting decisions - negative bags
                don't hurt your visible score, but they're devastating in close games. Meanwhile, positive bags boost
                your display but can trigger painful penalties at 7+ bags. The denial rule prevents lucky discard wins
                when you're behind, ensuring skill matters more than chance in final moments.</p>

            <p><strong>Bottom Line:</strong> Highest display score wins when anyone hits 300+. Ties are nearly
                impossible due to the bag system, but when they occur, more bags (including negative bags closer to
                zero) provide the advantage.</p>
        </div>

        <div class="section">
            <h2>Advanced Features</h2>

            <h3>Auto-Resolution</h3>
            <p>When the outcome of remaining tricks is mathematically certain (like when one player has only spades and
                the other has none), the game automatically plays out the remaining cards to save time while showing you
                exactly what happened.</p>

            <h3>Smart AI Opponent</h3>
            <p>Marta now uses advanced strategy when she's made her bid - she'll lead high cards to force you into
                difficult decisions when you have lots of bags, and she'll strategically dump her dangerous high cards
                on tricks she's going to lose anyway. This creates realistic pressure similar to playing against an
                experienced human opponent.</p>
        </div>

        <div class="section">
            <h2>Strategy Tips</h2>

            <div class="tip">
                <strong>Bidding Strategy:</strong>
                <ul>
                    <li>Count your high spades - they're usually reliable tricks</li>
                    <li>Look for aces in other suits, but remember they can be trumped</li>
                    <li>Consider void suits (suits you have no cards in) - you can trump them</li>
                    <li>Be conservative when you have many bags</li>
                    <li>Consider Blind NIL as a last resort when far behind - it's all or nothing!</li>
                </ul>
            </div>

            <div class="tip">
                <strong>Playing Strategy:</strong>
                <ul>
                    <li>Try to force out high cards early when you're leading</li>
                    <li>Count cards to know what's still in play</li>
                    <li>Use your spades wisely - they're powerful but limited</li>
                    <li>Sometimes let your opponent win tricks if you've already made your bid</li>
                    <li>Be extra careful about bag management - Marta actively exploits your weaknesses!</li>
                </ul>
            </div>

            <div class="tip">
                <strong>Discard Strategy:</strong>
                <ul>
                    <li>Discard singleton special cards (7‚ô¶ or 10‚ô£) to create voids</li>
                    <li>Create voids in suits where you have spades to trump</li>
                    <li>Consider the parity game - sometimes a strategic discard can win you bonus points</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>Interface Guide</h2>
            <ul>
                <li><strong>Top Headers:</strong> Show game scores, hand number, and current hand status</li>
                <li><strong>Play Area:</strong> Shows current trick being played</li>
                <li><strong>Your Cards:</strong> Click to select, then use the action button</li>
                <li><strong>Results Summary:</strong> After each hand, review detailed scoring and trick history</li>
                <li><strong>Auto-Resolution Message:</strong> When remaining tricks are predetermined, you'll see
                    exactly what happened</li>
            </ul>
        </div>

        <div class="section">
            <div class="ai-update">
                <h3>Recent Improvement</h3>
                <p><strong>Marta now plays much smarter!</strong> When she's made her bid, she actively forces you into
                    difficult decisions by leading high cards when you have 5+ bags, and strategically dumps her highest
                    losing cards (like playing Queen instead of 2 when you lead King) to avoid getting stuck with
                    dangerous high cards later. This creates realistic pressure and makes bag management much more
                    challenging.</p>
            </div>
        </div>

        <div class="section">
            <p style="text-align: center; margin-top: 40px; font-style: italic; color: #666;">
                Two-Man Spades combines strategy, memory, and calculated risk-taking. Each hand is a puzzle to solve,
                and each game tells a story. With Marta's improved AI, you'll face tougher decisions and more realistic
                pressure. Good luck, and may your bids be true!
            </p>
        </div>
    </div>
</body>

</html>

================================================================================

