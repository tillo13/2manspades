Number of files: 12
Number of directories: 5

Directory structure:
.
static
templates
utilities
utilities/__pycache__

List of file paths by type:

CSS Files (1):
  ./static/style.css

HTML Files (2):
  ./templates/index.html
  ./templates/instructions.html

JS Files (1):
  ./static/game.js

JSON Files (1):
  ./static/manifest.json

PY Files (7):
  ./app.py
  ./gather_pythons.py
  ./gcloud_deploy.py
  ./utilities/computer_logic.py
  ./utilities/custom_rules.py
  ./utilities/gameplay_logic.py
  ./utilities/logging_utils.py

================================================================================
FILE CONTENTS
================================================================================

FILE: ./gcloud_deploy.py
--------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
Deployment script for Two Man Spades
This script manages deployment to Google App Engine for twomanspades project.
"""

import subprocess
import json
import time
import os
import sys
import random
import string

# Configuration - TWO MAN SPADES PROJECT SPECIFIC
EXPECTED_PROJECT_ID = "twomanspades"  # Critical: This must match your project
SERVICE_NAME = "default"
VERSION_MAX = 15  # Keep 15 versions to minimize storage costs

def print_separator():
    """Print a visual separator in console output."""
    print("\n" + "="*70 + "\n")

def check_gcloud_project():
    """Verify we're using the correct GCP project - CRITICAL SAFEGUARD."""
    print_separator()
    print("ðŸ”’ VERIFYING GOOGLE CLOUD PROJECT CONFIGURATION...")
    print(f"Expected project: {EXPECTED_PROJECT_ID}")
    
    try:
        current_project = subprocess.run(
            ["gcloud", "config", "get-value", "project"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True
        ).stdout.decode().strip()
        
        print(f"Current project:  {current_project}")
        
        if current_project != EXPECTED_PROJECT_ID:
            print(f"âŒ ERROR: Current gcloud project is '{current_project}' but expected '{EXPECTED_PROJECT_ID}'")
            print(f"ðŸ”„ Attempting to switch to the correct project...")
            
            # Try to use an existing configuration first
            try:
                configs_result = subprocess.run(
                    ["gcloud", "config", "configurations", "list", "--format=value(name)"],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True
                )
                configs = configs_result.stdout.decode().strip().split('\n')
                
                if "twomanspades-config" in configs:
                    print("ðŸ“‹ Using existing twomanspades-config configuration")
                    subprocess.run(
                        ["gcloud", "config", "configurations", "activate", "twomanspades-config"],
                        check=True
                    )
                else:
                    print("âš™ï¸  Setting project directly")
                    subprocess.run(
                        ["gcloud", "config", "set", "project", EXPECTED_PROJECT_ID],
                        check=True
                    )
            except subprocess.CalledProcessError:
                print("âš™ï¸  Setting project directly")
                subprocess.run(
                    ["gcloud", "config", "set", "project", EXPECTED_PROJECT_ID],
                    check=True
                )
            
            # CRITICAL: Verify the switch was successful
            current_project = subprocess.run(
                ["gcloud", "config", "get-value", "project"],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True
            ).stdout.decode().strip()
            
            if current_project != EXPECTED_PROJECT_ID:
                print(f"âŒ CRITICAL ERROR: Failed to switch to project {EXPECTED_PROJECT_ID}")
                print("ðŸ›‘ DEPLOYMENT ABORTED to prevent deploying to wrong project!")
                print("")
                print("Please manually set the project with one of these commands:")
                print(f"  gcloud config configurations activate twomanspades-config")
                print(f"  gcloud config set project {EXPECTED_PROJECT_ID}")
                print("")
                print("Then re-run this script.")
                sys.exit(1)
            else:
                print(f"âœ… Successfully switched to project {EXPECTED_PROJECT_ID}")
        else:
            print(f"âœ… Project verification passed - correctly configured for {EXPECTED_PROJECT_ID}")
    
    except subprocess.CalledProcessError as e:
        print(f"âŒ Error checking Google Cloud project: {e}")
        print("ðŸ›‘ DEPLOYMENT ABORTED")
        sys.exit(1)

# Function to get versions of a service
def get_versions(service_name):
    """Fetch the current versions of the App Engine service."""
    print(f"ðŸ“‹ Checking existing versions for service: {service_name}...")
    try:
        result = subprocess.run(
            ["gcloud", "app", "versions", "list", 
             "--service", service_name, 
             "--format", "json", 
             "--project", EXPECTED_PROJECT_ID],  # Always specify project
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        versions = json.loads(result.stdout)
        versions.sort(key=lambda x: x["version"]["createTime"], reverse=True)
        return versions
    except subprocess.CalledProcessError as e:
        if "Service not found" in e.stderr.decode() or f"Service [{service_name}] not found" in e.stderr.decode():
            print(f"ðŸ“ Service {service_name} not found. It will be created during deployment.")
            return []
        else:
            print(f"âŒ Error getting versions: {e.stderr.decode()}")
            raise e

# Function to delete versions
def delete_old_versions(service_name, versions_to_delete):
    """Delete older versions to maintain version limit."""
    if not versions_to_delete:
        return
    
    print(f"ðŸ§¹ Cleaning up old versions. Deleting {len(versions_to_delete)} older versions...")
    
    for v in versions_to_delete:
        version_id = v["id"]
        print(f"  - Deleting version {service_name}-{version_id}")
        subprocess.run(
            ["gcloud", "app", "versions", "delete", version_id, 
             "--service", service_name, 
             "--quiet", 
             "--project", EXPECTED_PROJECT_ID],  # Always specify project
            check=True)
    
    print("âœ… Cleanup complete.")

# Function to get changed files using git diff
def get_changed_files(directory):
    """Get list of new or modified files using git diff"""
    try:
        result = subprocess.run(
            ["git", "-C", directory, "diff", "--name-only", "HEAD^", "HEAD"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        files = result.stdout.decode().strip().split("\n")
        return [os.path.join(directory, f) for f in files if f]
    except subprocess.CalledProcessError:
        print("â„¹ï¸  Error determining changed files (this is normal for first deployment).")
        return []

def list_files_to_upload():
    """List files that will be uploaded to Google Cloud Storage."""
    print("ðŸ“ Files to be uploaded:")
    
    # Fallback: manually parse .gcloudignore and list files
    ignored_patterns = set()
    if os.path.exists('.gcloudignore'):
        with open('.gcloudignore', 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    ignored_patterns.add(line.rstrip('/'))
    
    # Default ignore patterns if no .gcloudignore exists
    if not ignored_patterns:
        ignored_patterns = {
            '.git',  'logging', '__pycache__', '*.pyc', '.env', 'venv*', 
            '.vscode', '.idea', '*.md', 'gather_pythons.py', 
            '*_project_structure.txt'
        }
    
    # Walk directory and respect .gcloudignore patterns
    files_to_upload = []
    for root, dirs, files in os.walk('.'):
        # Remove ignored directories from dirs to prevent walking into them
        dirs[:] = [d for d in dirs if not any(
            d == pattern or f"{root}/{d}".startswith(f"./{pattern}")
            for pattern in ignored_patterns
        )]
        
        for file in files:
            rel_path = os.path.relpath(os.path.join(root, file), '.')
            # Skip if file matches any ignore pattern
            if not any(
                rel_path.startswith(pattern) or file.endswith(pattern.lstrip('*'))
                for pattern in ignored_patterns
            ):
                files_to_upload.append(rel_path)
    
    # Print the files
    for file in sorted(files_to_upload):
        print(f"  - {file}")
    
    print(f"\nðŸ“Š Total files to upload: {len(files_to_upload)}")

# Function to generate a valid version name
def generate_version_name():
    random_string = ''.join(random.choices(string.ascii_lowercase + string.digits, k=10))
    return f"version-{random_string}"

# Function to deploy the services
def deploy_service(service_name, yaml_path):
    """Deploy the application to Google App Engine."""
    start_time = time.time()
    current_directory = os.path.dirname(os.path.abspath(yaml_path))
    
    print_separator()
    print(f"ðŸš€ DEPLOYING TWO MAN SPADES TO GOOGLE APP ENGINE")
    print(f"ðŸ“¦ Project: {EXPECTED_PROJECT_ID}")
    print(f"âš™ï¸  Service: {service_name}")
    print(f"ðŸ“‚ Deploy from: {current_directory}")
    print(f"ðŸ“„ Using config: {yaml_path}")
    print_separator()
    
    # List changed files
    print("ðŸ“ Listing new or modified files to be uploaded:")
    changed_files = get_changed_files(current_directory)
    if changed_files:
        for file_path in changed_files:
            print(f"  ðŸ“„ Changed file: {file_path}")
    else:
        print("  â„¹ï¸  No new or modified files detected (normal for first deployment).")
    
    # Check the current versions
    try:
        versions = get_versions(service_name)
        print(f"âœ… {len(versions)} versions retrieved successfully.")
    except subprocess.CalledProcessError as e:
        versions = []
        print(f"âš ï¸  Failed to get versions. Error: {e}")
        print(f"ðŸ“ First deployment for service {service_name}. Proceeding with deployment.")
    
    print(f"ðŸ“Š You currently have {len(versions)} versions for {service_name}.")
    if versions:
        print(f"ðŸ“‹ The latest version is {versions[0]['id']} for {service_name}.")
    
    if len(versions) > VERSION_MAX:
        print(f"ðŸ§¹ More than {VERSION_MAX} versions exist for {service_name}.")
    
    # Show files that will be uploaded
    print_separator()
    list_files_to_upload()
    
    # Deploy new version
    print_separator()
    version_name = generate_version_name()
    print(f"ðŸš€ Deploying new version: {version_name}")
    try:
        result = subprocess.run([
            "gcloud", "app", "deploy", yaml_path, 
            "--quiet", 
            "--project", EXPECTED_PROJECT_ID,  # Always specify project
            "--version", version_name
        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        print("âœ… Deployment successful!")
    except subprocess.CalledProcessError as e:
        print(f"âŒ Failed to deploy new version. Error: {e.stderr.decode()}")
        return  # Early exit if deployment fails
    
    # Delete old versions if needed
    if len(versions) > VERSION_MAX:
        print_separator()
        try:
            # Get fresh list of versions after deployment
            updated_versions = get_versions(service_name)
            versions_to_delete = updated_versions[VERSION_MAX:]
            delete_old_versions(service_name, versions_to_delete)
        except subprocess.CalledProcessError as e:
            print(f"âš ï¸  Failed to delete old versions. Error: {e.stderr.decode()}")

    # Calculate and display execution time
    end_time = time.time()
    execution_time = end_time - start_time
    
    # Display the target URL
    print_separator()
    print(f"â±ï¸  Deployment completed in {execution_time:.2f} seconds.")
    print(f"ðŸŒ Your Two Man Spades game is now live at:")
    print(f"  - https://{EXPECTED_PROJECT_ID}.appspot.com")
    print_separator()

# Main deployment function
def main_deploy():
    # CRITICAL: Verify project before doing ANYTHING
    check_gcloud_project()
    
    # Deploy the service
    deploy_service(SERVICE_NAME, 'app.yaml')
    
    # Automatically tail logs
    print(f"\nðŸ“‹ Tailing logs... (Press Ctrl+C to stop)")
    try:
        subprocess.run([
            "gcloud", "app", "logs", "tail",
            "--service", SERVICE_NAME,
            "--project", EXPECTED_PROJECT_ID  # Always specify project
        ])
    except KeyboardInterrupt:
        print("\n\nâ¹ï¸  Stopped tailing logs.")
        print(f"ðŸ“‹ You can view logs anytime with: gcloud app logs tail -s {SERVICE_NAME} --project {EXPECTED_PROJECT_ID}")

if __name__ == "__main__":
    print(f"ðŸ”’ You have chosen to keep {VERSION_MAX} versions of your app.")
    main_deploy()

================================================================================

FILE: ./app.py
--------------------------------------------------------------------------------
from flask import Flask, render_template, request, session, jsonify
import sys
import os
import time

# Add utilities directory to path if running as main
if __name__ == '__main__':
    sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from utilities.gameplay_logic import (
    init_game,
    init_new_hand,
    sort_hand,
    is_valid_play,
    determine_trick_winner,
    computer_follow,
    computer_lead,
    check_game_over
)

from utilities.custom_rules import (
    assign_even_odd_at_game_start,
    calculate_discard_score_with_winner,
    calculate_hand_scores_with_bags,
    get_player_names_with_parity,
    check_special_cards_in_discard,
    reduce_bags_safely,
    check_blind_bidding_eligibility
)

from utilities.computer_logic import (
    computer_bidding_brain,
    computer_discard_strategy
)

# Import logging utilities
from utilities.logging_utils import (
    initialize_game_logging_with_client,
    log_action,
    log_game_event,
    log_ai_decision,
    track_session_client,
    finalize_game_logging, get_client_ip
)

app = Flask(__name__)
app.secret_key = 'your-secret-key-change-this'

DEBUG_MODE = False  # Set to False to hide Marta's cards completely

session_tracker = {}

def get_display_score(base_score, bags):
    """Convert base score and bags to display score (bags in ones column)"""
    # Only modify ones digit if bags are non-negative
    if bags >= 0:
        # For negative scores, we need to handle the ones digit differently
        if base_score < 0:
            # Remove ones digit from negative number and subtract bags
            tens_and_higher = (base_score // 10) * 10
            return tens_and_higher - bags
        else:
            # For positive scores, remove ones digit and add bags
            tens_and_higher = (base_score // 10) * 10
            return tens_and_higher + bags
    else:
        # If bags are negative, show base score unchanged
        return base_score

def get_base_score_from_display(display_score, bags):
    """Convert display score back to base score (removing bags from ones column)"""
    return display_score - bags

def track_request_session():
    """Track client info for this request session"""
    if 'game' in session:
        return track_session_client(session, request)
    return None

def resolve_trick_with_delay(game, session_obj=None):
    """Resolve trick and set it up to be displayed for 3 seconds with logging"""
    if len(game['current_trick']) != 2:
        return
    
    winner = determine_trick_winner(game['current_trick'])
    
    # SAVE TRICK TO HISTORY BEFORE PROCESSING
    trick_number = len(game.get('trick_history', [])) + 1
    player_card = next((play['card'] for play in game['current_trick'] if play['player'] == 'player'), None)
    computer_card = next((play['card'] for play in game['current_trick'] if play['player'] == 'computer'), None)
    
    game.setdefault('trick_history', []).append({
        'number': trick_number,
        'player_card': player_card,
        'computer_card': computer_card,
        'winner': winner
    })
    
    # LOG TRICK COMPLETION TO CONSOLE AND JSON
    p_text = f"{player_card['rank']}{player_card['suit']}" if player_card else "?"
    c_text = f"{computer_card['rank']}{computer_card['suit']}" if computer_card else "?"
    winner_name = "You" if winner == 'player' else "Marta"
    print(f"TRICK {trick_number}: {p_text} vs {c_text} -> {winner_name} wins")
    
    # LOG TO JSON AS WELL
    if session_obj:
        log_game_event(
            event_type='trick_completed',
            event_data={
                'trick_number': trick_number,
                'player_card': p_text,
                'computer_card': c_text,
                'winner': winner,
                'winner_name': winner_name
            },
            session=session_obj
        )
    
    # Check for special cards in the trick and apply bag reduction IMMEDIATELY
    from utilities.custom_rules import check_special_cards_in_trick, reduce_bags_safely
    special_result = check_special_cards_in_trick(game['current_trick'], winner)
    
    if special_result['bag_reduction'] > 0:
        if winner == 'player':
            current_bags = game.get('player_bags', 0)
            game['player_bags'] = reduce_bags_safely(current_bags, special_result['bag_reduction'])
            game['player_trick_special_cards'] = game.get('player_trick_special_cards', 0) + special_result['bag_reduction']
        else:
            current_bags = game.get('computer_bags', 0)
            game['computer_bags'] = reduce_bags_safely(current_bags, special_result['bag_reduction'])
            game['computer_trick_special_cards'] = game.get('computer_trick_special_cards', 0) + special_result['bag_reduction']
        
        game['special_card_message'] = special_result['explanation']
        
        # Log special card effect
        if session_obj:
            log_game_event(
                event_type='special_card_effect',
                event_data={
                    'trick_number': trick_number,
                    'bag_reduction': special_result['bag_reduction'],
                    'beneficiary': winner_name,
                    'explanation': special_result['explanation']
                },
                session=session_obj
            )
    
    # Award trick
    if winner == 'player':
        game['player_tricks'] += 1
        base_message = 'You won the trick!'
    else:
        game['computer_tricks'] += 1
        base_message = 'Marta won the trick!'
    
    # Add special card info to message if present
    if special_result['explanation']:
        game['message'] = f"{base_message} {special_result['explanation']}."
    else:
        game['message'] = f"{base_message}."
    
    # Mark trick as completed but don't clear yet
    game['trick_completed'] = True
    game['trick_winner'] = winner

def computer_follow_with_logging(game, session_obj=None):
    """Computer plays a card when following with logging"""
    hand = game['computer_hand']
    trick = game['current_trick']
    
    if not trick or not hand:
        return
    
    # Use enhanced following strategy from computer_logic
    from utilities.computer_logic import computer_follow_strategy
    chosen_idx = computer_follow_strategy(hand, trick, game)
    
    if chosen_idx is None:
        # Fallback to original simple logic if strategy fails
        lead_card = trick[0]['card']
        lead_suit = lead_card['suit']
        lead_value = lead_card['value']
        
        # Find valid plays
        same_suit = [(i, c) for i, c in enumerate(hand) if c['suit'] == lead_suit]
        spades = [(i, c) for i, c in enumerate(hand) if c['suit'] == 'â™ ']
        
        if same_suit:
            # Must follow suit - try to win with lowest winning card
            winners = [(i, c) for i, c in same_suit if c['value'] > lead_value]
            if winners:
                chosen_idx = min(winners, key=lambda x: x[1]['value'])[0]
            else:
                # Can't win, play lowest
                chosen_idx = min(same_suit, key=lambda x: x[1]['value'])[0]
        elif lead_suit != 'â™ ' and spades:
            # Can't follow suit, can trump with spade
            chosen_idx = min(spades, key=lambda x: x[1]['value'])[0]
        else:
            # Can't follow or trump, discard lowest
            all_cards = [(i, c) for i, c in enumerate(hand)]
            chosen_idx = min(all_cards, key=lambda x: x[1]['value'])[0]
    
    # Play the chosen card
    card = hand.pop(chosen_idx)
    game['current_trick'].append({'player': 'computer', 'card': card})
    
    # LOG COMPUTER'S RESPONSE
    if session_obj:
        lead_card = game['current_trick'][0]['card'] if len(game['current_trick']) >= 1 else None
        log_action(
            action_type='card_play',
            player='computer',
            action_data={
                'card_played': f"{card['rank']}{card['suit']}",
                'trick_position': 2,
                'following_suit': card['suit'] == lead_card['suit'] if lead_card else False
            },
            session=session_obj,
            additional_context={
                'responding_to': f"{lead_card['rank']}{lead_card['suit']}" if lead_card else None,
                'hand_size_after': len(hand)
            }
        )
    
    if card['suit'] == 'â™ ':
        game['spades_broken'] = True
        if session_obj:
            log_game_event('spades_broken', {'broken_by': 'computer', 'card': f"{card['rank']}{card['suit']}"}, session_obj)

def computer_lead_with_logging(game, session_obj=None):
    """Computer plays a card when leading with logging"""
    hand = game['computer_hand']
    
    if not hand:
        return
    
    # Use enhanced leading strategy from computer_logic
    from utilities.computer_logic import computer_lead_strategy
    chosen_idx = computer_lead_strategy(hand, game['spades_broken'])
    
    if chosen_idx is None:
        # Fallback to original simple logic if strategy fails
        valid = []
        for i, card in enumerate(hand):
            if card['suit'] != 'â™ ' or game['spades_broken'] or all(c['suit'] == 'â™ ' for c in hand):
                valid.append((i, card))
        
        if valid:
            chosen = min(valid, key=lambda x: (x[1]['suit'] == 'â™ ', x[1]['value']))
            chosen_idx = chosen[0]
        else:
            return
    
    # Play the chosen card
    card = hand.pop(chosen_idx)
    game['current_trick'] = [{'player': 'computer', 'card': card}]
    game['trick_leader'] = 'computer'
    
    # LOG COMPUTER'S LEAD
    if session_obj:
        log_action(
            action_type='card_play',
            player='computer',
            action_data={
                'card_played': f"{card['rank']}{card['suit']}",
                'trick_position': 1,
                'leading': True
            },
            session=session_obj,
            additional_context={
                'hand_size_after': len(hand)
            }
        )
    
    if card['suit'] == 'â™ ':
        game['spades_broken'] = True
        if session_obj:
            log_game_event('spades_broken', {'broken_by': 'computer', 'card': f"{card['rank']}{card['suit']}"}, session_obj)


# In the index() route:
@app.route('/')
def index():
    # Check if we should force a new game (via query parameter)
    force_new = request.args.get('new', '').lower() == 'true'
    
    # Only start fresh if explicitly requested or no existing game
    if force_new or 'game' not in session:
        session.clear()
        player_parity, computer_parity, first_player = assign_even_odd_at_game_start()
        game = init_game(player_parity, computer_parity, first_player)
        # Initialize logging with client tracking
        game = initialize_game_logging_with_client(game, request)
        session['game'] = game
    
    # If there's an existing game, preserve it
    return render_template('index.html')

@app.route('/new_game', methods=['POST'])
def new_game():
    # Track client session
    client_info = track_request_session()
    
    # Finalize previous game logging if exists
    if 'game' in session:
        finalize_game_logging(session['game'])
    
    # Assign new even/odd and first player for the new game
    player_parity, computer_parity, first_player = assign_even_odd_at_game_start()
    game = init_game(player_parity, computer_parity, first_player)
    # Initialize logging with client tracking - this starts a new JSON file
    game = initialize_game_logging_with_client(game, request)
    session['game'] = game
    
    # Log the new game start
    log_game_event(
        event_type='new_game_started',
        event_data={
            'player_parity': player_parity,
            'computer_parity': computer_parity,
            'first_leader': first_player
        },
        session=session
    )
    
    return jsonify({'success': True})


@app.route('/state')
def get_state():
    global session_tracker
    client_ip = get_client_ip(request)
    game_phase = session.get('game', {}).get('phase', 'no-game')
    
    # Store both timestamp and phase for each IP
    session_tracker[client_ip] = {'last_seen': time.time(), 'phase': game_phase}
    
    # Clean up and show all active users with phases
    cutoff = time.time() - 300
    active = {ip: data for ip, data in session_tracker.items() if data['last_seen'] > cutoff}
    session_tracker = active
    
    total_ips = len(active)
    print(f"ACTIVE: {total_ips} users | Current: {client_ip} ({game_phase})")
    if total_ips > 1:
        for ip, data in active.items():
            print(f"  {ip}: {data['phase']}")
    
    if 'game' not in session:
        player_parity, computer_parity, first_player = assign_even_odd_at_game_start()
        session['game'] = init_game(player_parity, computer_parity, first_player)
    
    game = session['game']
    
    # Get player names with parity
    player_name, computer_name = get_player_names_with_parity(
        game.get('player_parity', 'even'),
        game.get('computer_parity', 'odd')
    )
    
    # Only show discard_bonus_explanation if hand is over
    show_discard_explanation = game.get('hand_over', False)
    discard_explanation = game.get('discard_bonus_explanation') if show_discard_explanation else None
    
    # Calculate display scores (base score + bags)
    player_base_score = game.get('player_score', 0)
    computer_base_score = game.get('computer_score', 0)
    player_bags = game.get('player_bags', 0)
    computer_bags = game.get('computer_bags', 0)
    
    player_display_score = get_display_score(player_base_score, player_bags)
    computer_display_score = get_display_score(computer_base_score, computer_bags)
    
    # Prepare safe state
    safe_state = {
        'player_hand': game['player_hand'],
        # Only include computer_hand_count if DEBUG_MODE is True
        'computer_hand_count': len(game['computer_hand']) if DEBUG_MODE else 0,
        'current_trick': game['current_trick'],
        'player_tricks': game['player_tricks'],
        'computer_tricks': game['computer_tricks'],
        'spades_broken': game['spades_broken'],
        'phase': game['phase'],
        'turn': game['turn'],
        'trick_leader': game.get('trick_leader'),
        'hand_over': game.get('hand_over', False),
        'game_over': game.get('game_over', False),
        'winner': game['winner'],
        'message': game['message'],
        'player_discarded': game.get('player_discarded'),
        'computer_discarded': game.get('computer_discarded'),
        'show_computer_hand': game.get('show_computer_hand', False) and DEBUG_MODE,
        'player_bid': game.get('player_bid'),
        'computer_bid': game.get('computer_bid'),
        'total_tricks': game.get('total_tricks', 10),
        'player_score': player_display_score,  # Display score with bags
        'computer_score': computer_display_score,  # Display score with bags
        'player_base_score': player_base_score,  # Keep base score for internal calculations
        'computer_base_score': computer_base_score,  # Keep base score for internal calculations
        'player_bags': player_bags,
        'computer_bags': computer_bags,
        'hand_number': game.get('hand_number', 1),
        'target_score': game.get('target_score', 300),
        'player_parity': game.get('player_parity', 'even'),
        'computer_parity': game.get('computer_parity', 'odd'),
        'player_name': player_name,
        'computer_name': computer_name,
        'discard_bonus_explanation': discard_explanation,
        'blind_bidding_available': game.get('blind_bidding_available', False),
        'blind_bid': game.get('blind_bid'),
        'computer_blind_bid': game.get('computer_blind_bid'),
        'debug_mode': DEBUG_MODE,
        'hand_results': game.get('hand_results')
    }
    
    # Include computer hand only if debug mode is on AND showing
    if DEBUG_MODE and game.get('show_computer_hand', False):
        safe_state['computer_hand'] = game['computer_hand']
    
    return jsonify(safe_state)

# Modify the toggle_computer_hand route:
@app.route('/toggle_computer_hand', methods=['POST'])
def toggle_computer_hand():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    # Don't allow toggling if debug mode is off
    if not DEBUG_MODE:
        return jsonify({'error': 'Debug mode disabled'}), 400
    
    game = session['game']
    game['show_computer_hand'] = not game.get('show_computer_hand', False)
    session.modified = True
    
    return jsonify({'success': True, 'showing': game['show_computer_hand']})


@app.route('/choose_blind_bidding', methods=['POST'])
def choose_blind_bidding():
    """Handle when player chooses to go blind"""
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    # Track client session
    client_info = track_request_session()
    
    game = session['game']
    
    if game['phase'] != 'blind_decision':
        return jsonify({'error': 'Not in blind decision phase'}), 400
    
    # Log the decision
    log_action(
        action_type='blind_decision',
        player='player',
        action_data={
            'chose_blind': True,
            'chose_normal': False
        },
        session=session,
        request=request
    )
    
    # Move to blind bidding phase
    game['phase'] = 'blind_bidding'
    game['message'] = 'Choose your blind bid amount (5-10 tricks). Double points if you make it, double penalty if you fail!'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/choose_normal_bidding', methods=['POST'])
def choose_normal_bidding():
    """Handle when player chooses normal bidding"""
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    # Track client session
    client_info = track_request_session()
    
    game = session['game']
    
    if game['phase'] != 'blind_decision':
        return jsonify({'error': 'Not in blind decision phase'}), 400
    
    # Log the decision
    log_action(
        action_type='blind_decision',
        player='player',
        action_data={
            'chose_blind': False,
            'chose_normal': True
        },
        session=session,
        request=request
    )
    
    # Move to discard phase
    game['phase'] = 'discard'
    game['message'] = 'You chose normal bidding. Select a card to discard.'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/blind_bid', methods=['POST'])
def make_blind_bid():
    """Handle blind bidding during blind_bidding phase"""
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    # Track client session
    client_info = track_request_session()
    
    game = session['game']
    data = request.get_json()
    bid = data.get('bid')
    
    if game['phase'] != 'blind_bidding':
        return jsonify({'error': 'Can only make blind bid during blind bidding phase'}), 400
    
    if bid < 5 or bid > 10:
        return jsonify({'error': 'Blind bid must be between 5 and 10'}), 400
    
    # Log blind bid
    log_action(
        action_type='blind_bid',
        player='player',
        action_data={
            'bid_amount': bid
        },
        session=session,
        request=request
    )
    
    # Set blind bid and regular bid
    game['blind_bid'] = bid
    game['player_bid'] = bid
    
    # Computer makes its decision (might also go blind if eligible)
    computer_bid, computer_is_blind = computer_bidding_brain(
        game['computer_hand'], 
        bid, 
        game
    )
    game['computer_bid'] = computer_bid
    
    if computer_is_blind:
        game['computer_blind_bid'] = computer_bid
        log_action(
            action_type='blind_bid',
            player='computer',
            action_data={
                'bid_amount': computer_bid,
                'in_response_to_player': True
            },
            session=session
        )
    else:
        log_action(
            action_type='regular_bid',
            player='computer',
            action_data={
                'bid_amount': computer_bid,
                'in_response_to_blind': True
            },
            session=session
        )
    
    # After blind bid, go to discard phase
    game['phase'] = 'discard'
    computer_blind_text = " (BLIND)" if computer_is_blind else ""
    game['message'] = f'You bid BLIND {bid}! Marta bid {computer_bid}{computer_blind_text}. Select a card to discard.'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/choose_blind_nil', methods=['POST'])
def choose_blind_nil():
    """Handle blind nil - win or lose the entire game"""
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    game = session['game']
    if game['phase'] != 'blind_decision':
        return jsonify({'error': 'Not in blind decision phase'}), 400
    
    # Set blind nil
    game['blind_bid'] = 0
    game['player_bid'] = 0
    game['blind_nil'] = True
    
    # Computer bids normally (no blind nil for Marta)
    computer_bid, computer_is_blind = computer_bidding_brain(
        game['computer_hand'], 0, game
    )
    game['computer_bid'] = computer_bid
    if computer_is_blind:
        game['computer_blind_bid'] = computer_bid
    
    # Go to discard
    game['phase'] = 'discard'
    computer_text = f" Marta bid {computer_bid}{'(BLIND)' if computer_is_blind else ''}."
    game['message'] = f'BLIND NIL chosen! Win instantly with 0 tricks or lose the game!{computer_text} Select a card to discard.'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/bid', methods=['POST'])
def make_bid():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    # Track client session
    client_info = track_request_session()
    
    game = session['game']
    data = request.get_json()
    bid = data.get('bid')
    
    if game['phase'] != 'bidding':
        return jsonify({'error': 'Not in bidding phase'}), 400
    
    if bid < 0 or bid > 10:
        return jsonify({'error': 'Bid must be between 0 and 10'}), 400
    
    # Log player bid
    log_action(
        action_type='regular_bid',
        player='player',
        action_data={
            'bid_amount': bid,
            'is_nil': bid == 0
        },
        session=session,
        request=request
    )
    
    # Player makes regular bid
    game['player_bid'] = bid
    
    # Check if computer has already bid (Marta-first scenario)
    if game.get('computer_bid') is None:
        # Normal scenario - computer bids after player
        computer_bid, computer_is_blind = computer_bidding_brain(
            game['computer_hand'], 
            bid, 
            game
        )
        game['computer_bid'] = computer_bid
        
        # Handle computer blind bid
        if computer_is_blind:
            game['computer_blind_bid'] = computer_bid
            log_action(
                action_type='blind_bid',
                player='computer',
                action_data={
                    'bid_amount': computer_bid,
                    'in_response_to_player': True
                },
                session=session
            )
        else:
            log_action(
                action_type='regular_bid',
                player='computer',
                action_data={
                    'bid_amount': computer_bid,
                    'in_response_to_player': True
                },
                session=session
            )
            
        computer_blind_text = " (BLIND)" if computer_is_blind else ""
        player_blind_text = " (BLIND)" if game.get('blind_bid') == bid else ""
        
        message_base = f'You bid {bid}{player_blind_text}, Marta bid {computer_bid}{computer_blind_text}.'
    else:
        # Marta already bid - just acknowledge You bid
        computer_blind_text = " (BLIND)" if game.get('computer_blind_bid') else ""
        player_blind_text = " (BLIND)" if game.get('blind_bid') == bid else ""
        
        message_base = f'You bid {bid}{player_blind_text}, Marta bid {game["computer_bid"]}{computer_blind_text}.'
    
    # Start playing phase with the designated first leader
    game['phase'] = 'playing'
    first_leader = game.get('first_leader', 'player')
    game['turn'] = first_leader
    game['trick_leader'] = first_leader
    
    # Log bidding phase complete
    log_game_event(
        event_type='bidding_complete',
        event_data={
            'player_bid': game['player_bid'],
            'computer_bid': game['computer_bid'],
            'first_leader': first_leader,
            'player_blind': game.get('blind_bid') is not None,
            'computer_blind': game.get('computer_blind_bid') is not None
        },
        session=session
    )
    
    # Create message indicating who leads first
    if first_leader == 'player':
        game['message'] = f'{message_base} Your turn to lead the first trick.'
    else:
        game['message'] = f'{message_base} Marta leads the first trick.'
        # If computer leads, make the computer play immediately
        computer_lead_with_logging(game, session)
        game['turn'] = 'player'
        game['message'] = f'{message_base} Marta led. Your turn to follow.'
    
    session.modified = True
    return jsonify({'success': True})


@app.route('/discard', methods=['POST'])
def discard_card():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    # Track client session
    client_info = track_request_session()
    
    game = session['game']
    data = request.get_json()
    card_index = data.get('index')
    
    if game['phase'] != 'discard':
        return jsonify({'error': 'Not in discard phase'}), 400
    
    if card_index < 0 or card_index >= len(game['player_hand']):
        return jsonify({'error': 'Invalid card index'}), 400
    
    # Player discards
    player_card = game['player_hand'].pop(card_index)
    game['player_discarded'] = player_card
    
    # Log player discard
    log_action(
        action_type='discard',
        player='player',
        action_data={
            'card_discarded': f"{player_card['rank']}{player_card['suit']}",
            'card_index': card_index
        },
        session=session,
        additional_context={
            'hand_size_after': len(game['player_hand'])
        },
        request=request
    )
    
    # Computer discards using enhanced strategy
    idx = computer_discard_strategy(game['computer_hand'], game)
    computer_card = game['computer_hand'].pop(idx)
    game['computer_discarded'] = computer_card
    
    # Log computer discard
    log_action(
        action_type='discard',
        player='computer',
        action_data={
            'card_discarded': f"{computer_card['rank']}{computer_card['suit']}",
            'card_index': idx
        },
        session=session,
        additional_context={
            'hand_size_after': len(game['computer_hand'])
        }
    )
    
    # Calculate discard bonus points and determine winner
    discard_result = calculate_discard_score_with_winner(
        game['player_discarded'],
        game['computer_discarded'],
        game.get('player_parity', 'even'),
        game.get('computer_parity', 'odd')
    )
    
    # Store discard results for later reveal
    game['pending_discard_result'] = discard_result
    
    # Check for special cards in discards and store for later
    special_discard_result = check_special_cards_in_discard(
        game['player_discarded'],
        game['computer_discarded'],
        discard_result['winner']
    )
    
    game['pending_special_discard_result'] = special_discard_result
    
    # Log discard results
    log_game_event(
        event_type='discard_scoring',
        event_data={
            'player_card': f"{player_card['rank']}{player_card['suit']}",
            'computer_card': f"{computer_card['rank']}{computer_card['suit']}",
            'winner': discard_result['winner'],
            'bonus_points': discard_result['player_bonus'] + discard_result['computer_bonus'],
            'is_double': discard_result['is_double'],
            'explanation': discard_result['explanation']
        },
        session=session
    )
    
    # Check if bids were already made (blind bidding scenario)
    if game.get('player_bid') is not None:
        # Bids already set, go straight to playing
        game['phase'] = 'playing'
        first_leader = game.get('first_leader', 'player')
        game['turn'] = first_leader
        game['trick_leader'] = first_leader
        
        player_blind_text = " (BLIND)" if game.get('blind_bid') else ""
        computer_blind_text = " (BLIND)" if game.get('computer_blind_bid') else ""
        
        if first_leader == 'player':
            game['message'] = f'Cards discarded. You bid {game["player_bid"]}{player_blind_text}, Marta bid {game["computer_bid"]}{computer_blind_text}. Your turn to lead the first trick.'
        else:
            game['message'] = f'Cards discarded. You bid {game["player_bid"]}{player_blind_text}, Marta bid {game["computer_bid"]}{computer_blind_text}. Marta leads the first trick.'
            # If computer leads, make the computer play immediately
            computer_lead_with_logging(game, session)
            game['turn'] = 'player'
            game['message'] = f'Cards discarded. You bid {game["player_bid"]}{player_blind_text}, Marta bid {game["computer_bid"]}{computer_blind_text}. Marta led. Your turn to follow.'
    else:
        # Normal flow - check for blind bidding eligibility for both players
        player_base_score = game.get('player_score', 0)
        computer_base_score = game.get('computer_score', 0)
        blind_eligibility = check_blind_bidding_eligibility(player_base_score, computer_base_score)
        
        print(f"DEBUG BLIND CHECK: Player={player_base_score}, Computer={computer_base_score}, Player Eligible={blind_eligibility['player_eligible']}, Computer Eligible={blind_eligibility['computer_eligible']}")
        
        # Check player blind eligibility first
        if blind_eligibility['player_eligible']:
            # Enter blind decision phase
            game['phase'] = 'blind_decision'
            deficit = computer_base_score - player_base_score
            game['message'] = f'Cards discarded! You are down by {deficit} points. Choose: Go BLIND for double points/penalties, or bid normally?'
            
            print(f"DEBUG: Entering blind_decision phase with deficit of {deficit}")
        else:
            # No blind eligibility - go straight to normal bidding
            game['phase'] = 'bidding'
            first_leader = game.get('first_leader', 'player')
            
            if first_leader == 'computer':
                # Marta bids first - make her bid immediately
                computer_bid, computer_is_blind = computer_bidding_brain(
                    game['computer_hand'], 
                    None,  # No player bid yet
                    game
                )
                game['computer_bid'] = computer_bid
                
                # Log Marta's bid
                if computer_is_blind:
                    game['computer_blind_bid'] = computer_bid
                    computer_blind_text = " (BLIND)"
                    log_action(
                        action_type='blind_bid',
                        player='computer',
                        action_data={
                            'bid_amount': computer_bid,
                            'bid_first': True
                        },
                        session=session
                    )
                else:
                    computer_blind_text = ""
                    log_action(
                        action_type='regular_bid',
                        player='computer',
                        action_data={
                            'bid_amount': computer_bid,
                            'bid_first': True
                        },
                        session=session
                    )
                
                game['message'] = f'Cards discarded. Marta bid {computer_bid}{computer_blind_text}. Your turn to bid.'
            else:
                # Player bids first
                game['message'] = f'Cards discarded. Now make your bid: How many tricks will you take? (0-10)'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/play', methods=['POST'])
def play_card():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    # Track client session
    client_info = track_request_session()
    
    game = session['game']
    data = request.get_json()
    card_index = data.get('index')
    
    if game['phase'] != 'playing':
        return jsonify({'error': 'Not in playing phase'}), 400
    
    if game['turn'] != 'player':
        return jsonify({'error': 'Not your turn'}), 400
    
    if card_index < 0 or card_index >= len(game['player_hand']):
        return jsonify({'error': 'Invalid card index'}), 400
    
    card = game['player_hand'][card_index]
    
    # Validate the play
    if not is_valid_play(card, game['player_hand'], game['current_trick'], game['spades_broken']):
        return jsonify({'error': 'Invalid play - must follow suit if possible'}), 400
    
    # LOG THE PLAYER'S CARD PLAY
    log_action(
        action_type='card_play',
        player='player', 
        action_data={
            'card_played': f"{card['rank']}{card['suit']}",
            'card_index': card_index,
            'trick_position': len(game['current_trick']) + 1,
            'leading': len(game['current_trick']) == 0
        },
        session=session,
        additional_context={
            'hand_size_before': len(game['player_hand']),
            'spades_broken_before': game['spades_broken']
        },
        request=request
    )
    
    # Play the card
    game['player_hand'].pop(card_index)
    game['current_trick'].append({'player': 'player', 'card': card})
    
    if card['suit'] == 'â™ ':
        game['spades_broken'] = True
        log_game_event('spades_broken', {'broken_by': 'player', 'card': f"{card['rank']}{card['suit']}"}, session)
    
    # Determine next action based on trick state
    if len(game['current_trick']) == 1:
        # Player just led, computer needs to follow
        game['trick_leader'] = 'player'
        game['turn'] = 'computer'
        computer_follow_with_logging(game, session)
        # After computer follows, resolve the trick with delay
        resolve_trick_with_delay(game, session)
    elif len(game['current_trick']) == 2:
        # This shouldn't happen in normal flow, but handle it
        resolve_trick_with_delay(game, session)
    
    session.modified = True
    return jsonify({'success': True})


@app.route('/clear_trick', methods=['POST'])
def clear_trick():
    """Called by frontend after displaying trick for 3 seconds"""
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    game = session['game']
    
    # Don't error if trick is already cleared
    if not game.get('trick_completed'):
        return jsonify({'success': True, 'message': 'No trick to clear'}), 200
    
    winner = game.get('trick_winner')
    
    # Clear the trick
    game['current_trick'] = []
    game['trick_completed'] = False
    game['trick_winner'] = None
    
    # Check for hand over first
    if len(game['player_hand']) == 0:
        game['hand_over'] = True
        
        # Log hand completion
        log_game_event(
            event_type='hand_completed',
            event_data={
                'hand_number': game['hand_number'],
                'player_tricks': game['player_tricks'],
                'computer_tricks': game['computer_tricks'],
                'player_bid': game.get('player_bid', 0),
                'computer_bid': game.get('computer_bid', 0)
            },
            session=session
        )
        
        # Apply stored discard results at the end of the hand
        if 'pending_discard_result' in game:
            discard_result = game['pending_discard_result']
            game['player_score'] += discard_result['player_bonus']
            game['computer_score'] += discard_result['computer_bonus']
            
            # Apply special card effects from discards
            if 'pending_special_discard_result' in game:
                special_discard_result = game['pending_special_discard_result']
                
                if special_discard_result['player_bag_reduction'] > 0:
                    game['player_bags'] = reduce_bags_safely(
                        game.get('player_bags', 0), 
                        special_discard_result['player_bag_reduction']
                    )
                
                if special_discard_result['computer_bag_reduction'] > 0:
                    game['computer_bags'] = reduce_bags_safely(
                        game.get('computer_bags', 0), 
                        special_discard_result['computer_bag_reduction']
                    )
                
                # Store explanation for the final message
                game['discard_bonus_explanation'] = discard_result['explanation']
                if special_discard_result['explanation']:
                    game['discard_bonus_explanation'] += " | " + special_discard_result['explanation']
            else:
                game['discard_bonus_explanation'] = discard_result['explanation']
            
            # Clean up pending results
            del game['pending_discard_result']
            if 'pending_special_discard_result' in game:
                del game['pending_special_discard_result']
        
        # Calculate scoring with bags system
        scoring_result = calculate_hand_scores_with_bags(game)
        
        # Check if blind nil ended the game (but don't return early - show full results)
        blind_nil_ending = game.get('game_over', False)
        
        # Create structured hand results for cleaner display
        trick_history = game.get('trick_history', [])
        
        # Calculate display scores for hand results
        player_display_score = get_display_score(game['player_score'], game.get('player_bags', 0))
        computer_display_score = get_display_score(game['computer_score'], game.get('computer_bags', 0))
        
        hand_results = {
            'hand_number': game['hand_number'],
            'parity': {
                'player': game.get('player_parity', 'even').title(),
                'computer': game.get('computer_parity', 'odd').title()
            },
            'discard_info': game.get('discard_bonus_explanation', ''),
            'scoring': scoring_result['explanation'],
            'trick_history': [
                {
                    'number': trick['number'],
                    'player_card': f"{trick['player_card']['rank']}{trick['player_card']['suit']}" if trick['player_card'] else "?",
                    'computer_card': f"{trick['computer_card']['rank']}{trick['computer_card']['suit']}" if trick['computer_card'] else "?",
                    'winner': "You" if trick['winner'] == 'player' else "Marta"
                }
                for trick in trick_history
            ],
            'totals': {
                'player_score': player_display_score,
                'computer_score': computer_display_score
            }
        }
        
        # Store structured results for frontend
        game['hand_results'] = hand_results
        
        # Log final scoring
        log_game_event(
            event_type='hand_scoring',
            event_data={
                'scoring_explanation': scoring_result['explanation'],
                'final_scores': {
                    'player_score': player_display_score,
                    'computer_score': computer_display_score
                },
                'hand_results': hand_results
            },
            session=session
        )
        
        # Set appropriate message based on game state
        if blind_nil_ending:
            # Keep the blind nil message - it's already set in calculate_hand_scores_with_bags
            # Results will still be shown alongside the game over screen
            log_game_event(
                event_type='game_completed',
                event_data={
                    'winner': game['winner'],
                    'final_message': game['message'],
                    'hands_played': game['hand_number'],
                    'game_end_reason': 'blind_nil'
                },
                session=session
            )
        else:
            # Normal hand completion message
            game['message'] = f"Hand #{game['hand_number']} complete! Click 'Next Hand' to continue"
            
            # Check if game is over using base scores for comparison
            game_over = check_game_over(game)
            if game_over:
                log_game_event(
                    event_type='game_completed',
                    event_data={
                        'winner': game['winner'],
                        'final_message': game['message'],
                        'hands_played': game['hand_number']
                    },
                    session=session
                )
    
    # Check for auto-resolvable scenarios if hand not over
    elif len(game['player_hand']) > 0 and len(game['computer_hand']) > 0:
        from utilities.computer_logic import autoplay_remaining_cards
        auto_resolved, explanation = autoplay_remaining_cards(game, session)
        
        if auto_resolved:
            # Continue with normal hand completion logic
            if 'pending_discard_result' in game:
                discard_result = game['pending_discard_result']
                game['player_score'] += discard_result['player_bonus']
                game['computer_score'] += discard_result['computer_bonus']
                
                if 'pending_special_discard_result' in game:
                    special_discard_result = game['pending_special_discard_result']
                    
                    if special_discard_result['player_bag_reduction'] > 0:
                        game['player_bags'] = reduce_bags_safely(
                            game.get('player_bags', 0), 
                            special_discard_result['player_bag_reduction']
                        )
                    
                    if special_discard_result['computer_bag_reduction'] > 0:
                        game['computer_bags'] = reduce_bags_safely(
                            game.get('computer_bags', 0), 
                            special_discard_result['computer_bag_reduction']
                        )
                    
                    game['discard_bonus_explanation'] = discard_result['explanation']
                    if special_discard_result['explanation']:
                        game['discard_bonus_explanation'] += " | " + special_discard_result['explanation']
                else:
                    game['discard_bonus_explanation'] = discard_result['explanation']
                
                del game['pending_discard_result']
                if 'pending_special_discard_result' in game:
                    del game['pending_special_discard_result']
            
            # Calculate scoring
            scoring_result = calculate_hand_scores_with_bags(game)
            
            # Check if blind nil ended the game (auto-resolve case)
            blind_nil_ending = game.get('game_over', False)
            
            # Create hand results
            trick_history = game.get('trick_history', [])
            player_display_score = get_display_score(game['player_score'], game.get('player_bags', 0))
            computer_display_score = get_display_score(game['computer_score'], game.get('computer_bags', 0))
            
            hand_results = {
                'hand_number': game['hand_number'],
                'parity': {
                    'player': game.get('player_parity', 'even').title(),
                    'computer': game.get('computer_parity', 'odd').title()
                },
                'discard_info': game.get('discard_bonus_explanation', ''),
                'scoring': scoring_result['explanation'],
                'auto_resolution': explanation,
                'trick_history': [
                    {
                        'number': trick['number'],
                        'player_card': f"{trick['player_card']['rank']}{trick['player_card']['suit']}" if trick['player_card'] else "?",
                        'computer_card': f"{trick['computer_card']['rank']}{trick['computer_card']['suit']}" if trick['computer_card'] else "?",
                        'winner': "You" if trick['winner'] == 'player' else "Marta"
                    }
                    for trick in trick_history
                ],
                'totals': {
                    'player_score': player_display_score,
                    'computer_score': computer_display_score
                }
            }
            
            game['hand_results'] = hand_results
            
            if blind_nil_ending:
                # Keep blind nil message and log completion
                log_game_event(
                    event_type='game_completed',
                    event_data={
                        'winner': game['winner'],
                        'final_message': game['message'],
                        'hands_played': game['hand_number'],
                        'game_end_reason': 'blind_nil_auto_resolve'
                    },
                    session=session
                )
            else:
                game['message'] = f"{explanation}. Hand #{game['hand_number']} complete! Click 'Next Hand' to continue"
                
                # Check if game is over
                game_over = check_game_over(game)
                if game_over:
                    log_game_event(
                        event_type='game_completed',
                        event_data={
                            'winner': game['winner'],
                            'final_message': game['message'],
                            'hands_played': game['hand_number']
                        },
                        session=session
                    )
        else:
            # Normal trick continuation - determine next action
            if winner == 'computer':
                # Computer won last trick, so computer leads
                computer_lead_with_logging(game, session)
                game['turn'] = 'player'
                game['message'] = 'Marta led. Your turn to follow.'
            else:
                # Player won last trick, player leads next
                game['turn'] = 'player'
                game['message'] = 'You won the trick! Your turn to lead.'
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/next_hand', methods=['POST'])
def next_hand():
    if 'game' not in session:
        return jsonify({'error': 'No game in session'}), 400
    
    # Track client session
    client_info = track_request_session()
    
    game = session['game']
    
    if not game.get('hand_over', False) or game.get('game_over', False):
        return jsonify({'error': 'Cannot start next hand'}), 400
    
    # Log new hand start
    log_game_event(
        event_type='new_hand_started',
        event_data={
            'previous_hand': game['hand_number'],
            'new_hand': game['hand_number'] + 1
        },
        session=session
    )
    
    # Increment hand number and start new hand
    game['hand_number'] += 1
    init_new_hand(game)
    
    session.modified = True
    return jsonify({'success': True})

@app.route('/instructions')
def instructions():
    return render_template('instructions.html')

if __name__ == '__main__':
    import subprocess
    import webbrowser
    import time
    import socket
    
    def kill_process_on_port(port):
        """Kill any process using the specified port"""
        try:
            # macOS/Linux approach
            result = subprocess.run(['lsof', '-ti:' + str(port)], capture_output=True, text=True)
            if result.stdout.strip():
                pids = result.stdout.strip().split('\n')
                for pid in pids:
                    if pid.strip():
                        subprocess.run(['kill', '-9', pid.strip()], capture_output=True)
                        print(f"Killed process {pid.strip()} on port {port}")
                time.sleep(1)
                return True
        except FileNotFoundError:
            try:
                # Windows approach
                result = subprocess.run(['netstat', '-ano'], capture_output=True, text=True)
                for line in result.stdout.split('\n'):
                    if f':{port}' in line and 'LISTENING' in line:
                        parts = line.split()
                        if parts:
                            pid = parts[-1]
                            subprocess.run(['taskkill', '/F', '/PID', pid], capture_output=True)
                            print(f"Killed process {pid} on port {port}")
                time.sleep(1)
                return True
            except:
                pass
        except Exception as e:
            print(f"Could not kill processes on port {port}: {e}")
        return False
    
    def is_port_available(port):
        """Check if a port is available"""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        result = sock.connect_ex(('localhost', port))
        sock.close()
        return result != 0
    
    def find_available_port(start_port=5000, max_attempts=10):
        """Find an available port, killing processes if needed"""
        for port in range(start_port, start_port + max_attempts):
            if is_port_available(port):
                print(f"Port {port} is available")
                return port
            else:
                print(f"Port {port} is in use, attempting to kill process...")
                if kill_process_on_port(port):
                    # Check again after killing
                    time.sleep(0.5)
                    if is_port_available(port):
                        print(f"Successfully freed port {port}")
                        return port
                    else:
                        print(f"Port {port} still in use after kill attempt")
                else:
                    print(f"Could not kill process on port {port}")
        
        raise RuntimeError(f"Could not find an available port in range {start_port}-{start_port + max_attempts - 1}")
    
    # Find and secure a port
    try:
        port = find_available_port(5000, 10)
    except RuntimeError as e:
        print(f"Error: {e}")
        print("Please manually kill processes or restart your computer")
        exit(1)
    
    def open_browser():
        time.sleep(1.5)
        url = f'http://localhost:{port}'
        
        chrome_paths = [
            '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',
            'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe',
            'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
            '/usr/bin/google-chrome',
            '/usr/bin/chromium-browser',
        ]
        
        opened = False
        for chrome_path in chrome_paths:
            if os.path.exists(chrome_path):
                try:
                    subprocess.Popen([chrome_path, url])
                    print(f"Opened Chrome at {url}")
                    opened = True
                    break
                except:
                    pass
        
        # If Chrome wasn't found, use default browser
        if not opened:
            webbrowser.open(url)
            print(f"Opened default browser at {url}")
    
    # Start browser opening in a separate thread
    from threading import Thread
    browser_thread = Thread(target=open_browser)
    browser_thread.daemon = True
    browser_thread.start()
    
    print(f"Starting Flask app on port {port}...")
    print(f"The browser should open automatically in a moment...")
    print(f"If not, navigate to http://localhost:{port}")
    
    # Run Flask app
    app.run(debug=True, port=port, use_reloader=False)

================================================================================

FILE: ./gather_pythons.py
--------------------------------------------------------------------------------
import os
from datetime import datetime

# Configuration
# Set file types to include
FILE_EXTENSIONS = [
    '.py',    # Python files (always included)
    '.html',  # HTML files
    '.js',    # JavaScript files
    '.css',   # CSS files
    '.json',  # JSON configuration files
]

# Flag to control directory depth
ONLY_ROOT_DIRECTORY = False  # Set to True to only search in root directory

# Filename patterns to exclude (new)
EXCLUDED_FILENAME_PATTERNS = [
    'copy',   # Any file with 'copy' in the name
    'backup', # Any file with 'backup' in the name
    'temp',   # Any file with 'temp' in the name
        'archives',   # Any file with 'temp' in the name
]

# Directories to completely exclude from both scanning and output
EXCLUDED_DIRECTORIES = [
    "assets",
    "tests",
    "previous_versions",
    "projects",
    "tools",
    "revisions_app",
    "venv_de",
    ".git",
    "archives"

]

def gather_files(root_dir, excluded_directories, file_extensions, excluded_patterns, only_root=False):
    """
    Gathers files with specified extensions within the root directory and its subdirectories,
    excluding specified directories and filename patterns.

    Parameters:
        root_dir (str): The root directory to search for files.
        excluded_directories (list): List of directory names to exclude.
        file_extensions (list): List of file extensions to include.
        excluded_patterns (list): List of filename patterns to exclude.
        only_root (bool): If True, only search in the root directory (no subdirectories).

    Returns:
        tuple: (files_data, included_directories)
    """
    files_data = []
    included_directories = set()

    if only_root:
        # Only process files in the root directory
        relative_path = "."
        included_directories.add(relative_path)
        
        try:
            filenames = os.listdir(root_dir)
            for filename in filenames:
                file_path = os.path.join(root_dir, filename)
                
                # Skip directories
                if os.path.isdir(file_path):
                    continue
                
                # Skip files with excluded patterns in the filename
                if any(pattern.lower() in filename.lower() for pattern in excluded_patterns):
                    continue
                    
                # Only include files with the specified extensions
                if any(filename.endswith(ext) for ext in file_extensions):
                    try:
                        with open(file_path, 'r', encoding='utf-8') as file:
                            file_contents = file.read()
                        files_data.append((file_path, file_contents))
                    except UnicodeDecodeError:
                        print(f"Could not read file {file_path} due to encoding error. Skipping.")
                    except Exception as e:
                        print(f"Error with file {file_path}: {e}")
        except Exception as e:
            print(f"Error accessing root directory: {e}")
    else:
        # Original recursive behavior
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Get the relative path
            relative_path = os.path.relpath(dirpath, root_dir)
            
            # Skip excluded directories - check if any part of the path matches exclusion patterns
            should_exclude = False
            for excluded_dir in excluded_directories:
                # Check both exact match and path-based matches
                if excluded_dir == relative_path or excluded_dir in relative_path.replace('\\', '/'):
                    should_exclude = True
                    break
                    
            if should_exclude:
                continue

            # Add directory to our structure
            included_directories.add(relative_path)
            
            # Process files
            for filename in filenames:
                file_path = os.path.join(dirpath, filename)
                
                # Skip files with excluded patterns in the filename
                if any(pattern.lower() in filename.lower() for pattern in excluded_patterns):
                    continue
                    
                # Only include files with the specified extensions
                if any(filename.endswith(ext) for ext in file_extensions):
                    try:
                        with open(file_path, 'r', encoding='utf-8') as file:
                            file_contents = file.read()
                        files_data.append((file_path, file_contents))
                    except UnicodeDecodeError:
                        print(f"Could not read file {file_path} due to encoding error. Skipping.")
                    except Exception as e:
                        print(f"Error with file {file_path}: {e}")

    return files_data, sorted(included_directories)

def write_to_file(output_filepath, files_data, included_directories):
    """
    Writes the gathered data to a file with project information and file contents.
    """
    with open(output_filepath, 'w', encoding='utf-8') as file:
        # Write statistics
        file.write(f"Number of files: {len(files_data)}\n")
        file.write(f"Number of directories: {len(included_directories)}\n\n")
        
        # Write directory structure
        file.write("Directory structure:\n")
        for directory in included_directories:
            file.write(f"{directory}\n")
        file.write("\n")
        
        # Group and list files by extension
        extension_groups = {}
        for filepath, _ in files_data:
            ext = os.path.splitext(filepath)[1].lower()
            if ext not in extension_groups:
                extension_groups[ext] = []
            extension_groups[ext].append(filepath)
        
        file.write("List of file paths by type:\n")
        for ext, filepaths in sorted(extension_groups.items()):
            file.write(f"\n{ext.upper()[1:]} Files ({len(filepaths)}):\n")
            for filepath in sorted(filepaths):
                file.write(f"  {filepath}\n")
        file.write("\n")
        
        # Write file contents
        file.write("="*80 + "\n")
        file.write("FILE CONTENTS\n")
        file.write("="*80 + "\n\n")
        
        for filepath, file_contents in files_data:
            file.write(f"FILE: {filepath}\n")
            file.write("-"*80 + "\n")
            file.write(f"{file_contents}\n\n")
            file.write("="*80 + "\n\n")

def scan_project_structure():
    """
    Main function to scan the project structure and write the results to a file.
    """
    root_dir = "."  # Current directory
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_filepath = f"{timestamp}_project_structure.txt"
    
    print(f"Starting to scan project structure at {root_dir}...")
    print(f"Including file types: {', '.join(FILE_EXTENSIONS)}")
    print(f"Excluding file patterns: {', '.join(EXCLUDED_FILENAME_PATTERNS)}")
    
    if ONLY_ROOT_DIRECTORY:
        print("Scanning ONLY root directory (subdirectories will be skipped)")
    else:
        print(f"Excluding directories: {', '.join(EXCLUDED_DIRECTORIES)}")
    
    # Gather files and directory information
    files_data, included_directories = gather_files(
        root_dir, 
        EXCLUDED_DIRECTORIES, 
        FILE_EXTENSIONS,
        EXCLUDED_FILENAME_PATTERNS,
        only_root=ONLY_ROOT_DIRECTORY
    )
    
    print(f"Found {len(files_data)} files across {len(included_directories)} directories.")
    if not ONLY_ROOT_DIRECTORY:
        print(f"Excluded directories won't appear in the output file.")
    
    # Write the output file
    write_to_file(
        output_filepath, 
        files_data, 
        included_directories
    )
    
    print(f"Project structure has been written to {output_filepath}")
    print(f"File size: {os.path.getsize(output_filepath) / (1024*1024):.2f} MB")

if __name__ == "__main__":
    scan_project_structure()

================================================================================

FILE: ./utilities/gameplay_logic.py
--------------------------------------------------------------------------------
import random

def create_deck():
    """Create a standard 52-card deck"""
    suits = ['â™ ', 'â™¥', 'â™¦', 'â™£']
    ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
    deck = []
    for suit in suits:
        for rank in ranks:
            deck.append({'rank': rank, 'suit': suit, 'value': get_card_value(rank)})
    return deck

def get_card_value(rank):
    """Get numerical value of a card rank"""
    if rank == 'A':
        return 14
    elif rank == 'K':
        return 13
    elif rank == 'Q':
        return 12
    elif rank == 'J':
        return 11
    else:
        return int(rank)

def sort_hand(hand):
    """Sort hand by suit (clubs, diamonds, hearts, spades) then by value"""
    suit_order = {'â™£': 0, 'â™¦': 1, 'â™¥': 2, 'â™ ': 3}
    return sorted(hand, key=lambda x: (suit_order[x['suit']], x['value']))

def init_game(player_parity='even', computer_parity='odd', first_leader='player'):
    """Initialize a new game"""
    deck = create_deck()
    random.shuffle(deck)
    
    return {
        'player_hand': sort_hand(deck[:11]),
        'computer_hand': sort_hand(deck[11:22]),
        'current_trick': [],
        'player_tricks': 0,
        'computer_tricks': 0,
        'spades_broken': False,
        'phase': 'discard',
        'turn': 'player',  # Both players can discard simultaneously
        'trick_leader': None,
        'hand_over': False,
        'game_over': False,
        'winner': None,
        'message': 'Select a card to discard',
        'player_discarded': None,
        'computer_discarded': None,
        'show_computer_hand': False,
        'trick_display_timer': None,
        'player_bid': None,
        'computer_bid': None,
        'total_tricks': 10,
        'player_score': 0,
        'computer_score': 0,
        'player_bags': 0,
        'computer_bags': 0,
        'player_trick_special_cards': 0,
        'computer_trick_special_cards': 0,
        'hand_number': 1,
        'target_score': 300,
        'player_parity': player_parity,
        'computer_parity': computer_parity,
        'first_leader': first_leader,  # Who leads the first trick of each hand
        'discard_bonus_explanation': None,
        'pending_discard_result': None,
        'pending_special_discard_result': None,
        'blind_bidding_available': False,
        'blind_bid': None,
        'computer_blind_bid': None,
        'blind_multiplier': 2,
        'trick_history': []  # Track all tricks played this hand
    }

def init_new_hand(game):
    """Start a new hand while preserving scores, bags, and parity assignments"""
    deck = create_deck()
    random.shuffle(deck)
    
    # Alternate who leads the first trick each hand
    current_first_leader = game.get('first_leader', 'player')
    next_first_leader = 'computer' if current_first_leader == 'player' else 'player'
    
    # Check blind bidding eligibility before setting phase
    from .custom_rules import check_blind_bidding_eligibility
    player_base_score = game.get('player_score', 0)
    computer_base_score = game.get('computer_score', 0)
    blind_eligibility = check_blind_bidding_eligibility(player_base_score, computer_base_score)
    
    # Set initial phase and message based on blind eligibility
    if blind_eligibility['player_eligible']:
        initial_phase = 'blind_decision'
        deficit = computer_base_score - player_base_score
        initial_message = f'You are down by {deficit} points. Choose: Go BLIND for double points/penalties, or bid normally?'
    else:
        initial_phase = 'discard'
        initial_message = f'Hand #{game["hand_number"]} - Select a card to discard'
    
    game.update({
        'player_hand': sort_hand(deck[:11]),
        'computer_hand': sort_hand(deck[11:22]),
        'current_trick': [],
        'player_tricks': 0,
        'computer_tricks': 0,
        'spades_broken': False,
        'phase': initial_phase,
        'turn': 'player',
        'trick_leader': None,
        'hand_over': False,
        'message': initial_message,
        'player_discarded': None,
        'computer_discarded': None,
        'show_computer_hand': False,
        'trick_display_timer': None,
        'player_bid': None,
        'computer_bid': None,
        'total_tricks': 10,
        'discard_bonus_explanation': None,
        'player_trick_special_cards': 0,
        'computer_trick_special_cards': 0,
        'pending_discard_result': None,
        'pending_special_discard_result': None,
        'blind_bidding_available': blind_eligibility['player_eligible'],
        'blind_bid': None,
        'computer_blind_bid': None,
        'first_leader': next_first_leader,
        'trick_history': []
    })

def computer_bidding_brain(computer_hand, player_bid, game_state=None):
    """
    Computer bidding function - now delegates to computer_logic module
    """
    if game_state is None:
        # Fallback for backward compatibility
        game_state = {'player_score': 0, 'computer_score': 0, 'computer_bags': 0}
    
    from .computer_logic import computer_bidding_brain as enhanced_brain
    return enhanced_brain(computer_hand, player_bid, game_state)

def computer_discard_strategy(computer_hand, game_state=None):
    """
    Computer discard strategy - now delegates to computer_logic module
    """
    if game_state is None:
        # Fallback to simple strategy for backward compatibility
        computer_discards = []
        for i, card in enumerate(computer_hand):
            if card['suit'] != 'â™ ':
                computer_discards.append((i, card['value']))
        
        if computer_discards:
            return min(computer_discards, key=lambda x: x[1])[0]
        else:
            return 0
    
    from .computer_logic import computer_discard_strategy as enhanced_discard
    return enhanced_discard(computer_hand, game_state)

def is_valid_play(card, hand, trick, spades_broken):
    """Check if a card play is valid according to Spades rules"""
    if len(trick) == 0:
        # Leading
        if card['suit'] == 'â™ ' and not spades_broken:
            # Can only lead spades if no other suits
            for c in hand:
                if c['suit'] != 'â™ ':
                    return False
        return True
    else:
        # Following
        lead_suit = trick[0]['card']['suit']
        # Must follow suit if possible
        has_suit = any(c['suit'] == lead_suit for c in hand)
        if has_suit:
            return card['suit'] == lead_suit
        return True

def determine_trick_winner(trick):
    """
    Determine who won a completed trick
    Returns the player who won ('player' or 'computer')
    """
    if len(trick) != 2:
        return None
    
    first = trick[0]
    second = trick[1]
    
    if first['card']['suit'] == second['card']['suit']:
        # Same suit, higher value wins
        if first['card']['value'] > second['card']['value']:
            return first['player']
        else:
            return second['player']
    elif first['card']['suit'] == 'â™ ':
        # First player trumped
        return first['player']
    elif second['card']['suit'] == 'â™ ':
        # Second player trumped  
        return second['player']
    else:
        # Different suits, no trump - first player (leader) wins
        return first['player']

def resolve_trick_with_delay(game):
    """Resolve trick and set it up to be displayed for 3 seconds"""
    if len(game['current_trick']) != 2:
        return
    
    winner = determine_trick_winner(game['current_trick'])
    
    # SAVE TRICK TO HISTORY BEFORE PROCESSING
    trick_number = len(game.get('trick_history', [])) + 1
    player_card = next((play['card'] for play in game['current_trick'] if play['player'] == 'player'), None)
    computer_card = next((play['card'] for play in game['current_trick'] if play['player'] == 'computer'), None)
    
    game.setdefault('trick_history', []).append({
        'number': trick_number,
        'player_card': player_card,
        'computer_card': computer_card,
        'winner': winner
    })
    
    # LOG EACH TRICK TO CONSOLE
    p_text = f"{player_card['rank']}{player_card['suit']}" if player_card else "?"
    c_text = f"{computer_card['rank']}{computer_card['suit']}" if computer_card else "?"
    winner_name = "You" if winner == 'player' else "Marta"
    print(f"TRICK {trick_number}: {p_text} vs {c_text} -> {winner_name} wins")
    
    
    # Check for special cards in the trick and apply bag reduction IMMEDIATELY
    from utilities.custom_rules import check_special_cards_in_trick, reduce_bags_safely
    special_result = check_special_cards_in_trick(game['current_trick'], winner)
    
    if special_result['bag_reduction'] > 0:
        if winner == 'player':
            current_bags = game.get('player_bags', 0)
            game['player_bags'] = reduce_bags_safely(current_bags, special_result['bag_reduction'])
            game['player_trick_special_cards'] = game.get('player_trick_special_cards', 0) + special_result['bag_reduction']
        else:
            current_bags = game.get('computer_bags', 0)
            game['computer_bags'] = reduce_bags_safely(current_bags, special_result['bag_reduction'])
            game['computer_trick_special_cards'] = game.get('computer_trick_special_cards', 0) + special_result['bag_reduction']
        
        game['special_card_message'] = special_result['explanation']
    
    # Award trick
    if winner == 'player':
        game['player_tricks'] += 1
        base_message = 'You won the trick!'
    else:
        game['computer_tricks'] += 1
        base_message = 'Marta won the trick!'
    
    # Add special card info to message if present
    if special_result['explanation']:
        game['message'] = f"{base_message} {special_result['explanation']} Cards will clear in 3 seconds..."
    else:
        game['message'] = f"{base_message} Cards will clear in 3 seconds..."
    
    # Mark trick as completed but don't clear yet
    game['trick_completed'] = True
    game['trick_winner'] = winner

def computer_follow(game):
    """Computer plays a card when following - now uses bag avoidance strategy"""
    hand = game['computer_hand']
    trick = game['current_trick']
    
    if not trick or not hand:
        return
    
    # Use enhanced following strategy from computer_logic
    from .computer_logic import computer_follow_strategy
    chosen_idx = computer_follow_strategy(hand, trick, game)
    
    if chosen_idx is None:
        # Fallback to original simple logic if strategy fails
        lead_card = trick[0]['card']
        lead_suit = lead_card['suit']
        lead_value = lead_card['value']
        
        # Find valid plays
        same_suit = [(i, c) for i, c in enumerate(hand) if c['suit'] == lead_suit]
        spades = [(i, c) for i, c in enumerate(hand) if c['suit'] == 'â™ ']
        
        if same_suit:
            # Must follow suit - try to win with lowest winning card
            winners = [(i, c) for i, c in same_suit if c['value'] > lead_value]
            if winners:
                chosen_idx = min(winners, key=lambda x: x[1]['value'])[0]
            else:
                # Can't win, play lowest
                chosen_idx = min(same_suit, key=lambda x: x[1]['value'])[0]
        elif lead_suit != 'â™ ' and spades:
            # Can't follow suit, can trump with spade
            chosen_idx = min(spades, key=lambda x: x[1]['value'])[0]
        else:
            # Can't follow or trump, discard lowest
            all_cards = [(i, c) for i, c in enumerate(hand)]
            chosen_idx = min(all_cards, key=lambda x: x[1]['value'])[0]
    
    # Play the chosen card
    card = hand.pop(chosen_idx)
    game['current_trick'].append({'player': 'computer', 'card': card})
    
    if card['suit'] == 'â™ ':
        game['spades_broken'] = True

def computer_lead(game):
    """Computer plays a card when leading - now uses enhanced strategy"""
    hand = game['computer_hand']
    
    if not hand:
        return
    
    # Use enhanced leading strategy from computer_logic
    from .computer_logic import computer_lead_strategy
    chosen_idx = computer_lead_strategy(hand, game['spades_broken'])
    
    if chosen_idx is None:
        # Fallback to original simple logic if strategy fails
        valid = []
        for i, card in enumerate(hand):
            if card['suit'] != 'â™ ' or game['spades_broken'] or all(c['suit'] == 'â™ ' for c in hand):
                valid.append((i, card))
        
        if valid:
            chosen = min(valid, key=lambda x: (x[1]['suit'] == 'â™ ', x[1]['value']))
            chosen_idx = chosen[0]
        else:
            return
    
    # Play the chosen card
    card = hand.pop(chosen_idx)
    game['current_trick'] = [{'player': 'computer', 'card': card}]
    game['trick_leader'] = 'computer'
    
    if card['suit'] == 'â™ ':
        game['spades_broken'] = True

def check_game_over(game):
    """
    Check if the game is over (someone reached target score OR down by 300+ points)
    Updates game state with winner information if game is over
    Uses proper tie-breaking logic considering base scores and bags
    """
    player_base_score = game['player_score']
    computer_base_score = game['computer_score']
    player_bags = game.get('player_bags', 0)
    computer_bags = game.get('computer_bags', 0)
    target_score = game['target_score']
    
    # Calculate display scores inline (no import needed)
    def calc_display_score(base_score, bags):
        if bags >= 0:
            if base_score < 0:
                tens_and_higher = (base_score // 10) * 10
                return tens_and_higher - bags
            else:
                tens_and_higher = (base_score // 10) * 10
                return tens_and_higher + bags
        else:
            return base_score
    
    player_display_score = calc_display_score(player_base_score, player_bags)
    computer_display_score = calc_display_score(computer_base_score, computer_bags)
    
    # Check for 300-point deficit rule (mercy rule) using display scores
    if player_display_score - computer_display_score >= 300:
        game['game_over'] = True
        game['winner'] = 'player'
        game['message'] = f"GAME OVER! You WIN by mercy rule {player_display_score} to {computer_display_score}! (300+ point lead)"
        return True
    elif computer_display_score - player_display_score >= 300:
        game['game_over'] = True
        game['winner'] = 'computer'
        game['message'] = f"GAME OVER! Marta WINS by mercy rule {computer_display_score} to {player_display_score}! (300+ point lead)"
        return True
    
    # Check for regular target score (300 points) using display scores
    if player_display_score >= target_score or computer_display_score >= target_score:
        game['game_over'] = True
        
        if player_display_score > computer_display_score:
            game['winner'] = 'player'
            game['message'] = f"GAME OVER! You WIN {player_display_score} to {computer_display_score}!"
        elif computer_display_score > player_display_score:
            game['winner'] = 'computer'
            game['message'] = f"GAME OVER! Marta WINS {computer_display_score} to {player_display_score}!"
        else:
            # Tie-breaking logic
            if player_base_score > computer_base_score:
                game['winner'] = 'player'
                game['message'] = f"GAME OVER! You WIN {player_display_score} to {computer_display_score} (tie-breaker)!"
            elif computer_base_score > player_base_score:
                game['winner'] = 'computer'
                game['message'] = f"GAME OVER! Marta WINS {computer_display_score} to {player_display_score} (tie-breaker)!"
            else:
                # Bags tie-breaker - negative bags lose
                if player_bags < 0 and computer_bags >= 0:
                    game['winner'] = 'computer'
                    game['message'] = f"GAME OVER! Marta WINS {computer_display_score} to {player_display_score} (negative bags lose)!"
                elif computer_bags < 0 and player_bags >= 0:
                    game['winner'] = 'player'
                    game['message'] = f"GAME OVER! You WIN {player_display_score} to {computer_display_score} (negative bags lose)!"
                elif player_bags < computer_bags:
                    game['winner'] = 'player'
                    game['message'] = f"GAME OVER! You WIN {player_display_score} to {computer_display_score} (fewer bags)!"
                elif computer_bags < player_bags:
                    game['winner'] = 'computer' 
                    game['message'] = f"GAME OVER! Marta WINS {computer_display_score} to {player_display_score} (fewer bags)!"
                else:
                    game['winner'] = 'tie'
                    game['message'] = f"GAME OVER! TIE at {player_display_score} points each!"
        
        return True
    
    return False

================================================================================

FILE: ./utilities/custom_rules.py
--------------------------------------------------------------------------------
import random

def get_discard_value(card):
    """
    Get the numerical value of a card for discard scoring.
    J=11, Q=12, K=13, A=1, numbers are face value
    """
    rank = card['rank']
    if rank == 'A':
        return 1
    elif rank == 'J':
        return 11
    elif rank == 'Q':
        return 12
    elif rank == 'K':
        return 13
    else:
        return int(rank)

def assign_even_odd_at_game_start():
    """
    Randomly assign even/odd to players at the start of a new game.
    Also determines who leads the first trick - if player is odd, they lead first.
    Returns tuple: (player_parity, computer_parity, first_leader)
    """
    coin_flip = random.choice(['even', 'odd'])
    if coin_flip == 'even':
        player_parity = 'even'
        computer_parity = 'odd'
        first_leader = 'computer'  # Computer (odd) leads first trick
    else:
        player_parity = 'odd'
        computer_parity = 'even'
        first_leader = 'player'   # Player (odd) leads first trick
    
    return (player_parity, computer_parity, first_leader)

def is_special_card(card):
    """
    Check if a card is one of the special bag-reducing cards.
    Returns tuple: (is_special, bags_to_remove)
    """
    if card['rank'] == '7' and card['suit'] == 'â™¦':
        return True, 2  # 7 of diamonds removes 2 bags
    elif card['rank'] == '10' and card['suit'] == 'â™£':
        return True, 1  # 10 of clubs removes 1 bag
    else:
        return False, 0

def check_blind_bidding_eligibility(player_score, computer_score, target_score=300):
    """
    Check if a player is eligible for blind bidding (down by 100+ points).
    
    Returns:
        dict: {
            'player_eligible': bool,
            'computer_eligible': bool,
            'player_deficit': int,
            'computer_deficit': int
        }
    """
    player_deficit = computer_score - player_score
    computer_deficit = player_score - computer_score
    
    return {
        'player_eligible': player_deficit >= 100,
        'computer_eligible': computer_deficit >= 100,
        'player_deficit': max(0, player_deficit),
        'computer_deficit': max(0, computer_deficit)
    }

def apply_blind_scoring(base_points, blind_bid, actual_tricks):
    """
    Apply blind bidding scoring rules.
    
    Args:
        base_points: Normal points that would be awarded
        blind_bid: The blind bid amount (5-10)
        actual_tricks: Actual tricks taken
        
    Returns:
        int: Modified points (doubled if successful, doubled penalty if failed)
    """
    if actual_tricks >= blind_bid:
        # Successful blind bid: double the points
        return base_points * 2
    else:
        # Failed blind bid: double the penalty
        return base_points * 2  # base_points will already be negative for failed bids

def check_special_cards_in_discard(player_discard, computer_discard, discard_winner):
    """
    Check for special cards in the discard pile and apply bag reduction to the winner.
    """
    total_reduction = 0
    special_cards_found = []
    
    # Check both discarded cards for special cards
    for card, discarder in [(player_discard, 'You'), (computer_discard, 'Marta')]:
        if card:
            is_special, reduction = is_special_card(card)
            if is_special:
                total_reduction += reduction
                card_name = f"{card['rank']}{card['suit']}"
                special_cards_found.append(f"{card_name} (-{reduction} bags)")
    
    # Apply all reductions to the winner of the discard pile
    player_reduction = 0
    computer_reduction = 0
    
    if total_reduction > 0:
        if discard_winner == 'player':
            player_reduction = total_reduction
        else:
            computer_reduction = total_reduction
    
    # Create explanation
    explanation = ""
    if special_cards_found:
        winner_name = "You" if discard_winner == 'player' else "Marta"
        cards_text = ", ".join(special_cards_found)
        explanation = f"{winner_name} won discard pile with special cards: {cards_text}"
    
    return {
        'player_bag_reduction': player_reduction,
        'computer_bag_reduction': computer_reduction,
        'explanation': explanation
    }

def check_special_cards_in_trick(trick, winner):
    """
    Check for special cards in a completed trick and apply bag reduction to winner.
    """
    total_reduction = 0
    special_cards_found = []
    
    for play in trick:
        card = play['card']
        is_special, reduction = is_special_card(card)
        if is_special:
            total_reduction += reduction
            card_name = f"{card['rank']}{card['suit']}"
            special_cards_found.append(f"{card_name} (-{reduction} bags)")
    
    explanation = ""
    if special_cards_found:
        winner_name = "You" if winner == 'player' else "Marta"
        cards_text = ", ".join(special_cards_found)
        explanation = f"{winner_name} won trick with special cards: {cards_text}"
    
    return {
        'bag_reduction': total_reduction,
        'explanation': explanation
    }

def calculate_discard_score_with_winner(player_discard, computer_discard, player_parity, computer_parity):
    """Calculate the bonus points from discarded cards and determine winner."""
    if not player_discard or not computer_discard:
        return {
            'player_bonus': 0,
            'computer_bonus': 0, 
            'total': 0,
            'is_double': False,
            'winner': None,
            'explanation': 'No discards to score'
        }
    
    # Calculate total value
    player_value = get_discard_value(player_discard)
    computer_value = get_discard_value(computer_discard)
    total = player_value + computer_value
    
    # Check for doubles (same suit OR same rank)
    is_double = (player_discard['suit'] == computer_discard['suit'] or 
                 player_discard['rank'] == computer_discard['rank'])
    
    # Determine base points (10 for normal, 20 for doubles)
    base_points = 20 if is_double else 10
    
    # Award points based on parity and determine winner
    player_bonus = 0
    computer_bonus = 0
    winner = None
    
    is_total_even = (total % 2 == 0)
    
    if is_total_even and player_parity == 'even':
        player_bonus = base_points
        winner = 'player'
    elif not is_total_even and player_parity == 'odd':
        player_bonus = base_points
        winner = 'player'
    elif is_total_even and computer_parity == 'even':
        computer_bonus = base_points
        winner = 'computer'
    elif not is_total_even and computer_parity == 'odd':
        computer_bonus = base_points
        winner = 'computer'
    
    # Create explanation
    double_text = ""
    if is_double:
        if player_discard['suit'] == computer_discard['suit']:
            double_text = f" (DOUBLE: Both {player_discard['suit']} suit!)"
        else:
            double_text = f" (DOUBLE: Both {player_discard['rank']}s!)"
    
    parity_text = "even" if is_total_even else "odd"
    
    explanation = f"Discards: {player_discard['rank']}{player_discard['suit']} ({player_value}) + {computer_discard['rank']}{computer_discard['suit']} ({computer_value}) = {total} ({parity_text}){double_text}"
    
    if player_bonus > 0:
        explanation += f" â†’ You gets {player_bonus} pts!"
    elif computer_bonus > 0:
        explanation += f" â†’ Marta gets {computer_bonus} pts!"
    else:
        explanation += " â†’ No bonus points this hand."
    
    return {
        'player_bonus': player_bonus,
        'computer_bonus': computer_bonus,
        'total': total,
        'is_double': is_double,
        'winner': winner,
        'explanation': explanation
    }

def apply_bags_penalty(score, bags):
    """Apply bags penalty system."""
    penalty_applied = False
    bonus_applied = False
    
    while bags >= 7:
        score -= 100
        bags -= 7
        penalty_applied = True
    
    while bags <= -5:
        score += 100
        bags += 5
        bonus_applied = True
    
    return score, bags, penalty_applied, bonus_applied

def reduce_bags_safely(current_bags, reduction):
    """Reduce bags by the specified amount. Bags can go negative."""
    return current_bags - reduction


def calculate_hand_scores_with_bags(game):
    """
    Calculate hand scoring including bags system, nil bids, blind bidding, and blind nil for both players.
    """
    
    # Check for blind nil FIRST - it ends the game immediately
    if game.get('blind_nil') and game.get('player_bid') == 0:
        player_actual = game.get('player_tricks', 0)
        if player_actual == 0:
            # INSTANT WIN - Set score to 500 to show massive victory
            game['player_score'] = 500
            game['game_over'] = True
            game['winner'] = 'player'
            game['message'] = "BLIND NIL SUCCESS! You win the entire game instantly!"
            return {'explanation': "BLIND NIL SUCCESS - INSTANT GAME WIN!"}
        else:
            # INSTANT LOSS - Keep Marta's current score, player gets massive penalty
            game['player_score'] = -500  # Show crushing defeat
            game['game_over'] = True
            game['winner'] = 'computer'
            game['message'] = f"Blind Nil failed - you took {player_actual} tricks. Marta wins!"
            return {'explanation': f"BLIND NIL FAILURE - took {player_actual} tricks - GAME OVER"}

    
    # Normal scoring continues if no blind nil or blind nil not attempted
    player_bid = game.get('player_bid', 0)
    computer_bid = game.get('computer_bid', 0)
    player_actual = game.get('player_tricks', 0)
    computer_actual = game.get('computer_tricks', 0)
    
    # Check blind bids for both players
    is_player_blind = game.get('blind_bid') == player_bid and game.get('blind_bid') is not None
    is_computer_blind = game.get('computer_blind_bid') == computer_bid and game.get('computer_blind_bid') is not None
    
    # Get current bags
    current_player_bags = game.get('player_bags', 0)
    current_computer_bags = game.get('computer_bags', 0)
    
    # Calculate player points
    if player_bid == 0:
        if player_actual == 0:
            player_hand_points = 200  # NIL success
            player_bags_added = 0
        else:
            player_hand_points = -200  # NIL failure
            player_bags_added = player_actual
    elif player_actual >= player_bid:
        player_hand_points = (player_bid * 10)
        player_bags_added = player_actual - player_bid
        if is_player_blind:
            player_hand_points = apply_blind_scoring(player_hand_points, player_bid, player_actual)
    else:
        player_hand_points = -(player_bid * 10)
        player_bags_added = 0
        if is_player_blind:
            player_hand_points = apply_blind_scoring(player_hand_points, player_bid, player_actual)
    
    # Calculate computer points
    if computer_bid == 0:
        if computer_actual == 0:
            computer_hand_points = 200  # NIL success
            computer_bags_added = 0
        else:
            computer_hand_points = -200  # NIL failure
            computer_bags_added = computer_actual
    elif computer_actual >= computer_bid:
        computer_hand_points = (computer_bid * 10)
        computer_bags_added = computer_actual - computer_bid
        if is_computer_blind:
            computer_hand_points = apply_blind_scoring(computer_hand_points, computer_bid, computer_actual)
    else:
        computer_hand_points = -(computer_bid * 10)
        computer_bags_added = 0
        if is_computer_blind:
            computer_hand_points = apply_blind_scoring(computer_hand_points, computer_bid, computer_actual)
    
    # Update bag counts
    new_player_bags = current_player_bags + player_bags_added
    new_computer_bags = current_computer_bags + computer_bags_added
    
    # Apply bag penalties/bonuses
    player_score = game.get('player_score', 0) + player_hand_points
    computer_score = game.get('computer_score', 0) + computer_hand_points
    
    player_score, final_player_bags, player_penalty, player_bonus = apply_bags_penalty(player_score, new_player_bags)
    computer_score, final_computer_bags, computer_penalty, computer_bonus = apply_bags_penalty(computer_score, new_computer_bags)
    
    # Update game state
    game['player_bags'] = final_player_bags
    game['computer_bags'] = final_computer_bags
    game['player_score'] = player_score
    game['computer_score'] = computer_score
    
    # Get special card tracking for summary
    player_trick_special_cards = game.get('player_trick_special_cards', 0)
    computer_trick_special_cards = game.get('computer_trick_special_cards', 0)
    
    # Reset special card tracking for next hand
    game['player_trick_special_cards'] = 0
    game['computer_trick_special_cards'] = 0
    
    # Create explanation
    explanation_parts = []
    
    # Player explanation
    if player_bid == 0:
        if player_actual == 0:
            explanation_parts.append(f"You: NIL SUCCESS! 0 bid, 0 tricks (+200 pts)")
        else:
            explanation_parts.append(f"You: NIL FAILED! 0 bid, {player_actual} tricks (-200 pts, +{player_bags_added} bags)")
    elif is_player_blind:
        if player_actual >= player_bid:
            explanation_parts.append(f"You: BLIND {player_bid} SUCCESS! {player_actual} tricks (DOUBLE POINTS: +{player_hand_points} pts)")
        else:
            explanation_parts.append(f"You: BLIND {player_bid} FAILED! {player_actual} tricks (DOUBLE PENALTY: {player_hand_points} pts)")
        if player_bags_added > 0:
            explanation_parts[-1] += f", +{player_bags_added} bags"
    elif player_bags_added > 0:
        explanation_parts.append(f"You: {player_bid} bid, {player_actual} tricks (+{player_bags_added} bags)")
    else:
        explanation_parts.append(f"You: {player_bid} bid, {player_actual} tricks")
    
    # Computer explanation with blind support
    if computer_bid == 0:
        if computer_actual == 0:
            explanation_parts.append(f"Marta: NIL SUCCESS! 0 bid, 0 tricks (+200 pts)")
        else:
            explanation_parts.append(f"Marta: NIL FAILED! 0 bid, {computer_actual} tricks (-200 pts, +{computer_bags_added} bags)")
    elif is_computer_blind:
        if computer_actual >= computer_bid:
            explanation_parts.append(f"Marta: BLIND {computer_bid} SUCCESS! {computer_actual} tricks (DOUBLE POINTS: +{computer_hand_points} pts)")
        else:
            explanation_parts.append(f"Marta: BLIND {computer_bid} FAILED! {computer_actual} tricks (DOUBLE PENALTY: {computer_hand_points} pts)")
        if computer_bags_added > 0:
            explanation_parts[-1] += f", +{computer_bags_added} bags"
    elif computer_bags_added > 0:
        explanation_parts.append(f"Marta: {computer_bid} bid, {computer_actual} tricks (+{computer_bags_added} bags)")
    else:
        explanation_parts.append(f"Marta: {computer_bid} bid, {computer_actual} tricks")
    
    # Show special card effects from tricks
    if player_trick_special_cards > 0:
        explanation_parts.append(f"You won special cards: -{player_trick_special_cards} bags")
    if computer_trick_special_cards > 0:
        explanation_parts.append(f"Marta won special cards: -{computer_trick_special_cards} bags")
    
    # Show penalties and bonuses
    if player_penalty:
        penalty_count = (current_player_bags + player_bags_added) // 7
        explanation_parts.append(f"You: BAG PENALTY! -{penalty_count * 100} pts")
    
    if player_bonus:
        bonus_count = abs((current_player_bags + player_bags_added) // -5)
        explanation_parts.append(f"You: NEGATIVE BAG BONUS! +{bonus_count * 100} pts")
        
    if computer_penalty:
        penalty_count = (current_computer_bags + computer_bags_added) // 7
        explanation_parts.append(f"Marta: BAG PENALTY! -{penalty_count * 100} pts")
    
    if computer_bonus:
        bonus_count = abs((current_computer_bags + computer_bags_added) // -5)
        explanation_parts.append(f"Marta: NEGATIVE BAG BONUS! +{bonus_count * 100} pts")
    
    # Show current bag counts
    if final_player_bags != 0 or final_computer_bags != 0:
        explanation_parts.append(f"Bags: You {final_player_bags}/7, Marta {final_computer_bags}/7")
    
    return {
        'player_hand_points': player_hand_points,
        'computer_hand_points': computer_hand_points,
        'player_bags_added': player_bags_added,
        'computer_bags_added': computer_bags_added,
        'player_penalty': player_penalty,
        'computer_penalty': computer_penalty,
        'player_bonus': player_bonus,
        'computer_bonus': computer_bonus,
        'explanation': " | ".join(explanation_parts)
    }

def get_player_names_with_parity(player_parity, computer_parity):
    """
    Get display names that include the parity assignment.
    """
    player_name = f"You ({player_parity.title()})"
    computer_name = f"Marta ({computer_parity.title()})"
    
    return (player_name, computer_name)

================================================================================

FILE: ./utilities/computer_logic.py
--------------------------------------------------------------------------------
"""
Computer AI logic for Two-Man Spades
Handles all computer decision making including bidding, discarding, and play strategy
"""
import random
from .custom_rules import (
    get_discard_value, 
    is_special_card, 
    check_blind_bidding_eligibility,
    apply_blind_scoring
)

from .logging_utils import log_game_event

# =============================================================================
# GLOBAL AI DIFFICULTY SETTINGS
# =============================================================================

# Discard Strategy Settings
SINGLETON_SPECIAL_PRIORITY = 1000    # How much to prioritize discarding singleton 7â™¦/10â™£
VOID_CREATION_PRIORITY = 500         # How much to value creating voids
SPECIAL_CARD_PROTECTION = -100       # Penalty for discarding protected special cards
SPADE_DISCARD_PENALTY = 3           # Multiplier for avoiding spade discards
PARITY_CONSIDERATION = 1            # Small bonus for parity-favorable discards

# Bidding Strategy Settings  
BID_ACCURACY_BOOST = 0.8            # How much to boost base expectations (higher = more aggressive)
NIL_RISK_TOLERANCE = 0.8            # Threshold for nil bidding (lower = more nil attempts)
BLIND_DESPERATION_THRESHOLD = 120   # Points behind before considering blind bids
SCORE_BASED_ADJUSTMENT = 0.05       # How much score differential affects bidding
NIL_STRICTNESS = 0.8                # Lower = more likely to nil (minimum expectation for non-nil)

# Playing Strategy Settings
BAG_AVOIDANCE_STRENGTH = 0.92       # Multiplier when trying to avoid bags (lower = more avoidance)
SPECIAL_CARD_FOLLOWING_PROTECTION = True  # Whether to avoid playing special cards when following
LEAD_SAFETY_CONSIDERATION = True     # Whether to avoid leading into dangerous suits

# Meta-Strategy Settings
OPPONENT_MODELING = False            # Whether to try predicting opponent plays (future feature)
RISK_TAKING_PERSONALITY = 0.5       # 0.0 = very conservative, 1.0 = very aggressive
DEFAULT_BLIND_BID = 5

# =============================================================================
# HAND ANALYSIS FUNCTIONS
# =============================================================================

def analyze_hand_strength(hand):
    """
    Analyze hand strength and return expected trick count
    Returns tuple: (sure_tricks, probable_tricks, special_card_bonus)
    """
    sure_tricks = 0
    probable_tricks = 0
    special_card_bonus = 0
    
    # Count special cards for strategic value
    for card in hand:
        is_special, bag_reduction = is_special_card(card)
        if is_special:
            special_card_bonus += 0.2  # Special cards provide strategic value
    
    # Separate spades from other suits
    spades = [card for card in hand if card['suit'] == 'â™ ']
    other_suits = [card for card in hand if card['suit'] != 'â™ ']
    
    # Group other suits
    suits = {'â™¥': [], 'â™¦': [], 'â™£': []}
    for card in other_suits:
        suits[card['suit']].append(card)
    
    # ENHANCED SPADES ANALYSIS
    spade_values = sorted([card['value'] for card in spades], reverse=True)
    spade_count = len(spades)
    
    # Apply spade count expectations
    if spade_count >= 5:
        sure_tricks += 3.0  # Expect 5 tricks from 5+ spades
        probable_tricks += 2.0
    elif spade_count == 4:
        sure_tricks += 2.0  # Expect 3 tricks from 4 spades  
        probable_tricks += 1.0
    elif spade_count == 3:
        sure_tricks += 1.5  # Expect 2 tricks from 3 spades
        probable_tricks += 0.5
    elif spade_count == 2:
        sure_tricks += 0.8  # Modest expectation from 2 spades
        probable_tricks += 0.4
    elif spade_count == 1:
        sure_tricks += 0.3  # Low expectation from 1 spade
    
    # High spades get additional value on top of count-based expectations
    ace_spades = sum(1 for v in spade_values if v == 14)
    king_spades = sum(1 for v in spade_values if v == 13)
    queen_spades = sum(1 for v in spade_values if v == 12)
    
    if ace_spades > 0:
        sure_tricks += 0.3 * ace_spades  # Ace of spades is nearly guaranteed
    if king_spades > 0:
        sure_tricks += 0.2 * king_spades  # King of spades very likely
    if queen_spades > 0:
        probable_tricks += 0.2 * queen_spades  # Queen adds some value
    
    # ENHANCED OTHER SUITS ANALYSIS
    aces_other_suits = 0
    kings_other_suits = 0
    
    for suit, cards in suits.items():
        if not cards:
            continue
            
        values = sorted([card['value'] for card in cards], reverse=True)
        
        # Count high cards for overall hand strength
        aces_in_suit = sum(1 for v in values if v == 14)
        kings_in_suit = sum(1 for v in values if v == 13)
        
        aces_other_suits += aces_in_suit
        kings_other_suits += kings_in_suit
        
        # Aces in other suits (can be trumped but still strong)
        if 14 in values:
            sure_tricks += 0.8 * aces_in_suit  # High but not guaranteed
        
        # Protected kings (with ace)
        if 13 in values and 14 in values:
            sure_tricks += 0.6 * kings_in_suit  # Protected kings are strong
        elif 13 in values:
            if len(cards) >= 3:  # King in long suit has protection
                probable_tricks += 0.5 * kings_in_suit
            else:  # Unprotected king
                probable_tricks += 0.3 * kings_in_suit
        
        # Long suits can generate tricks through length
        if len(cards) >= 4:
            probable_tricks += (len(cards) - 3) * 0.25
    
    # MULTIPLE HIGH CARDS BONUS
    total_high_cards = aces_other_suits + kings_other_suits + ace_spades + king_spades
    
    if total_high_cards >= 4:
        sure_tricks += 0.5  # Multiple high cards create synergy
        probable_tricks += 0.3
    elif total_high_cards >= 3:
        sure_tricks += 0.3
        probable_tricks += 0.2
    elif total_high_cards >= 2:
        probable_tricks += 0.2
    
    # VOID SUITS (can trump)
    void_suits = sum(1 for cards in suits.values() if len(cards) == 0)
    if void_suits > 0 and spade_count >= 2:
        probable_tricks += void_suits * 0.4  # Void + spades = trumping opportunities
    
    return sure_tricks, probable_tricks, special_card_bonus

def analyze_suit_distribution(hand):
    """Analyze suit distribution and identify singleton/void opportunities"""
    suits = {'â™¥': [], 'â™¦': [], 'â™£': [], 'â™ ': []}
    
    for card in hand:
        suits[card['suit']].append(card)
    
    distribution = {}
    for suit, cards in suits.items():
        distribution[suit] = {
            'count': len(cards),
            'cards': cards,
            'is_void': len(cards) == 0,
            'is_singleton': len(cards) == 1
        }
    
    return distribution

# =============================================================================
# DISCARD STRATEGY
# =============================================================================

def computer_discard_strategy(computer_hand, game_state):
    """
    Enhanced discard strategy prioritizing singleton special cards and void creation
    Returns index of card to discard
    """
    player_parity = game_state.get('player_parity', 'even')
    computer_parity = game_state.get('computer_parity', 'odd')
    
    # Analyze suit distribution
    suit_distribution = analyze_suit_distribution(computer_hand)
    
    discard_candidates = []
    
    for i, card in enumerate(computer_hand):
        score = 0
        suit_info = suit_distribution[card['suit']]
        
        # PRIORITY 1: Singleton special cards - MUST discard these
        if suit_info['is_singleton'] and card['suit'] != 'â™ ':
            is_special, _ = is_special_card(card)
            if is_special:
                score += SINGLETON_SPECIAL_PRIORITY
                discard_candidates.append((i, score))
                continue  # Don't apply other penalties to singleton specials
        
        # PRIORITY 2: Void creation (singleton non-specials in non-spade suits)
        elif suit_info['is_singleton'] and card['suit'] != 'â™ ':
            spade_count = suit_distribution['â™ ']['count']
            # More spades = void is more valuable
            void_value = (spade_count * VOID_CREATION_PRIORITY) // 10
            if spade_count >= 4:  # Strong spade holding
                void_value += (VOID_CREATION_PRIORITY // 4)
            void_value -= card['value']  # Prefer discarding low cards
            score += void_value
        
        # PRIORITY 3: Normal special card protection (protected specials)
        else:
            is_special, _ = is_special_card(card)
            if is_special:
                score += SPECIAL_CARD_PROTECTION  # Negative score
        
        # PRIORITY 4: Avoid discarding spades
        if card['suit'] == 'â™ ':
            score -= card['value'] * SPADE_DISCARD_PENALTY
        else:
            # Prefer discarding low cards from other suits
            score += (15 - card['value'])
        
        # PRIORITY 5: Light parity consideration
        discard_value = get_discard_value(card)
        if computer_parity == 'even' and discard_value % 2 == 1:
            score += PARITY_CONSIDERATION
        elif computer_parity == 'odd' and discard_value % 2 == 0:
            score += PARITY_CONSIDERATION
        
        discard_candidates.append((i, score))
    
    # Return index of card with highest discard score
    return max(discard_candidates, key=lambda x: x[1])[0]

# =============================================================================
# BIDDING STRATEGY
# =============================================================================

def should_bid_nil(hand, game_state):
    """
    Determine if computer should bid nil (using configurable strictness)
    """
    player_score = game_state.get('player_score', 0)
    computer_score = game_state.get('computer_score', 0)
    player_bid = game_state.get('player_bid', 0)
    
    # Get hand strength
    sure_tricks, probable_tricks, special_bonus = analyze_hand_strength(hand)
    total_expectation = sure_tricks + probable_tricks + special_bonus
    
    # Use configurable nil threshold
    if total_expectation > NIL_STRICTNESS:
        return False
    
    # Must have very few spades and they must be low
    spades = [card for card in hand if card['suit'] == 'â™ ']
    if len(spades) > 3:  # At most 3 spades
        return False
    
    # No high spades allowed
    for spade in spades:
        if spade['value'] >= 11:  # No J, Q, K, A of spades
            return False
    
    # Must have at least 2 twos for safety
    twos = [card for card in hand if card['rank'] == '2']
    if len(twos) < 2:
        return False
    
    # Must have mostly very low cards (2-7) in other suits
    other_suits = [card for card in hand if card['suit'] != 'â™ ']
    low_cards = [card for card in other_suits if card['value'] <= 7]
    
    if len(low_cards) < len(other_suits) - 1:
        return False
    
    # No aces or kings in other suits
    high_other_suits = [card for card in other_suits if card['value'] >= 13]
    if len(high_other_suits) > 0:
        return False
    
    # Don't nil if player already bid nil
    if player_bid == 0:
        return False
    
    # Only nil when significantly behind
    if computer_score >= player_score - 50:
        return False
    
    # Conservative probability - only when truly desperate
    return computer_score < player_score - 80

def should_bid_blind(hand, game_state):
    """
    Determine if computer should bid blind when eligible
    Returns tuple: (should_blind, blind_bid_amount)
    """
    player_score = game_state.get('player_score', 0)
    computer_score = game_state.get('computer_score', 0)
    
    # Check eligibility
    blind_eligibility = check_blind_bidding_eligibility(player_score, computer_score)
    if not blind_eligibility['computer_eligible']:
        return False, 0
    
    # If down by 100+, just go blind 5 (simplest aggressive strategy)
    return True, DEFAULT_BLIND_BID

def computer_bidding_brain(computer_hand, player_bid, game_state):
    """
    Main computer bidding function with configurable AI settings
    Returns tuple: (bid_amount, is_blind)
    """
    player_score = game_state.get('player_score', 0)
    computer_score = game_state.get('computer_score', 0)
    computer_bags = game_state.get('computer_bags', 0)
    
    # Check for nil opportunity first
    if should_bid_nil(computer_hand, game_state):
        return 0, False
    
    # Check for blind bidding opportunity
    should_blind, blind_amount = should_bid_blind(computer_hand, game_state)
    if should_blind:
        return blind_amount, True
    
    # Regular bidding logic
    sure_tricks, probable_tricks, special_bonus = analyze_hand_strength(computer_hand)
    base_expectation = sure_tricks + probable_tricks + special_bonus
    
    # Apply configurable accuracy boost
    base_expectation += BID_ACCURACY_BOOST
    
    # Score-based adjustments (using configurable multiplier)
    score_diff = computer_score - player_score
    if score_diff > 30:  # Ahead - be slightly conservative
        base_expectation *= (1 - SCORE_BASED_ADJUSTMENT)
    elif score_diff < -30:  # Behind - be slightly aggressive
        base_expectation *= (1 + SCORE_BASED_ADJUSTMENT)
    
    # Bag avoidance when close to penalty
    if computer_bags >= 5:
        base_expectation *= BAG_AVOIDANCE_STRENGTH
    
    # Strategic response to player's bid
    if player_bid is not None:
        if player_bid == 0:  # Player nil - be aggressive to set them
            base_expectation += 0.3
        elif player_bid <= 2:  # Player bid low
            base_expectation += 0.15
        elif player_bid >= 7:  # Player bid high
            base_expectation -= 0.2
    
    # Convert to bid
    raw_bid = max(0, min(10, round(base_expectation)))
    
    # Bid range preferences
    if 2.5 <= base_expectation <= 5.5:
        if raw_bid < 3:
            raw_bid = 3  # Minimum reasonable bid is 3
        elif raw_bid == 5 and random.random() < 0.4:
            raw_bid = 4  # Sometimes prefer 4 over 5
    
    # Avoid obvious total-10 scenarios
    if player_bid is not None and abs((raw_bid + player_bid) - 10) <= 1 and random.random() < 0.3:
        if raw_bid > 3:
            raw_bid -= 1
        elif raw_bid < 7:
            raw_bid += 1
    
    # Final bounds check
    raw_bid = max(1, min(10, raw_bid))
    
    return raw_bid, False

# =============================================================================
# PLAYING STRATEGY
# =============================================================================

def computer_lead_strategy(computer_hand, spades_broken):
    """
    Enhanced leading strategy - avoid leading into special cards when possible
    Returns index of best card to lead, or None if no valid leads
    """
    if not computer_hand:
        return None
    
    # Find all valid leads
    valid_leads = []
    for i, card in enumerate(computer_hand):
        if card['suit'] != 'â™ ' or spades_broken or all(c['suit'] == 'â™ ' for c in computer_hand):
            valid_leads.append((i, card))
    
    if not valid_leads:
        return None
    
    # Categorize leads by danger level (if safety consideration is enabled)
    if LEAD_SAFETY_CONSIDERATION:
        safe_leads = []
        risky_leads = []
        dangerous_leads = []
        
        for i, card in valid_leads:
            suit = card['suit']
            rank = card['rank']
            
            # Check if leading this suit could give opponent special cards
            if suit == 'â™£':
                # Leading clubs could set up 10â™£ for opponent
                if rank in ['J', 'Q', 'K', 'A']:
                    dangerous_leads.append((i, card))
                elif rank in ['8', '9', '10']:
                    risky_leads.append((i, card))
                else:
                    safe_leads.append((i, card))
            elif suit == 'â™¦':
                # Leading diamonds could set up 7â™¦ for opponent  
                if rank in ['J', 'Q', 'K', 'A']:
                    dangerous_leads.append((i, card))
                elif rank in ['6', '7', '8']:
                    risky_leads.append((i, card))
                else:
                    safe_leads.append((i, card))
            else:
                # Hearts and spades are generally safer
                safe_leads.append((i, card))
        
        # Choose lead in order of preference: safe > risky > dangerous
        if safe_leads:
            chosen = min(safe_leads, key=lambda x: x[1]['value'])
        elif risky_leads:
            chosen = min(risky_leads, key=lambda x: x[1]['value'])
        else:
            chosen = min(dangerous_leads, key=lambda x: x[1]['value'])
    else:
        # Simple strategy - just lead lowest valid card
        chosen = min(valid_leads, key=lambda x: x[1]['value'])
    
    return chosen[0]

def computer_follow_strategy(computer_hand, current_trick, game_state):
    """
    Enhanced strategy for when computer must follow suit - includes bag avoidance and special card protection
    Returns index of best card to play
    """
    if not current_trick or not computer_hand:
        return None
    
    computer_bid = game_state.get('computer_bid', 0)
    computer_tricks = game_state.get('computer_tricks', 0)
    
    # Check if computer has already made their bid
    bid_already_made = computer_tricks >= computer_bid and computer_bid > 0
    
    lead_card = current_trick[0]['card']
    lead_suit = lead_card['suit']
    lead_value = lead_card['value']
    
    # Find valid plays and categorize by special card status
    same_suit = []
    same_suit_special = []
    spades = []
    spades_special = []
    other = []
    other_special = []
    
    for i, card in enumerate(computer_hand):
        is_special, _ = is_special_card(card)
        
        if card['suit'] == lead_suit:
            if is_special:
                same_suit_special.append((i, card))
            else:
                same_suit.append((i, card))
        elif card['suit'] == 'â™ ':
            if is_special:
                spades_special.append((i, card))
            else:
                spades.append((i, card))
        else:
            if is_special:
                other_special.append((i, card))
            else:
                other.append((i, card))
    
    # Combine same suit cards (prioritize non-special if protection is enabled)
    if SPECIAL_CARD_FOLLOWING_PROTECTION:
        all_same_suit = same_suit + same_suit_special
        all_spades = spades + spades_special
        all_other = other + other_special
    else:
        all_same_suit = same_suit_special + same_suit
        all_spades = spades_special + spades
        all_other = other_special + other
    
    if all_same_suit:
        # Must follow suit
        winners = [(i, c) for i, c in all_same_suit if c['value'] > lead_value]
        losers = [(i, c) for i, c in all_same_suit if c['value'] <= lead_value]
        
        if SPECIAL_CARD_FOLLOWING_PROTECTION:
            # Separate special cards from regular cards in each category
            winners_regular = [(i, c) for i, c in winners if not is_special_card(c)[0]]
            winners_special = [(i, c) for i, c in winners if is_special_card(c)[0]]
            losers_regular = [(i, c) for i, c in losers if not is_special_card(c)[0]]
            losers_special = [(i, c) for i, c in losers if is_special_card(c)[0]]
            
            if bid_already_made:
                # Try to avoid winning (avoid bags), protect special cards
                if losers_regular:
                    return max(losers_regular, key=lambda x: x[1]['value'])[0]
                elif losers_special:
                    return max(losers_special, key=lambda x: x[1]['value'])[0]
                elif winners_regular:
                    return min(winners_regular, key=lambda x: x[1]['value'])[0]
                else:
                    return min(winners_special, key=lambda x: x[1]['value'])[0]
            else:
                # Still need tricks - try to win, avoid wasting special cards
                if winners_regular:
                    return min(winners_regular, key=lambda x: x[1]['value'])[0]
                elif winners_special:
                    return min(winners_special, key=lambda x: x[1]['value'])[0]
                elif losers_regular:
                    return min(losers_regular, key=lambda x: x[1]['value'])[0]
                else:
                    return min(losers_special, key=lambda x: x[1]['value'])[0]
        else:
            # Simple strategy without special card protection
            if bid_already_made:
                if losers:
                    return max(losers, key=lambda x: x[1]['value'])[0]
                else:
                    return min(winners, key=lambda x: x[1]['value'])[0]
            else:
                if winners:
                    return min(winners, key=lambda x: x[1]['value'])[0]
                else:
                    return min(losers, key=lambda x: x[1]['value'])[0]
                
    elif lead_suit != 'â™ ' and all_spades:
        # Can trump with spade
        if bid_already_made:
            # Try to avoid trumping unless forced
            if all_other:
                if SPECIAL_CARD_FOLLOWING_PROTECTION:
                    non_special_other = [x for x in all_other if not is_special_card(x[1])[0]]
                    if non_special_other:
                        return min(non_special_other, key=lambda x: x[1]['value'])[0]
                    else:
                        return min(all_other, key=lambda x: x[1]['value'])[0]
                else:
                    return min(all_other, key=lambda x: x[1]['value'])[0]
            else:
                # Must trump
                if SPECIAL_CARD_FOLLOWING_PROTECTION:
                    non_special_spades = [x for x in all_spades if not is_special_card(x[1])[0]]
                    if non_special_spades:
                        return min(non_special_spades, key=lambda x: x[1]['value'])[0]
                    else:
                        return min(all_spades, key=lambda x: x[1]['value'])[0]
                else:
                    return min(all_spades, key=lambda x: x[1]['value'])[0]
        else:
            # Still need tricks - trump but protect special cards if possible
            if SPECIAL_CARD_FOLLOWING_PROTECTION:
                non_special_spades = [x for x in all_spades if not is_special_card(x[1])[0]]
                if non_special_spades:
                    return min(non_special_spades, key=lambda x: x[1]['value'])[0]
                else:
                    return min(all_spades, key=lambda x: x[1]['value'])[0]
            else:
                return min(all_spades, key=lambda x: x[1]['value'])[0]
    else:
        # Can't follow or trump - discard lowest
        if SPECIAL_CARD_FOLLOWING_PROTECTION:
            non_special_other = [x for x in all_other if not is_special_card(x[1])[0]]
            if non_special_other:
                return min(non_special_other, key=lambda x: x[1]['value'])[0]
            else:
                all_cards = [(i, c) for i, c in enumerate(computer_hand)]
                return min(all_cards, key=lambda x: x[1]['value'])[0]
        else:
            all_cards = [(i, c) for i, c in enumerate(computer_hand)]
            return min(all_cards, key=lambda x: x[1]['value'])[0]

# =============================================================================
# DIFFICULTY ADJUSTMENT FUNCTIONS (Future Enhancement)
# =============================================================================

def set_difficulty_easy():
    """Set all AI parameters for easy difficulty"""
    global SINGLETON_SPECIAL_PRIORITY, VOID_CREATION_PRIORITY, BID_ACCURACY_BOOST
    global NIL_RISK_TOLERANCE, SPECIAL_CARD_FOLLOWING_PROTECTION
    
    # Make poor decisions
    SINGLETON_SPECIAL_PRIORITY = 50  # Sometimes keeps singleton specials
    VOID_CREATION_PRIORITY = 100     # Doesn't prioritize voids much
    BID_ACCURACY_BOOST = 0.2         # Under-bids frequently
    NIL_RISK_TOLERANCE = 1.5         # Rarely goes nil
    SPECIAL_CARD_FOLLOWING_PROTECTION = False  # Doesn't protect specials

def set_difficulty_hard():
    """Set all AI parameters for hard difficulty"""
    global SINGLETON_SPECIAL_PRIORITY, VOID_CREATION_PRIORITY, BID_ACCURACY_BOOST
    global NIL_RISK_TOLERANCE, SPECIAL_CARD_FOLLOWING_PROTECTION
    
    # Optimal play
    SINGLETON_SPECIAL_PRIORITY = 1000
    VOID_CREATION_PRIORITY = 500
    BID_ACCURACY_BOOST = 0.8
    NIL_RISK_TOLERANCE = 0.8
    SPECIAL_CARD_FOLLOWING_PROTECTION = True

def set_difficulty_custom(settings_dict):
    """Set AI parameters from a dictionary"""
    globals().update(settings_dict)


def autoplay_remaining_cards(game, session_obj=None):
    """
    Check for mathematically certain scenarios and auto-resolve remaining tricks.
    Only auto-resolves when 3-9 cards remain to preserve engagement.
    Returns (was_auto_resolved, explanation)
    """
    player_hand_size = len(game['player_hand'])
    computer_hand_size = len(game['computer_hand'])
    
    # Only auto-resolve if 3-9 cards remain (don't auto-play final 1-2 tricks)
    if player_hand_size == 0 or computer_hand_size == 0:
        return False, ""
    if player_hand_size < 3 or player_hand_size > 9:
        return False, ""
    
    player_suits = set(card['suit'] for card in game['player_hand'])
    computer_suits = set(card['suit'] for card in game['computer_hand'])
    winner = game.get('trick_winner')
    
    auto_resolved = False
    explanation = ""
    tricks_to_award = 0
    
    # Case 1: One player only spades, other no spades
    if player_suits == {'â™ '} and 'â™ ' not in computer_suits:
        tricks_to_award = len(game['player_hand'])
        game['player_tricks'] += tricks_to_award
        auto_resolved = True
        explanation = f"Auto-resolved: You had only spades ({tricks_to_award} cards), Marta had none"
        winner_of_remaining = 'player'
    elif computer_suits == {'â™ '} and 'â™ ' not in player_suits:
        tricks_to_award = len(game['computer_hand'])
        game['computer_tricks'] += tricks_to_award
        auto_resolved = True
        explanation = f"Auto-resolved: Marta had only spades ({tricks_to_award} cards), you had none"
        winner_of_remaining = 'computer'
    # Case 2: Trick winner has one suit, loser has none of it and no spades
    elif winner == 'player' and len(player_suits) == 1:
        player_suit = list(player_suits)[0]
        if player_suit not in computer_suits and 'â™ ' not in computer_suits:
            tricks_to_award = len(game['player_hand'])
            game['player_tricks'] += tricks_to_award
            auto_resolved = True
            explanation = f"Auto-resolved: You had only {player_suit} ({tricks_to_award} cards), Marta had none and no spades"
            winner_of_remaining = 'player'
    elif winner == 'computer' and len(computer_suits) == 1:
        computer_suit = list(computer_suits)[0]
        if computer_suit not in player_suits and 'â™ ' not in player_suits:
            tricks_to_award = len(game['computer_hand'])
            game['computer_tricks'] += tricks_to_award
            auto_resolved = True
            explanation = f"Auto-resolved: Marta had only {computer_suit} ({tricks_to_award} cards), you had none and no spades"
            winner_of_remaining = 'computer'
    
    if auto_resolved:
        # Simulate the remaining tricks and add to history
        player_cards = game['player_hand'].copy()
        computer_cards = game['computer_hand'].copy()
        current_trick_number = len(game.get('trick_history', [])) + 1
        
        # Log console message for auto-resolution
        print(f"AUTO-RESOLVE: {explanation}")
        
        # Play out remaining tricks in any order since outcome is predetermined
        while player_cards and computer_cards:
            # Just take first card from each hand (order doesn't matter)
            player_card = player_cards.pop(0)
            computer_card = computer_cards.pop(0)
            
            # Add to trick history
            game.setdefault('trick_history', []).append({
                'number': current_trick_number,
                'player_card': player_card,
                'computer_card': computer_card,
                'winner': winner_of_remaining  # Predetermined winner
            })
            
            # Log each auto-played trick to console
            p_text = f"{player_card['rank']}{player_card['suit']}"
            c_text = f"{computer_card['rank']}{computer_card['suit']}"
            winner_name = "You" if winner_of_remaining == 'player' else "Marta"
            print(f"AUTO-TRICK {current_trick_number}: {p_text} vs {c_text} -> {winner_name} wins")
            
            current_trick_number += 1
        
        # Clear hands and mark as over
        game['player_hand'] = []
        game['computer_hand'] = []
        game['hand_over'] = True
        
        # Log the auto-resolution
        if session_obj:
            log_game_event(
                event_type='hand_auto_resolved',
                event_data={
                    'explanation': explanation,
                    'tricks_simulated': tricks_to_award,
                    'cards_remaining_when_triggered': player_hand_size,
                    'final_player_tricks': game['player_tricks'],
                    'final_computer_tricks': game['computer_tricks']
                },
                session=session_obj
            )
    
    return auto_resolved, explanation

================================================================================

FILE: ./utilities/logging_utils.py
--------------------------------------------------------------------------------
"""
Streamlined logging utilities for Two-Man Spades - WRITE-ONLY approach
Logs everything for historical analysis but NEVER reads/loads existing files during normal operation
All logging is append-only for performance - reading is only available via explicit debug endpoints
"""
import time
import uuid
import json
import os
import platform
from datetime import datetime

# =============================================================================
# GLOBAL LOGGING CONFIGURATION
# =============================================================================

# Environment detection
IS_LOCAL_DEVELOPMENT = os.environ.get('GAE_ENV') != 'standard'
IS_PRODUCTION = not IS_LOCAL_DEVELOPMENT

LOGGING_ENABLED = True
LOG_TO_CONSOLE = True
LOG_TO_FILE = IS_LOCAL_DEVELOPMENT
LOG_GAME_ACTIONS = True
LOG_AI_DECISIONS = True
LOG_AI_ANALYSIS = True
LOG_GAME_EVENTS = True
CONSOLE_LOG_LEVEL = 'ALL'  # 'ALL', 'ACTIONS_ONLY', 'AI_ONLY', 'EVENTS_ONLY', 'OFF'
LOGS_DIRECTORY = 'logging' if IS_LOCAL_DEVELOPMENT else None
CURRENT_LOG_FILE = None

# Production logging placeholder
PRODUCTION_LOG_PLACEHOLDER = "[PRODUCTION] Log entry saved to pending database implementation"

# =============================================================================
# CLIENT IP TRACKING FUNCTIONS
# =============================================================================

def get_client_ip(request):
    """Get the client's real IP address, preferring IPv4 when available from the same client."""
    
    # Get all potential IPs from various headers
    potential_ips = []
    
    # Check X-Forwarded-For (most common)
    forwarded = request.headers.get('X-Forwarded-For')
    if forwarded:
        potential_ips.extend([ip.strip() for ip in forwarded.split(',')])
    
    # Check other common headers
    for header in ['X-Real-IP', 'X-Client-IP']:
        ip = request.headers.get(header)
        if ip:
            potential_ips.append(ip.strip())
    
    # Add the direct connection IP
    if request.remote_addr:
        potential_ips.append(request.remote_addr)
    
    if not potential_ips:
        return 'unknown'
    
    # Filter out obviously internal/load balancer IPs
    filtered_ips = []
    for ip in potential_ips:
        # Skip Google/AWS internal IPs and private ranges
        if not ip.startswith(('169.254.', '10.', '192.168.', '172.', '127.')):
            filtered_ips.append(ip)
    
    if not filtered_ips:
        # If all IPs were filtered, use the first original IP
        return potential_ips[0]
    
    # Prefer IPv4 from the filtered list
    ipv4_ips = [ip for ip in filtered_ips if '.' in ip and ':' not in ip]
    if ipv4_ips:
        return ipv4_ips[0]
    
    # Fall back to first filtered IP (likely IPv6)
    return filtered_ips[0]

def get_client_info(request):
    """Get comprehensive client information for logging."""
    client_ip = get_client_ip(request)
    
    return {
        'ip_address': client_ip,
        'user_agent': request.headers.get('User-Agent', 'unknown'),
        'referer': request.headers.get('Referer', 'none'),
        'method': request.method,
        'endpoint': request.endpoint,
        'is_local': client_ip.startswith('127.') or client_ip.startswith('192.168.') or client_ip == 'localhost'
    }

def track_session_client(session, request):
    """Track client info in session for persistent identification."""
    client_info = get_client_info(request)
    
    session_client = {
        'ip_address': client_info['ip_address'],
        'first_seen': session.get('client_first_seen', time.time()),
        'last_seen': time.time(),
        'session_actions': session.get('client_actions', 0) + 1
    }
    
    session['client_info'] = session_client
    session['client_actions'] = session_client['session_actions'] 
    session['client_first_seen'] = session_client['first_seen']
    session.modified = True
    
    return session_client

def get_session_client_summary(session):
    """Get summary of client activity for this session."""
    client_info = session.get('client_info', {})
    
    if client_info:
        session_duration = time.time() - session.get('client_first_seen', time.time())
        return {
            'ip_address': client_info.get('ip_address', 'unknown'),
            'actions_this_session': session.get('client_actions', 0),
            'session_duration_minutes': round(session_duration / 60, 1),
            'first_seen': datetime.fromtimestamp(session.get('client_first_seen', 0)).strftime('%H:%M:%S')
        }
    
    return None

# =============================================================================
# FILE MANAGEMENT FUNCTIONS - WRITE ONLY
# =============================================================================

def _ensure_logs_directory():
    """Ensure the logging directory exists - only in local development, no scanning"""
    if not IS_LOCAL_DEVELOPMENT:
        return
        
    if LOGS_DIRECTORY and not os.path.exists(LOGS_DIRECTORY):
        os.makedirs(LOGS_DIRECTORY)

def _generate_log_filename(game_id, timestamp=None):
    """Generate a unique log filename for a game - only used in local development"""
    if not IS_LOCAL_DEVELOPMENT:
        return None
        
    if timestamp is None:
        timestamp = datetime.now()
    
    date_str = timestamp.strftime("%Y%m%d")
    time_str = timestamp.strftime("%H%M%S")
    short_game_id = game_id[:8] if game_id else "unknown"
    
    return f"game_log_{date_str}_{time_str}_{short_game_id}.json"

def _start_new_log_file(game_id):
    """Start a new log file for a game - WRITE ONLY, no existing file checking"""
    global CURRENT_LOG_FILE
    
    if not IS_LOCAL_DEVELOPMENT:
        return
    
    if not LOG_TO_FILE:
        return
    
    _ensure_logs_directory()  # Only creates if missing, no scanning
    
    filename = _generate_log_filename(game_id)
    CURRENT_LOG_FILE = os.path.join(LOGS_DIRECTORY, filename)
    
    # Initialize with game metadata
    initial_entry = {
        'log_type': 'game_metadata',
        'data': {
            'game_id': game_id,
            'log_file_created': datetime.now().isoformat(),
            'log_version': '2.0',
            'game_type': 'two_man_spades',
            'environment': 'local_development'
        }
    }
    
    try:
        # Write initial entry - no reading of existing files
        with open(CURRENT_LOG_FILE, 'w') as f:
            json.dump([initial_entry], f, indent=2, default=str)
        
        if LOG_TO_CONSOLE:
            print(f"Started new game log: {filename}")
        
    except Exception as e:
        if LOG_TO_CONSOLE:
            print(f"Warning: Could not create new log file: {e}")
        CURRENT_LOG_FILE = None

def _write_to_current_log_file(log_entry):
    """Write log entry to current game's log file - APPEND ONLY"""
    if not IS_LOCAL_DEVELOPMENT or not LOG_TO_FILE or not CURRENT_LOG_FILE:
        return
    
    try:
        # APPEND-ONLY approach - read existing, append new, write back
        logs = []
        if os.path.exists(CURRENT_LOG_FILE):
            try:
                with open(CURRENT_LOG_FILE, 'r') as f:
                    logs = json.load(f)
            except (json.JSONDecodeError, IOError):
                logs = []  # Start fresh if file is corrupted
        
        logs.append(log_entry)
        
        with open(CURRENT_LOG_FILE, 'w') as f:
            json.dump(logs, f, indent=2, default=str)
            
    except Exception as e:
        if LOG_TO_CONSOLE:
            print(f"Warning: Could not write to log file: {e}")

def _finalize_current_log_file(final_game_state):
    """Add final game metadata and close current log file"""
    if not IS_LOCAL_DEVELOPMENT or not CURRENT_LOG_FILE:
        return
        
    finalization_entry = {
        'log_type': 'game_finalization',
        'data': {
            'game_completed_at': datetime.now().isoformat(),
            'final_scores': {
                'player_score': final_game_state.get('player_score', 0),
                'computer_score': final_game_state.get('computer_score', 0)
            },
            'winner': final_game_state.get('winner'),
            'hands_played': final_game_state.get('hand_number', 1),
            'environment': 'local_development'
        }
    }
    
    _write_to_current_log_file(finalization_entry)
    
    if LOG_TO_CONSOLE:
        print(f"Finalized game log: {os.path.basename(CURRENT_LOG_FILE)}")

# =============================================================================
# GAME INITIALIZATION - STREAMLINED
# =============================================================================

def initialize_game_logging(game):
    """Initialize logging structures and start new log file for a new game - NO FILE SCANNING"""
    # Use Unix timestamp with microsecond precision as game ID for easy time correlation
    game_id = str(int(time.time() * 1000000))
    hand_id = str(uuid.uuid4())
    
    game.update({
        'game_id': game_id,
        'current_hand_id': hand_id,
        'game_started_at': time.time(),
        'action_sequence': 0
    })
    
    # Start new log file - NO scanning of existing files
    _start_new_log_file(game_id)
    
    # Log game initialization
    _write_to_current_log_file({
        'log_type': 'game_init',
        'data': {
            'game_id': game_id,
            'started_at': time.time(),
            'player_parity': game.get('player_parity'),
            'computer_parity': game.get('computer_parity'),
            'first_leader': game.get('first_leader')
        }
    })
    
    return game

def initialize_game_logging_with_client(game, request=None):
    """Enhanced game initialization with client tracking - NO FILE SCANNING"""
    game = initialize_game_logging(game)
    
    if request:
        client_info = get_client_info(request)
        game['client_info'] = client_info
        
        # Console output only
        if LOG_TO_CONSOLE:
            print(f"NEW GAME STARTED by {client_info['ip_address']}")
            print(f"   Game ID: {game.get('game_id', 'unknown')}")
    
    return game

def finalize_game_logging(game):
    """Called when a game ends to finalize the log file"""
    _finalize_current_log_file(game)

def start_new_hand_logging(game):
    """Generate new hand ID and log hand start"""
    hand_id = str(uuid.uuid4())
    game['current_hand_id'] = hand_id

# =============================================================================
# CORE LOGGING FUNCTIONS - WRITE ONLY
# =============================================================================

def log_action(action_type, player, action_data, session=None, additional_context=None, request=None):
    """Central logging function for all player/system game actions with optional client tracking"""
    if not LOGGING_ENABLED or not LOG_GAME_ACTIONS:
        return
    
    client_info = get_client_info(request) if request else None
    action_record = _build_action_record(action_type, player, action_data, session, additional_context)
    
    if client_info:
        action_record['client_info'] = client_info
    
    _write_to_current_log_file({
        'log_type': 'action',
        'data': action_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'ACTIONS_ONLY']:
        _print_action_log(action_record)

def log_ai_decision(decision_type, decision_data, analysis=None, reasoning=None, session=None):
    """Central logging function for AI decision-making process"""
    if not LOGGING_ENABLED or not LOG_AI_DECISIONS:
        return
    
    decision_record = _build_ai_decision_record(decision_type, decision_data, analysis, reasoning)
    
    _write_to_current_log_file({
        'log_type': 'ai_decision',
        'data': decision_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'AI_ONLY']:
        _print_ai_decision_log(decision_record)

def log_game_event(event_type, event_data, session=None):
    """Central logging function for major game events"""
    if not LOGGING_ENABLED or not LOG_GAME_EVENTS:
        return
    
    event_record = _build_event_record(event_type, event_data, session)
    
    _write_to_current_log_file({
        'log_type': 'game_event',
        'data': event_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'EVENTS_ONLY']:
        _print_event_log(event_record)

def log_ai_analysis(analysis_type, analysis_data, session=None):
    """Log detailed AI analysis with structured data"""
    if not LOGGING_ENABLED or not LOG_AI_ANALYSIS:
        return
    
    analysis_record = {
        'timestamp': time.time(),
        'analysis_type': analysis_type,
        'analysis_data': analysis_data
    }
    
    _write_to_current_log_file({
        'log_type': 'ai_analysis',
        'data': analysis_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'AI_ONLY']:
        _print_ai_analysis_log(analysis_record)

def log_ai_strategy(strategy_type, strategy_data, session=None):
    """Log AI strategy decisions and evaluations"""
    if not LOGGING_ENABLED or not LOG_AI_ANALYSIS:
        return
    
    strategy_record = {
        'timestamp': time.time(),
        'strategy_type': strategy_type,
        'strategy_data': strategy_data
    }
    
    _write_to_current_log_file({
        'log_type': 'ai_strategy',
        'data': strategy_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'AI_ONLY']:
        _print_ai_strategy_log(strategy_record)

def log_ai_evaluation(evaluation_type, candidates, chosen_candidate, session=None):
    """Log AI evaluation of multiple options"""
    if not LOGGING_ENABLED or not LOG_AI_ANALYSIS:
        return
    
    evaluation_record = {
        'timestamp': time.time(),
        'evaluation_type': evaluation_type,
        'candidates_evaluated': len(candidates),
        'all_candidates': candidates,
        'chosen_candidate': chosen_candidate,
        'confidence': _calculate_evaluation_confidence(candidates, chosen_candidate)
    }
    
    _write_to_current_log_file({
        'log_type': 'ai_evaluation',
        'data': evaluation_record
    })
    
    if LOG_TO_CONSOLE and CONSOLE_LOG_LEVEL in ['ALL', 'AI_ONLY']:
        _print_ai_evaluation_log(evaluation_record)

# =============================================================================
# INTERNAL HELPER FUNCTIONS
# =============================================================================

def _build_action_record(action_type, player, action_data, session, additional_context):
    """Build standardized action record"""
    game = session['game'] if session and 'game' in session else {}
    
    game['action_sequence'] = game.get('action_sequence', 0) + 1
    
    return {
        'sequence': game['action_sequence'],
        'timestamp': time.time(),
        'game_id': game.get('game_id'),
        'hand_id': game.get('current_hand_id'),
        'action_type': action_type,
        'player': player,
        'hand_number': game.get('hand_number', 1),
        'phase': game.get('phase', 'unknown'),
        'action_data': action_data,
        'game_context': {
            'player_score': game.get('player_score', 0),
            'computer_score': game.get('computer_score', 0),
            'player_tricks': game.get('player_tricks', 0),
            'computer_tricks': game.get('computer_tricks', 0),
            'player_bags': game.get('player_bags', 0),
            'computer_bags': game.get('computer_bags', 0),
            'spades_broken': game.get('spades_broken', False),
            'turn': game.get('turn'),
            'trick_leader': game.get('trick_leader')
        },
        'additional_context': additional_context
    }

def _build_ai_decision_record(decision_type, decision_data, analysis, reasoning):
    """Build standardized AI decision record"""
    return {
        'timestamp': time.time(),
        'decision_type': decision_type,
        'decision_data': decision_data,
        'analysis': analysis,
        'reasoning': reasoning,
        'confidence': _calculate_confidence(decision_type, decision_data, analysis)
    }

def _build_event_record(event_type, event_data, session):
    """Build standardized event record"""
    game = session['game'] if session and 'game' in session else {}
    
    return {
        'timestamp': time.time(),
        'game_id': game.get('game_id'),
        'hand_id': game.get('current_hand_id'),
        'event_type': event_type,
        'hand_number': game.get('hand_number', 1),
        'event_data': event_data
    }

def _calculate_confidence(decision_type, decision_data, analysis):
    """Calculate confidence score for AI decisions"""
    if not analysis:
        return 0.5
    
    if decision_type == 'bid':
        expected_tricks = analysis.get('base_expectation', 0)
        bid_amount = decision_data.get('bid_amount', 0)
        diff = abs(expected_tricks - bid_amount)
        return max(0.0, min(1.0, 1.0 - (diff / 5.0)))
    
    elif decision_type == 'discard_choice':
        chosen_score = decision_data.get('final_score', 0)
        if chosen_score >= 1000:
            return 1.0
        elif chosen_score >= 500:
            return 0.9
        else:
            return 0.6
    
    return 0.5

def _calculate_evaluation_confidence(candidates, chosen_candidate):
    """Calculate confidence for AI evaluations"""
    if not candidates or len(candidates) < 2:
        return 1.0
    
    if isinstance(chosen_candidate, dict) and 'score' in chosen_candidate:
        try:
            scores = [c.get('score', 0) for c in candidates if isinstance(c, dict)]
            if scores and len(scores) >= 2:
                best_score = max(scores)
                second_best = sorted(scores, reverse=True)[1]
                if best_score > 0:
                    confidence = min(1.0, (best_score - second_best) / best_score)
                    return max(0.1, confidence)
        except:
            pass
    
    return max(0.3, 1.0 - (len(candidates) * 0.1))

# =============================================================================
# CONSOLE OUTPUT FUNCTIONS
# =============================================================================

def _print_action_log(action_record):
    """Print action log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(action_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"=== ACTION #{action_record['sequence']}: {action_record['action_type'].upper()} by {action_record['player'].upper()} ===")
    print(f"Hand #{action_record['hand_number']} | Phase: {action_record['phase']} | Time: {timestamp_str}")
    print(f"Data: {action_record['action_data']}")
    
    ctx = action_record['game_context']
    print(f"Context: Score {ctx['player_score']}-{ctx['computer_score']} | Tricks {ctx['player_tricks']}-{ctx['computer_tricks']} | Bags {ctx['player_bags']}-{ctx['computer_bags']}")
    
    if action_record.get('additional_context'):
        print(f"Extra: {action_record['additional_context']}")
    
    print("=" * 60)

def _print_ai_decision_log(decision_record):
    """Print AI decision log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(decision_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"AI DECISION: {decision_record['decision_type'].upper()}")
    print(f"Time: {timestamp_str} | Confidence: {decision_record['confidence']:.2f}")
    print(f"Decision: {decision_record['decision_data']}")
    
    if decision_record.get('analysis'):
        print(f"Analysis: {decision_record['analysis']}")
    
    if decision_record.get('reasoning'):
        print(f"Reasoning: {decision_record['reasoning']}")
    
    print("=" * 58)

def _print_event_log(event_record):
    """Print game event log to console with formatting"""
    print(f"GAME EVENT: {event_record['event_type'].upper()}")
    print(f"Hand #{event_record['hand_number']} | Data: {event_record['event_data']}")
    print("*" * 40)

def _print_ai_analysis_log(analysis_record):
    """Print AI analysis log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(analysis_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"AI ANALYSIS: {analysis_record['analysis_type'].upper()}")
    print(f"Time: {timestamp_str}")
    
    for key, value in analysis_record['analysis_data'].items():
        if isinstance(value, (int, float)):
            print(f"  {key}: {value:.2f}")
        else:
            print(f"  {key}: {value}")
    
    print("-" * 40)

def _print_ai_strategy_log(strategy_record):
    """Print AI strategy log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(strategy_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"AI STRATEGY: {strategy_record['strategy_type'].upper()}")
    print(f"Time: {timestamp_str}")
    print(f"Strategy: {strategy_record['strategy_data']}")
    print("-" * 40)

def _print_ai_evaluation_log(evaluation_record):
    """Print AI evaluation log to console with formatting"""
    timestamp_str = datetime.fromtimestamp(evaluation_record['timestamp']).strftime('%H:%M:%S.%f')[:-3]
    
    print(f"AI EVALUATION: {evaluation_record['evaluation_type'].upper()}")
    print(f"Time: {timestamp_str} | Confidence: {evaluation_record['confidence']:.2f}")
    print(f"Evaluated {evaluation_record['candidates_evaluated']} options")
    print(f"Chosen: {evaluation_record['chosen_candidate']}")
    
    top_candidates = evaluation_record['all_candidates'][:3]
    for i, candidate in enumerate(top_candidates):
        print(f"  #{i+1}: {candidate}")
    
    if len(evaluation_record['all_candidates']) > 3:
        print(f"  ... and {len(evaluation_record['all_candidates']) - 3} more")
    
    print("-" * 40)

# =============================================================================
# DEBUG ENDPOINTS - FILE READING ONLY ON DEMAND
# =============================================================================

def get_environment_info():
    """Get information about the current environment - NO FILE READING"""
    return {
        'is_local_development': IS_LOCAL_DEVELOPMENT,
        'is_production': IS_PRODUCTION,
        'file_logging_enabled': LOG_TO_FILE,
        'console_logging_enabled': LOG_TO_CONSOLE,
        'gae_env': os.environ.get('GAE_ENV', 'Not set'),
        'platform': platform.system(),
        'logs_directory': LOGS_DIRECTORY,
        'current_log_file': os.path.basename(CURRENT_LOG_FILE) if CURRENT_LOG_FILE else None
    }

def get_logging_summary():
    """Get summary of current session only - NO FILE READING"""
    return {
        'current_log_file': os.path.basename(CURRENT_LOG_FILE) if CURRENT_LOG_FILE else None,
        'logging_enabled': LOGGING_ENABLED,
        'environment': 'local_development' if IS_LOCAL_DEVELOPMENT else 'production',
        'file_logging_available': IS_LOCAL_DEVELOPMENT,
        'message': 'Historical log analysis available via explicit debug endpoints only'
    }

# The following functions are only called by explicit debug routes, never during normal gameplay

def list_game_logs():
    """List all available game log files - ONLY for debug endpoints"""
    if not IS_LOCAL_DEVELOPMENT or not os.path.exists(LOGS_DIRECTORY):
        return []
    
    log_files = []
    for filename in os.listdir(LOGS_DIRECTORY):
        if filename.startswith('game_log_') and filename.endswith('.json'):
            filepath = os.path.join(LOGS_DIRECTORY, filename)
            try:
                parts = filename.replace('game_log_', '').replace('.json', '').split('_')
                if len(parts) >= 3:
                    stat = os.stat(filepath)
                    log_files.append({
                        'filename': filename,
                        'date': parts[0],
                        'time': parts[1],
                        'game_id': parts[2],
                        'size_bytes': stat.st_size,
                        'modified': datetime.fromtimestamp(stat.st_mtime).isoformat()
                    })
            except Exception:
                pass
    
    return sorted(log_files, key=lambda x: x['modified'], reverse=True)

def get_game_log_summary(filename):
    """Get summary of a specific game log file - ONLY for debug endpoints"""
    if not IS_LOCAL_DEVELOPMENT:
        return {'error': 'File logging not available in production'}
    
    filepath = os.path.join(LOGS_DIRECTORY, filename)
    if not os.path.exists(filepath):
        return {'error': f'Log file not found: {filename}'}
    
    try:
        with open(filepath, 'r') as f:
            logs = json.load(f)
        
        log_counts = {}
        for entry in logs:
            log_type = entry.get('log_type', 'unknown')
            log_counts[log_type] = log_counts.get(log_type, 0) + 1
        
        return {
            'filename': filename,
            'total_entries': len(logs),
            'log_type_counts': log_counts,
            'file_size_kb': round(os.path.getsize(filepath) / 1024, 2)
        }
        
    except Exception as e:
        return {'error': f'Could not analyze log file: {e}'}

# =============================================================================
# CONTROL FUNCTIONS
# =============================================================================

def enable_logging():
    """Enable all logging"""
    global LOGGING_ENABLED
    LOGGING_ENABLED = True
    if LOG_TO_CONSOLE:
        print("Logging ENABLED")

def disable_logging():
    """Disable all logging"""
    global LOGGING_ENABLED
    LOGGING_ENABLED = False
    if LOG_TO_CONSOLE:
        print("Logging DISABLED")

def set_console_log_level(level):
    """Set console logging level"""
    global CONSOLE_LOG_LEVEL
    valid_levels = ['ALL', 'ACTIONS_ONLY', 'AI_ONLY', 'EVENTS_ONLY', 'OFF']
    if level in valid_levels:
        CONSOLE_LOG_LEVEL = level
        if LOG_TO_CONSOLE:
            print(f"Console log level set to: {level}")
    else:
        if LOG_TO_CONSOLE:
            print(f"Invalid log level. Valid options: {valid_levels}")

def toggle_console_logging():
    """Toggle console logging on/off"""
    global LOG_TO_CONSOLE
    LOG_TO_CONSOLE = not LOG_TO_CONSOLE
    print(f"Console logging: {'ON' if LOG_TO_CONSOLE else 'OFF'}")

================================================================================

FILE: ./static/game.js
--------------------------------------------------------------------------------
let gameState = null;
let selectedCard = null;
let trickDisplayTimeout = null;
let lastHandNumber = null;

// Bidding confirmation variables
let selectedBid = null;
let confirmingBid = false;

// Scroll preservation for trick history
let trickHistoryScrollPosition = 0;

// MAIN FUNCTIONS
async function loadGameState() {
    try {
        const response = await fetch('/state');
        gameState = await response.json();
        updateUI();
    } catch (error) {
        console.error('Error loading game state:', error);
        showMessage('Error loading game', 'error');
    }
}

function updateUI() {
    if (!gameState) return;

    preserveTrickHistoryScroll();
    updateFloatingScores();
    updatePlayAreaVisibility();
    updateHandCount();
    updateGameOverState();
    updatePhaseVisibility();
    updateMessages();
    updatePlayArea();
    updatePlayerHand();
    updateComputerHand();
    updateActionButtons();
    updateBidButtons();
    updateComputerHandToggle();
    updateDiscards();
    handleResultsDisplay();
    handleTrickCompletion();

    lastHandNumber = gameState.hand_number;
    restoreTrickHistoryScroll();
}

// UI UPDATE FUNCTIONS
function updateFloatingScores() {
    const gameScoreEl = document.getElementById('floatingGameScore');
    if (gameScoreEl) {
        document.getElementById('floatingPlayerScore').textContent = gameState.player_score;
        document.getElementById('floatingComputerScore').textContent = gameState.computer_score;
        document.getElementById('floatingHandNumber').textContent = gameState.hand_number;

        const playerParityText = `(${gameState.player_parity.toUpperCase()})`;
        const computerParityText = `(${gameState.computer_parity.toUpperCase()})`;
        document.getElementById('floatingPlayerParity').textContent = playerParityText;
        document.getElementById('floatingComputerParity').textContent = computerParityText;
    }

    const handScoreEl = document.getElementById('floatingHandScore');
    if (handScoreEl) {
        // Player side
        document.getElementById('floatingPlayerTricks').textContent = gameState.player_tricks;
        const playerBid = gameState.player_bid !== null ? gameState.player_bid : '-';
        const playerBlindText = gameState.blind_bid === gameState.player_bid ? 'B' : '';
        document.getElementById('floatingPlayerBid').textContent = `${playerBid}${playerBlindText}`;

        const playerBidEl = document.getElementById('floatingPlayerBid');
        if (playerBlindText) {
            playerBidEl.style.color = '#dc3545';
            playerBidEl.style.fontWeight = 'bold';
        } else {
            playerBidEl.style.color = '#333';
            playerBidEl.style.fontWeight = '600';
        }

        document.getElementById('floatingPlayerBags').textContent = gameState.player_bags || 0;

        // Computer side
        document.getElementById('floatingComputerTricks').textContent = gameState.computer_tricks;
        const computerBid = gameState.computer_bid !== null ? gameState.computer_bid : '-';
        const computerBlindText = gameState.computer_blind_bid === gameState.computer_bid ? 'B' : '';
        document.getElementById('floatingComputerBid').textContent = `${computerBid}${computerBlindText}`;

        const computerBidEl = document.getElementById('floatingComputerBid');
        const martaWentFirst = gameState.phase === 'bidding' &&
            gameState.computer_bid !== null &&
            gameState.player_bid === null;

        if (computerBlindText) {
            computerBidEl.style.color = '#dc3545';
            computerBidEl.style.fontWeight = 'bold';
            computerBidEl.style.backgroundColor = '';
            computerBidEl.style.border = '';
            computerBidEl.style.borderRadius = '';
            computerBidEl.style.padding = '';
        } else if (martaWentFirst) {
            computerBidEl.style.color = '#1976d2';
            computerBidEl.style.fontWeight = 'bold';
            computerBidEl.style.backgroundColor = '#e3f2fd';
            computerBidEl.style.border = '2px solid #1976d2';
            computerBidEl.style.borderRadius = '4px';
            computerBidEl.style.padding = '2px 4px';
        } else {
            computerBidEl.style.color = '#333';
            computerBidEl.style.fontWeight = '600';
            computerBidEl.style.backgroundColor = '';
            computerBidEl.style.border = '';
            computerBidEl.style.borderRadius = '';
            computerBidEl.style.padding = '';
        }

        document.getElementById('floatingComputerBags').textContent = gameState.computer_bags || 0;
        document.getElementById('floatingSpadesStatus').textContent = gameState.spades_broken ? 'Broken' : 'Not Broken';
    }
}

function updatePlayAreaVisibility() {
    const playArea = document.getElementById('playArea');
    if (!playArea) return;

    // Hide play area during these phases to save screen space
    const hiddenPhases = ['discard', 'bidding', 'blind_decision', 'blind_bidding'];

    if (hiddenPhases.includes(gameState.phase)) {
        playArea.classList.add('hidden-for-phase');
    } else {
        playArea.classList.remove('hidden-for-phase');
    }
}

function updateHandCount() {
    const playerHandCountEl = document.getElementById('playerHandCount');
    if (playerHandCountEl) {
        playerHandCountEl.textContent = `(${gameState.player_hand.length} cards)`;
    }
}

function updateGameOverState() {
    const gameOverEl = document.getElementById('gameOver');
    const winnerTextEl = document.getElementById('winnerText');

    if (gameState.game_over) {
        gameOverEl.style.display = 'block';
        winnerTextEl.textContent = gameState.message;
        hideInteractiveSections();

        // Show results for blind nil games
        if (gameState.hand_results && (gameState.message.includes('BLIND NIL') || gameState.message.includes('Blind Nil'))) {
            handleResultsDisplay();
        } else {
            document.getElementById('resultsSection').classList.remove('show');
        }
    } else {
        gameOverEl.style.display = 'none';
    }
}

function hideInteractiveSections() {
    document.getElementById('biddingSection').style.display = 'none';
    const blindDecisionSection = document.getElementById('blindDecisionSection');
    if (blindDecisionSection) blindDecisionSection.style.display = 'none';
    document.getElementById('discardBlindBiddingSection').style.display = 'none';
    document.getElementById('nextHandSection').style.display = 'none';
    document.getElementById('playerHandSection').style.display = 'none';
    document.getElementById('computerHandSection').style.display = 'none';
}

function updatePhaseVisibility() {
    if (gameState.game_over) return;

    const biddingSection = document.getElementById('biddingSection');
    const blindDecisionSection = document.getElementById('blindDecisionSection');
    const discardBlindSection = document.getElementById('discardBlindBiddingSection');

    // Hide all sections first
    biddingSection.style.display = 'none';
    if (blindDecisionSection) blindDecisionSection.style.display = 'none';
    discardBlindSection.style.display = 'none';

    if (gameState.phase === 'blind_decision') {
        if (blindDecisionSection) blindDecisionSection.style.display = 'block';
    } else if (gameState.phase === 'blind_bidding') {
        discardBlindSection.style.display = 'block';
    } else if (gameState.phase === 'bidding') {
        biddingSection.style.display = 'block';
        if (!biddingSection.classList.contains('active')) {
            biddingSection.classList.add('active');
            resetBiddingState();
        }
    } else {
        biddingSection.classList.remove('active');
    }
}

function updateMessages() {
    if (gameState.game_over) {
        showMessage(gameState.message, gameState.winner === 'player' ? 'success' : '');
        return;
    }

    let messageToShow = gameState.message;



    // Avoid showing detailed results if structured results are shown
    if (gameState.hand_over && gameState.hand_results) {
        messageToShow = `Hand #${gameState.hand_number} complete! Click 'Next Hand' to continue, or scroll for hand stats!`;
    }

    showMessage(messageToShow, messageToShow.includes('WIN') || messageToShow.includes('BLIND NIL SUCCESS') ? 'success' : '');
}

function updatePlayArea() {
    const trickDisplay = document.getElementById('trickDisplay');

    if (gameState.current_trick.length === 0) {
        trickDisplay.innerHTML = '<div style="color: #999; font-size: 14px;">Waiting for play...</div>';
    } else {
        let html = '<div class="trick-container">';

        const playerCard = gameState.current_trick.find(play => play.player === 'player');
        const computerCard = gameState.current_trick.find(play => play.player === 'computer');

        // Always show side by side - You left, Marta right
        if (playerCard) {
            const card = playerCard.card;
            const suitClass = getSuitClass(card.suit);
            html += `
                <div class="trick-card ${suitClass}">
                    <div class="player-name">You</div>
                    <div class="card-content">${card.rank}${card.suit}</div>
                </div>
            `;
        } else {
            html += '<div class="trick-card-placeholder"><div style="font-size: 10px; color: #999;">You</div></div>';
        }

        if (computerCard) {
            const card = computerCard.card;
            const suitClass = getSuitClass(card.suit);
            html += `
                <div class="trick-card ${suitClass}">
                    <div class="player-name">Marta</div>
                    <div class="card-content">${card.rank}${card.suit}</div>
                </div>
            `;
        } else {
            html += '<div class="trick-card-placeholder"><div style="font-size: 10px; color: #999;">Marta</div></div>';
        }

        html += '</div>';
        trickDisplay.innerHTML = html;
    }
}

function updatePlayerHand() {
    const handEl = document.getElementById('playerHand');
    const playerHandSection = document.getElementById('playerHandSection');

    // Hide entire hand section when hand is complete
    if (gameState.hand_over && gameState.player_hand.length === 0) {
        playerHandSection.style.display = 'none';
        return;
    } else {
        playerHandSection.style.display = 'block';
    }

    handEl.innerHTML = '';

    // Hide cards during blind decision or blind bidding phases
    if (gameState.phase === 'blind_decision' || gameState.phase === 'blind_bidding') {
        handEl.innerHTML = '<div style="text-align: center; color: #666; font-style: italic; padding: 20px; border: 2px dashed #ccc; border-radius: 8px;">Cards hidden during blind bidding decision!</div>';
        return;
    }

    gameState.player_hand.forEach((card, index) => {
        const cardEl = document.createElement('div');
        cardEl.className = `card ${getSuitClass(card.suit)}`;
        cardEl.textContent = `${card.rank}${card.suit}`;

        cardEl.onclick = () => selectCard(index);
        cardEl.ontouchstart = (e) => {
            e.preventDefault();
            selectCard(index);
        };

        if (selectedCard === index) {
            cardEl.classList.add('selected');
        }

        if (!canPlayCard(card, index)) {
            cardEl.classList.add('disabled');
        }

        handEl.appendChild(cardEl);
    });
}

function updateComputerHand() {
    const handEl = document.getElementById('computerHand');
    const computerHandSection = handEl.closest('.hand-section');

    // Hide entire computer hand section if debug mode is off
    if (!gameState.debug_mode) {
        computerHandSection.style.display = 'none';
        return;
    }

    computerHandSection.style.display = 'block';
    handEl.innerHTML = '';

    // Only show cards if debug mode is on AND show_computer_hand is true
    if (gameState.debug_mode && gameState.show_computer_hand && gameState.computer_hand) {
        gameState.computer_hand.forEach((card, index) => {
            const cardEl = document.createElement('div');
            cardEl.className = `card ${getSuitClass(card.suit)}`;
            cardEl.textContent = `${card.rank}${card.suit}`;
            cardEl.style.cursor = 'default';
            handEl.appendChild(cardEl);
        });
    } else {
        const cardCount = gameState.computer_hand_count || 0;
        for (let i = 0; i < cardCount; i++) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card';
            cardEl.style.background = '#666';
            cardEl.style.color = '#999';
            cardEl.textContent = '?';
            cardEl.style.cursor = 'default';
            handEl.appendChild(cardEl);
        }
    }
}

function updateActionButtons() {
    const actionButton = document.getElementById('actionButton');
    const nextHandSection = document.getElementById('nextHandSection');

    if (gameState.hand_over && !gameState.game_over) {
        actionButton.style.display = 'none';
        nextHandSection.style.display = 'block';
    } else {
        nextHandSection.style.display = 'none';

        if (gameState.phase === 'discard') {
            actionButton.textContent = 'Discard Selected';
            actionButton.onclick = discardCard;
            actionButton.style.display = 'inline-block';
        } else if (gameState.phase === 'playing') {
            actionButton.textContent = 'Play Selected';
            actionButton.onclick = playCard;
            actionButton.style.display = 'inline-block';
        } else {
            actionButton.style.display = 'none';
        }
    }

    if (selectedCard === null && actionButton.style.display !== 'none') {
        actionButton.disabled = true;
        actionButton.textContent = gameState.phase === 'discard' ? 'Select Card to Discard' : 'Select Card to Play';
    } else if (actionButton.style.display !== 'none') {
        actionButton.disabled = false;
        actionButton.textContent = gameState.phase === 'discard' ? 'Discard Selected' : 'Play Selected';
    }
}

function updateBidButtons() {
    if (gameState.phase !== 'bidding') return;

    const bidButtons = document.querySelectorAll('.bid-btn');
    const confirmButton = document.getElementById('confirmBidButton');
    const cancelButton = document.getElementById('cancelBidButton');

    if (confirmingBid && selectedBid !== null) {
        bidButtons.forEach(btn => {
            const bidValue = parseInt(btn.getAttribute('data-bid'));
            if (bidValue === selectedBid) {
                btn.classList.add('selected');
                btn.style.backgroundColor = '#28a745';
                btn.style.color = 'white';
                btn.style.border = '2px solid #1e7e34';
            } else {
                btn.classList.remove('selected');
                btn.style.backgroundColor = '';
                btn.style.color = '';
                btn.style.border = '';
                btn.style.opacity = '0.6';
            }
        });

        if (confirmButton) confirmButton.style.display = 'inline-block';
        if (cancelButton) cancelButton.style.display = 'inline-block';
    } else {
        bidButtons.forEach(btn => {
            btn.classList.remove('selected');
            btn.style.backgroundColor = '';
            btn.style.color = '';
            btn.style.border = '';
            btn.style.opacity = '';
        });

        if (confirmButton) confirmButton.style.display = 'none';
        if (cancelButton) cancelButton.style.display = 'none';
    }
}

function updateComputerHandToggle() {
    const toggleButton = document.getElementById('toggleComputerHand');
    if (toggleButton) {
        if (gameState.debug_mode) {
            toggleButton.style.display = 'inline-block';
            toggleButton.textContent = gameState.show_computer_hand ? 'Hide Cards' : 'Show Cards';
            toggleButton.style.background = '#6c757d';
        } else {
            toggleButton.style.display = 'none';
        }
    }
}

function updateDiscards() {
    const discardsSection = document.getElementById('discardsSection');

    if (gameState.hand_over && (gameState.player_discarded || gameState.computer_discarded)) {
        discardsSection.style.display = 'block';

        const playerDiscardEl = document.getElementById('playerDiscard');
        if (gameState.player_discarded) {
            const card = gameState.player_discarded;
            playerDiscardEl.innerHTML = `<div class="card ${getSuitClass(card.suit)}">${card.rank}${card.suit}</div>`;
        } else {
            playerDiscardEl.innerHTML = '<div class="card" style="opacity: 0.5;">None</div>';
        }

        const computerDiscardEl = document.getElementById('computerDiscard');
        if (gameState.computer_discarded) {
            const card = gameState.computer_discarded;
            computerDiscardEl.innerHTML = `<div class="card ${getSuitClass(card.suit)}">${card.rank}${card.suit}</div>`;
        } else {
            computerDiscardEl.innerHTML = '<div class="card" style="opacity: 0.5;">None</div>';
        }
    } else {
        discardsSection.style.display = 'none';
    }
}

function handleResultsDisplay() {
    const resultsSection = document.getElementById('resultsSection');
    const resultsContent = document.getElementById('resultsContent');

    if (gameState.hand_over && gameState.hand_results) {
        resultsSection.classList.add('show');
        resultsContent.innerHTML = formatCleanResults(gameState.hand_results);
    } else {
        resultsSection.classList.remove('show');
    }
}

function handleTrickCompletion() {
    // Check for completed trick that needs to be displayed
    if (gameState.current_trick && gameState.current_trick.length === 2 && !trickDisplayTimeout) {
        trickDisplayTimeout = setTimeout(async () => {
            try {
                await fetch('/clear_trick', { method: 'POST' });
                await loadGameState();
                trickDisplayTimeout = null;
            } catch (error) {
                console.error('Error clearing trick:', error);
                trickDisplayTimeout = null;
            }
        }, 1500);
    }
}

// HELPER FUNCTIONS
function getSuitClass(suit) {
    switch (suit) {
        case 'â™ ': return 'spade';
        case 'â™¥': return 'heart';
        case 'â™¦': return 'diamond';
        case 'â™£': return 'club';
        default: return '';
    }
}

function canPlayCard(card, index) {
    if (gameState.phase === 'discard') return true;
    if (gameState.turn !== 'player') return false;

    if (gameState.current_trick.length === 1) {
        const leadSuit = gameState.current_trick[0].card.suit;
        const hasSuit = gameState.player_hand.some(c => c.suit === leadSuit);
        if (hasSuit) {
            return card.suit === leadSuit;
        }
        return true;
    }

    if (gameState.current_trick.length === 0) {
        if (card.suit === 'â™ ' && !gameState.spades_broken) {
            return gameState.player_hand.every(c => c.suit === 'â™ ');
        }
        return true;
    }

    return false;
}

function selectCard(index) {
    if (!canPlayCard(gameState.player_hand[index], index)) {
        showMessage('Cannot play this card!', 'error');
        if (navigator.vibrate) {
            navigator.vibrate(100);
        }
        return;
    }

    selectedCard = index;
    updatePlayerHand();
    updateActionButtons();

    if (navigator.vibrate) {
        navigator.vibrate(50);
    }
}

function showMessage(text, type = '') {
    const messageEl = document.getElementById('message');
    if (messageEl) {
        messageEl.textContent = text;
        messageEl.className = 'message ' + type;
    }
}

// BIDDING FUNCTIONS
function selectBid(bidAmount) {
    if (confirmingBid) return;

    selectedBid = bidAmount;
    confirmingBid = true;

    updateBidButtons();

    const biddingPrompt = document.querySelector('.bidding-prompt');
    if (biddingPrompt) {
        const bidText = bidAmount === 0 ? 'NIL (0 tricks)' : `${bidAmount} tricks`;
        biddingPrompt.innerHTML = `You selected: <strong>${bidText}</strong>`;
    }

    if (navigator.vibrate) navigator.vibrate(50);
}

function confirmSelectedBid() {
    if (selectedBid === null || !confirmingBid) return;

    makeBid(selectedBid);
    resetBiddingState();
}

function cancelBidSelection() {
    resetBiddingState();

    const biddingPrompt = document.querySelector('.bidding-prompt');
    if (biddingPrompt) {
        biddingPrompt.innerHTML = `How many tricks will you take?`;
    }
}

function resetBiddingState() {
    selectedBid = null;
    confirmingBid = false;
    updateBidButtons();
}

// RESULTS FORMATTING
function formatCleanResults(results) {
    let html = '';

    // Parity Assignment
    html += `
        <div class="result-section">
            <div class="result-header">Players</div>
            <div class="result-content">You (${results.parity.player}) vs Marta (${results.parity.computer})</div>
        </div>
    `;

    // Discard Information
    if (results.discard_info && results.discard_info !== 'No discards to score') {
        html += `
            <div class="result-section">
                <div class="result-header">Discard Pile</div>
                <div class="result-content highlight">${results.discard_info}</div>
            </div>
        `;
    }

    // Scoring Breakdown
    html += `
        <div class="result-section">
            <div class="result-header">Scoring</div>
            <div class="result-content">${formatScoring(results.scoring)}</div>
        </div>
    `;

    // Trick History
    if (results.trick_history && results.trick_history.length > 0) {
        html += `
            <div class="result-section">
                <div class="result-header">Trick History</div>
                <div class="trick-history">
        `;

        results.trick_history.forEach(trick => {
            html += `
                <div class="trick-line">
                    <span class="trick-number">T${trick.number}:</span>
                    <span class="trick-cards">${trick.player_card} vs ${trick.computer_card}</span>
                    <span class="trick-winner">â†’ ${trick.winner}</span>
                </div>
            `;
        });

        html += `
                </div>
            </div>
        `;
    }

    // Game Totals
    html += `
        <div class="result-section">
            <div class="result-header">Game Totals</div>
            <div class="result-content totals">
                <span>You: ${results.totals.player_score}</span>
                <span>Marta: ${results.totals.computer_score}</span>
            </div>
        </div>
    `;

    return html;
}

function formatScoring(scoringText) {
    const parts = scoringText.split(' | ');
    return parts.map(part => {
        part = part.trim();

        if (part.includes('BAG PENALTY')) {
            return `<div class="penalty-line">${part.replace('BAG PENALTY!', 'Bag Penalty')}</div>`;
        } else if (part.includes('NEGATIVE BAG BONUS')) {
            return `<div class="bonus-line">${part.replace('NEGATIVE BAG BONUS!', 'Bag Bonus')}</div>`;
        } else if (part.includes('special cards')) {
            return `<div class="special-line">${part}</div>`;
        } else if (part.includes('Bags:')) {
            return `<div class="bags-line">${part}</div>`;
        } else {
            return `<div class="score-line">${part}</div>`;
        }
    }).join('');
}

// SCROLL PRESERVATION
function preserveTrickHistoryScroll() {
    const trickHistory = document.querySelector('.trick-history');
    if (trickHistory) {
        trickHistoryScrollPosition = trickHistory.scrollTop;
    }
}

function restoreTrickHistoryScroll() {
    const trickHistory = document.querySelector('.trick-history');
    if (trickHistory && trickHistoryScrollPosition > 0) {
        setTimeout(() => {
            trickHistory.scrollTop = trickHistoryScrollPosition;
        }, 10);
    }
}

function resetTrickHistoryScroll() {
    trickHistoryScrollPosition = 0;
}

// API FUNCTIONS
async function chooseBlindNil() {
    try {
        const response = await fetch('/choose_blind_nil', { method: 'POST' });
        if (response.ok) {
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error choosing blind nil:', error);
        showMessage('Error choosing blind nil', 'error');
    }
}

async function chooseBlindBidding() {
    try {
        const response = await fetch('/choose_blind_bidding', { method: 'POST' });
        if (response.ok) {
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error choosing blind bidding:', error);
        showMessage('Error choosing blind bidding', 'error');
    }
}

async function chooseNormalBidding() {
    try {
        const response = await fetch('/choose_normal_bidding', { method: 'POST' });
        if (response.ok) {
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error choosing normal bidding:', error);
        showMessage('Error choosing normal bidding', 'error');
    }
}

async function makeBid(bidAmount) {
    try {
        const response = await fetch('/bid', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ bid: bidAmount })
        });

        if (response.ok) {
            await loadGameState();
            if (navigator.vibrate) navigator.vibrate(50);
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error making bid:', error);
        showMessage('Error making bid', 'error');
    }
}

async function makeBlindBid(bidAmount) {
    try {
        const response = await fetch('/blind_bid', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ bid: bidAmount })
        });

        if (response.ok) {
            await loadGameState();
            if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error making blind bid:', error);
        showMessage('Error making blind bid', 'error');
    }
}

async function discardCard() {
    if (selectedCard === null) {
        showMessage('Please select a card to discard', 'error');
        if (navigator.vibrate) navigator.vibrate(100);
        return;
    }

    try {
        const response = await fetch('/discard', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ index: selectedCard })
        });

        if (response.ok) {
            selectedCard = null;
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error discarding card:', error);
        showMessage('Error discarding card', 'error');
    }
}

async function playCard() {
    if (selectedCard === null) {
        showMessage('Please select a card to play', 'error');
        if (navigator.vibrate) navigator.vibrate(100);
        return;
    }

    try {
        const response = await fetch('/play', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ index: selectedCard })
        });

        if (response.ok) {
            selectedCard = null;
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error playing card:', error);
        showMessage('Error playing card', 'error');
    }
}

async function performAction() {
    if (gameState && gameState.phase === 'discard') {
        await discardCard();
    } else {
        await playCard();
    }
}

async function toggleComputerHand() {
    try {
        const response = await fetch('/toggle_computer_hand', { method: 'POST' });
        if (response.ok) {
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error toggling computer hand:', error);
        showMessage('Error toggling computer hand', 'error');
    }
}

async function nextHand() {
    try {
        const response = await fetch('/next_hand', { method: 'POST' });
        if (response.ok) {
            if (trickDisplayTimeout) {
                clearTimeout(trickDisplayTimeout);
                trickDisplayTimeout = null;
            }
            selectedCard = null;
            resetBiddingState();
            resetTrickHistoryScroll();
            await loadGameState();
        } else {
            const error = await response.json();
            showMessage(error.error, 'error');
        }
    } catch (error) {
        console.error('Error starting next hand:', error);
        showMessage('Error starting next hand', 'error');
    }
}

async function startNewGame() {
    try {
        if (trickDisplayTimeout) {
            clearTimeout(trickDisplayTimeout);
            trickDisplayTimeout = null;
        }

        await fetch('/new_game', { method: 'POST' });
        selectedCard = null;
        resetBiddingState();
        resetTrickHistoryScroll();
        await loadGameState();
    } catch (error) {
        console.error('Error starting new game:', error);
        showMessage('Error starting new game', 'error');
    }
}

// INITIALIZATION
document.addEventListener('DOMContentLoaded', function () {
    loadGameState();

    // Prevent zoom on double-tap for mobile
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function (event) {
        const now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300) {
            event.preventDefault();
        }
        lastTouchEnd = now;
    }, false);
});

// Auto-refresh with mobile-friendly timing
setInterval(() => {
    if (gameState && !gameState.game_over && !trickDisplayTimeout) {
        loadGameState();
    }
}, 2500);

// Handle orientation changes on mobile
window.addEventListener('orientationchange', function () {
    setTimeout(() => {
        updatePlayArea();
    }, 100);
});

================================================================================

FILE: ./static/style.css
--------------------------------------------------------------------------------
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    color: #333;
    line-height: 1.6;
}

/* GAME PAGE LAYOUT */
body:not(.instructions-page) {
    padding: 140px 0 40px 0;
}

.container {
    max-width: 650px;
    margin: 0 auto;
    background: white;
    border-radius: 15px;
    padding: 15px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
}

/* FLOATING HEADERS (GAME ONLY) */
.floating-game-score {
    position: fixed;
    top: 10px;
    left: 8px;
    right: 8px;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 10px;
    padding: 10px 15px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    z-index: 999;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 14px;
}

.floating-hand-score {
    position: fixed;
    top: 80px;
    left: 8px;
    right: 8px;
    background: rgba(248, 249, 250, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 8px;
    padding: 8px 15px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    z-index: 998;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: #495057;
}

.game-score-item,
.hand-score-item {
    text-align: center;
    flex: 1;
}

.game-score-label {
    font-size: 11px;
    color: #666;
    margin-bottom: 2px;
}

.game-score-value {
    font-size: 20px;
    font-weight: bold;
    color: #333;
}

.game-score-parity {
    font-size: 9px;
    color: #666;
    margin-bottom: 2px;
    font-weight: normal;
    line-height: 1;
}

.hand-score-item .label {
    color: #6c757d;
    margin-bottom: 2px;
}

.hand-score-item .value {
    font-weight: 600;
    color: #333;
}

/* PLAY AREA */
.play-area {
    padding: 20px 8px;
    margin-bottom: 12px;
    min-height: 140px;
    display: flex;
    justify-content: center;
    align-items: center;
}

.play-area.hidden-for-phase {
    display: none !important;
}

.trick-container {
    display: flex;
    justify-content: space-around;
    align-items: center;
    width: 100%;
    gap: 20px;
    flex-wrap: wrap;
}

.trick-card {
    background: white;
    border: 2px solid #333;
    border-radius: 10px;
    padding: 16px 12px;
    width: 120px;
    height: 140px;
    text-align: center;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    flex-shrink: 0;
}

.trick-card .player-name {
    font-size: 13px;
    font-weight: 600;
    color: #666;
    margin-bottom: 6px;
}

.trick-card .card-content {
    font-size: 32px;
    font-weight: bold;
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
}

.trick-card-placeholder {
    width: 120px;
    height: 140px;
    border: 2px dashed #ccc;
    border-radius: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: #999;
    font-size: 14px;
    flex-shrink: 0;
}

/* CARD COLORS */
.trick-card.spade,
.card.spade,
.spade {
    color: #000;
}

.trick-card.heart,
.card.heart,
.heart {
    color: #ff0000;
}

.trick-card.diamond,
.card.diamond,
.diamond {
    color: #ff6200;
}

.trick-card.club,
.card.club,
.club {
    color: #333;
}

/* MESSAGES */
.message {
    text-align: center;
    padding: 10px 12px;
    margin-bottom: 20px;
    border-radius: 6px;
    font-weight: 400;
    background: #f8f9fa;
    color: #495057;
    font-size: 14px;
    line-height: 1.3;
    border-left: 4px solid #6c757d;
}

.message.success {
    color: #28a745;
    border-left-color: #28a745;
}

.message.error {
    color: #dc3545;
    border-left-color: #dc3545;
}

/* GAME OVER */
.game-over {
    text-align: center;
    padding: 20px 15px;
    background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
    border-radius: 10px;
    margin-bottom: 15px;
    border: 3px solid #ff9800;
    box-shadow: 0 6px 20px rgba(255, 152, 0, 0.3);
    animation: gameOverPulse 2s ease-in-out infinite alternate;
}

.winner-text {
    font-size: 22px;
    font-weight: bold;
    color: #d84315;
    margin-bottom: 15px;
    line-height: 1.2;
    text-shadow: 1px 1px 2px rgba(216, 67, 21, 0.2);
}

@keyframes gameOverPulse {
    0% {
        transform: scale(1);
        box-shadow: 0 6px 20px rgba(255, 152, 0, 0.3);
    }

    100% {
        transform: scale(1.02);
        box-shadow: 0 8px 25px rgba(255, 152, 0, 0.4);
    }
}

/* BUTTONS */
button {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    padding: 12px 18px;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    min-width: 80px;
}

button:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
}

button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* NEXT HAND BUTTON */
.next-hand-section {
    margin-bottom: 20px;
    text-align: center;
}

.next-hand-btn {
    background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%) !important;
    color: white !important;
    border: none !important;
    padding: 16px 20px !important;
    border-radius: 10px !important;
    font-size: 18px !important;
    font-weight: bold !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    width: 100% !important;
    max-width: 400px !important;
    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3) !important;
}

.next-hand-btn:hover {
    background: linear-gradient(135deg, #45a049 0%, #4CAF50 100%) !important;
    transform: translateY(-2px) !important;
    box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4) !important;
}

/* HAND SECTIONS */
.hand-section {
    background: #f8f9fa;
    border-radius: 10px;
    padding: 12px;
    margin-bottom: 15px;
}

.hand-title {
    font-size: 16px;
    font-weight: bold;
    margin-bottom: 8px;
    color: #333;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

/* CARD GRIDS */
.cards {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
    gap: 8px;
    justify-content: center;
    margin-bottom: 12px;
    max-width: 620px;
    margin-left: auto;
    margin-right: auto;
}

.card {
    background: white;
    border: 2px solid #ddd;
    border-radius: 8px;
    padding: 14px 8px;
    min-width: 70px;
    min-height: 90px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 18px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
}

.card:hover:not(.disabled) {
    transform: translateY(-3px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.card.selected {
    border-color: #4CAF50;
    background: #e8f5e9;
    transform: translateY(-3px);
    box-shadow: 0 4px 10px rgba(76, 175, 80, 0.4);
}

.card.disabled {
    opacity: 0.4;
    cursor: not-allowed;
}

/* MOBILE OPTIMIZATIONS */
@media (max-width: 767px) {

    /* Compact 5x2 card layout */
    .cards {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        grid-template-rows: auto auto auto;
        gap: 5px;
        max-width: 300px;
        margin: 0 auto 10px auto;
    }

    .card {
        min-width: 50px;
        min-height: 65px;
        font-size: 14px;
        padding: 8px 4px;
        border-radius: 5px;
    }

    .card:hover:not(.disabled) {
        transform: translateY(-2px);
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
    }

    .card.selected {
        transform: translateY(-2px);
        box-shadow: 0 3px 8px rgba(76, 175, 80, 0.4);
    }

    .hand-section {
        padding: 10px;
        margin-bottom: 12px;
    }
}

/* BIDDING SECTIONS */
.bidding-section {
    background: #f8f9fa;
    border: 2px solid #dee2e6;
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 12px;
    text-align: center;
}

.bidding-title {
    font-size: 18px;
    font-weight: bold;
    color: #333;
    margin-bottom: 8px;
}

.bidding-prompt {
    font-size: 14px;
    color: #666;
    margin-bottom: 12px;
    line-height: 1.3;
}

.bid-buttons {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 8px;
    margin-top: 10px;
    max-width: 320px;
    margin-left: auto;
    margin-right: auto;
}

.bid-buttons button {
    padding: 12px 6px;
    font-size: 14px;
    background: #6c757d;
    color: white;
    font-weight: 600;
    min-width: 40px;
    border-radius: 6px;
    min-height: 50px;
}

.bid-buttons button:hover {
    background: #5a6268;
    transform: translateY(-2px);
}

/* Mobile bidding 6x2 layout */
@media (max-width: 767px) {
    .bid-buttons {
        display: grid;
        grid-template-columns: repeat(6, 1fr);
        grid-template-rows: auto auto;
        gap: 4px;
        max-width: 300px;
    }

    .bid-buttons button {
        padding: 8px 2px;
        font-size: 11px;
        min-width: 45px;
        border-radius: 4px;
        min-height: 36px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        line-height: 1;
    }

    .bid-buttons button small {
        font-size: 8px;
        margin-top: 1px;
        opacity: 0.9;
    }

    /* 6x2 grid arrangement: 0-5 top row, 6-10 bottom row, with 10 spanning center */
    .bid-buttons button:nth-child(1) {
        grid-column: 1;
        grid-row: 1;
    }

    /* 0 NIL */
    .bid-buttons button:nth-child(2) {
        grid-column: 2;
        grid-row: 1;
    }

    /* 1 */
    .bid-buttons button:nth-child(3) {
        grid-column: 3;
        grid-row: 1;
    }

    /* 2 */
    .bid-buttons button:nth-child(4) {
        grid-column: 4;
        grid-row: 1;
    }

    /* 3 */
    .bid-buttons button:nth-child(5) {
        grid-column: 5;
        grid-row: 1;
    }

    /* 4 */
    .bid-buttons button:nth-child(6) {
        grid-column: 6;
        grid-row: 1;
    }

    /* 5 */
    .bid-buttons button:nth-child(7) {
        grid-column: 1;
        grid-row: 2;
    }

    /* 6 */
    .bid-buttons button:nth-child(8) {
        grid-column: 2;
        grid-row: 2;
    }

    /* 7 */
    .bid-buttons button:nth-child(9) {
        grid-column: 3;
        grid-row: 2;
    }

    /* 8 */
    .bid-buttons button:nth-child(10) {
        grid-column: 4;
        grid-row: 2;
    }

    /* 9 */
    .bid-buttons button:nth-child(11) {
        grid-column: 5 / span 2;
        grid-row: 2;
        min-width: 90px;
    }

    /* 10 spanning two columns */
}

/* BID CONFIRMATION BUTTONS */
#confirmBidButton {
    background: #28a745 !important;
    color: white !important;
    border: none !important;
    padding: 14px 28px !important;
    border-radius: 8px !important;
    font-size: 16px !important;
    font-weight: bold !important;
    margin-right: 12px !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3) !important;
}

#confirmBidButton:hover {
    background: #218838 !important;
    transform: translateY(-2px) !important;
    box-shadow: 0 6px 16px rgba(40, 167, 69, 0.4) !important;
}

#cancelBidButton {
    background: #6c757d !important;
    color: white !important;
    border: none !important;
    padding: 14px 28px !important;
    border-radius: 8px !important;
    font-size: 16px !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
}

#cancelBidButton:hover {
    background: #5a6268 !important;
    transform: translateY(-2px) !important;
}

.bid-btn.selected {
    background: #28a745 !important;
    color: white !important;
    border: 3px solid #1e7e34 !important;
    transform: scale(1.05) !important;
    box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4) !important;
}

/* BLIND BIDDING */
.blind-decision-section {
    background: #fff2f2;
    border: 2px solid #e57373;
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 15px;
}

.blind-bidding-section {
    background: #fff2f2;
    border: 2px solid #e57373;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 15px;
}

.blind-header h3 {
    color: #d32f2f;
    margin-bottom: 6px;
    font-size: 16px;
    font-weight: 600;
}

.blind-header p {
    font-size: 12px;
    margin-bottom: 6px;
    color: #333;
    line-height: 1.3;
}

.blind-warning {
    background: #ffcdd2;
    color: #d32f2f;
    padding: 8px;
    border-radius: 4px;
    font-size: 11px;
    font-weight: 500;
    margin-bottom: 8px;
}

.blind-buttons {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 6px;
    max-width: 280px;
    margin: 0 auto;
}

.blind-bid-btn {
    background: #d32f2f;
    color: white;
    font-weight: 600;
    padding: 12px 6px;
    font-size: 12px;
    min-height: 45px;
}

.blind-bid-btn:hover {
    background: #c62828;
    transform: translateY(-2px);
}

@media (max-width: 767px) {
    .blind-buttons {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: auto auto;
        gap: 6px;
        max-width: 250px;
    }

    .blind-bid-btn {
        padding: 10px 4px;
        font-size: 11px;
        min-height: 40px;
        border-radius: 5px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        line-height: 1.1;
    }
}

/* RESULTS AND DISCARDS */
.results-section {
    background: #f8f9fa;
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 20px;
    display: none;
    font-size: 13px;
    color: #495057;
    border: 1px solid #e9ecef;
}

.results-section.show {
    display: block;
}

.results-header {
    font-weight: 600;
    color: #495057;
    margin-bottom: 10px;
    font-size: 16px;
    text-align: center;
    padding-bottom: 6px;
    border-bottom: 2px solid #e9ecef;
}

.result-section {
    margin-bottom: 10px;
    border-bottom: 1px solid #e9ecef;
    padding-bottom: 6px;
}

.result-section:last-child {
    border-bottom: none;
    margin-bottom: 0;
}

.result-header {
    font-size: 12px;
    font-weight: 600;
    color: #6c757d;
    margin-bottom: 4px;
    text-transform: uppercase;
}

.result-content {
    font-size: 13px;
    color: #495057;
    line-height: 1.3;
}

.result-content.highlight {
    background: #e8f5e9;
    padding: 6px 8px;
    border-radius: 4px;
    color: #2e7d32;
}

.result-content.totals {
    display: flex;
    justify-content: space-between;
    font-weight: 600;
    background: #f8f9fa;
    padding: 6px 8px;
    border-radius: 4px;
}

.trick-history {
    font-family: monospace;
    font-size: 11px;
    max-height: 150px;
    overflow-y: auto;
    background: #f8f9fa;
    padding: 8px;
    border-radius: 4px;
    border: 1px solid #e9ecef;
}

.trick-line {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 2px 0;
    border-bottom: 1px solid #e9ecef;
    flex-direction: column;
    align-items: flex-start;
}

.trick-line:last-child {
    border-bottom: none;
}

.trick-number {
    color: #6c757d;
    font-weight: 600;
    width: 100%;
}

.trick-cards {
    width: 100%;
    color: #495057;
    margin: 2px 0;
}

.trick-winner {
    color: #28a745;
    font-weight: 600;
    width: 100%;
    font-size: 10px;
}

.discards-section {
    background: #e8f5e9;
    border: 2px solid #4caf50;
    border-radius: 10px;
    padding: 12px;
    margin-bottom: 20px;
}

.discards-content {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-top: 6px;
}

.discard-item {
    text-align: center;
    background: white;
    padding: 10px;
    border-radius: 6px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
}

.discard-label {
    font-size: 12px;
    font-weight: bold;
    color: #666;
    margin-bottom: 6px;
}

/* BOTTOM NAVIGATION */
.bottom-section {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(5px);
    padding: 4px 8px;
    box-shadow: 0 -2px 6px rgba(0, 0, 0, 0.1);
    z-index: 997;
    text-align: center;
    border-top: 1px solid #e9ecef;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
}

.bottom-new-game-btn,
.bottom-rules-btn {
    border: none;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: 600;
    cursor: pointer;
    height: 22px;
    min-width: 50px;
}

.bottom-new-game-btn {
    background: #dc3545;
    color: white;
}

.bottom-new-game-btn:hover {
    background: #c82333;
}

.bottom-rules-btn {
    background: #28a745;
    color: white;
}

.bottom-rules-btn:hover {
    background: #218838;
}

#toggleComputerHand {
    font-size: 12px;
    padding: 6px 10px;
    background: #6c757d;
    border-radius: 4px;
}

#toggleComputerHand:hover {
    background: #5a6268;
}

/* INSTRUCTIONS PAGE LAYOUT */
.instructions-page body {
    padding: 20px;
}

.instructions-page .container {
    max-width: 800px;
    padding: 30px;
}

.instructions-page h1 {
    color: #4a5568;
    text-align: center;
    margin-bottom: 30px;
    font-size: 2.5em;
}

.instructions-page h2 {
    color: #2d3748;
    margin-top: 30px;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 2px solid #e2e8f0;
}

.instructions-page h3 {
    color: #4a5568;
    margin-top: 20px;
    margin-bottom: 10px;
}

.instructions-page .section {
    margin-bottom: 25px;
}

.instructions-page .highlight {
    background: #fff5f5;
    border-left: 4px solid #e53e3e;
    padding: 15px;
    margin: 15px 0;
    border-radius: 4px;
}

.instructions-page .tip {
    background: #f0fff4;
    border-left: 4px solid #38a169;
    padding: 15px;
    margin: 15px 0;
    border-radius: 4px;
}

.instructions-page .example {
    background: #ebf8ff;
    border: 1px solid #90cdf4;
    padding: 15px;
    margin: 15px 0;
    border-radius: 8px;
}

.instructions-page .card-example {
    display: inline-block;
    background: white;
    border: 2px solid #333;
    border-radius: 6px;
    padding: 8px 12px;
    margin: 2px;
    font-weight: bold;
    min-width: 50px;
    text-align: center;
}

.instructions-page .scoring-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
}

.instructions-page .scoring-table th,
.instructions-page .scoring-table td {
    border: 1px solid #cbd5e0;
    padding: 12px;
    text-align: left;
}

.instructions-page .scoring-table th {
    background: #edf2f7;
    font-weight: bold;
}

.instructions-page .back-button {
    position: fixed;
    top: 20px;
    left: 20px;
    background: #4299e1;
    color: white;
    border: none;
    padding: 12px 20px;
    border-radius: 8px;
    text-decoration: none;
    font-weight: bold;
    box-shadow: 0 4px 12px rgba(66, 153, 225, 0.3);
}

.instructions-page .back-button:hover {
    background: #3182ce;
    transform: translateY(-2px);
}

.instructions-page ol,
.instructions-page ul {
    margin-left: 20px;
    margin-bottom: 15px;
}

.instructions-page li {
    margin-bottom: 8px;
}

/* DESKTOP ADJUSTMENTS */
@media (min-width: 768px) {
    body:not(.instructions-page) {
        padding-top: 160px;
        padding-bottom: 45px;
    }

    .container {
        max-width: 750px;
        padding: 20px;
    }

    .floating-game-score,
    .floating-hand-score {
        max-width: 750px;
        left: 50%;
        right: auto;
        transform: translateX(-50%);
    }

    .floating-hand-score {
        top: 85px;
    }

    .bottom-section {
        max-width: 750px;
        left: 50%;
        right: auto;
        transform: translateX(-50%);
        height: 35px;
    }

    .bottom-new-game-btn,
    .bottom-rules-btn {
        padding: 6px 10px;
        font-size: 11px;
        height: 25px;
        min-width: 60px;
    }

    .play-area {
        min-height: 170px;
        padding: 25px 10px;
    }

    .trick-card {
        width: 140px;
        height: 160px;
        padding: 18px 14px;
    }

    .trick-card .card-content {
        font-size: 36px;
    }

    .trick-card-placeholder {
        width: 140px;
        height: 160px;
    }

    .game-over {
        padding: 25px 20px;
        margin-bottom: 20px;
    }

    .winner-text {
        font-size: 26px;
        margin-bottom: 18px;
    }

    .game-over button {
        padding: 18px 30px;
        font-size: 20px;
    }

    .cards {
        grid-template-columns: repeat(auto-fit, minmax(85px, 1fr));
        gap: 12px;
        max-width: 700px;
        margin: 0 auto 15px auto;
    }

    .card {
        min-width: 85px;
        min-height: 105px;
        font-size: 22px;
        padding: 16px 10px;
    }

    .bid-buttons {
        grid-template-columns: repeat(11, 1fr);
        max-width: 600px;
    }

    .blind-buttons {
        grid-template-columns: repeat(6, 1fr);
        max-width: 400px;
    }

    .trick-line {
        flex-direction: row;
        align-items: center;
    }

    .trick-number,
    .trick-cards,
    .trick-winner {
        width: auto;
        text-align: center;
    }

    .trick-cards {
        margin: 0;
        flex: 1;
    }

    .trick-winner {
        font-size: 11px;
        min-width: 60px;
        text-align: right;
    }

    .trick-history {
        max-height: 200px;
    }
}

================================================================================

FILE: ./static/manifest.json
--------------------------------------------------------------------------------
{
  "name": "Two-Man Spades",
  "short_name": "2ManSpades",
  "description": "Custom spades card game for two players",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#667eea",
  "theme_color": "#667eea",
  "icons": [
    {
      "src": "/static/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/static/icon-512.png", 
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}

================================================================================

FILE: ./templates/index.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Two-Player Spades</title>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-F5VP0CXERK"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-F5VP0CXERK');
    </script>

    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">

    <!-- PWA and Mobile App Settings -->
    <link rel="manifest" href="/static/manifest.json">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Two-Man Spades">
</head>

<body>
    <!-- Floating score headers -->
    <div class="floating-game-score" id="floatingGameScore">
        <div class="game-score-item">
            <div class="game-score-label">You</div>
            <div class="game-score-parity" id="floatingPlayerParity">(EVEN)</div>
            <div class="game-score-value" id="floatingPlayerScore">0</div>
        </div>
        <div class="game-score-item">
            <div class="game-score-label">Hand #<span id="floatingHandNumber">1</span></div>
        </div>
        <div class="game-score-item">
            <div class="game-score-label">Marta</div>
            <div class="game-score-parity" id="floatingComputerParity">(ODD)</div>
            <div class="game-score-value" id="floatingComputerScore">0</div>
        </div>
    </div>

    <div class="floating-hand-score" id="floatingHandScore">
        <div class="hand-score-item">
            <div class="label">Tricks</div>
            <div class="value" id="floatingPlayerTricks">0</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bid</div>
            <div class="value" id="floatingPlayerBid">-</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bags</div>
            <div class="value" id="floatingPlayerBags">0</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Spades</div>
            <div class="value" id="floatingSpadesStatus">Not Broken</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bags</div>
            <div class="value" id="floatingComputerBags">0</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Bid</div>
            <div class="value" id="floatingComputerBid">-</div>
        </div>
        <div class="hand-score-item">
            <div class="label">Tricks</div>
            <div class="value" id="floatingComputerTricks">0</div>
        </div>
    </div>

    <div class="container">
        <!-- Top interactive area -->
        <div class="top-interactive-area">
            <!-- Play area (hidden during bidding/discard phases) -->
            <div class="play-area" id="playArea">
                <div id="trickDisplay"></div>
            </div>

            <!-- Game Over section -->
            <div class="game-over" id="gameOver" style="display: none;">
                <div class="winner-text" id="winnerText"></div>
                <button onclick="startNewGame()">Play Again</button>
            </div>

            <!-- Message area -->
            <div class="message" id="message">Loading game...</div>

            <!-- Next Hand Button -->
            <div class="next-hand-section" id="nextHandSection" style="display: none;">
                <button id="nextHandButton" onclick="nextHand()" class="next-hand-btn">Next Hand</button>
            </div>

            <!-- Discarded cards section -->
            <div class="discards-section" id="discardsSection" style="display: none;">
                <div class="hand-title">Discarded Cards</div>
                <div class="discards-content">
                    <div class="discard-item">
                        <div class="discard-label">You</div>
                        <div id="playerDiscard"></div>
                    </div>
                    <div class="discard-item">
                        <div class="discard-label">Marta</div>
                        <div id="computerDiscard"></div>
                    </div>
                </div>
            </div>

            <!-- Results Section -->
            <div class="results-section" id="resultsSection">
                <div class="results-header">Hand Summary</div>
                <div class="results-content" id="resultsContent"></div>
            </div>

            <!-- Blind Decision Section -->
            <div class="blind-decision-section" id="blindDecisionSection" style="display: none;">
                <div class="blind-header">
                    <h3>Blind Bidding Decision</h3>
                    <p>You're down by 100+ points. Choose your approach:</p>
                </div>
                <div class="decision-buttons"
                    style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 12px;">
                    <button onclick="chooseBlindNil()"
                        style="background: #8b0000; color: white; padding: 12px 6px; border-radius: 6px; font-weight: bold; border: none; cursor: pointer; font-size: 11px;">
                        Blind NIL<br><small>Win or Die!</small>
                    </button>
                    <button onclick="chooseBlindBidding()"
                        style="background: #d32f2f; color: white; padding: 12px 6px; border-radius: 6px; font-weight: bold; border: none; cursor: pointer; font-size: 11px;">
                        Go BLIND<br><small>5-10 tricks</small>
                    </button>
                    <button onclick="chooseNormalBidding()"
                        style="background: #1976d2; color: white; padding: 12px 6px; border-radius: 6px; font-weight: bold; border: none; cursor: pointer; font-size: 11px;">
                        Bid Normal<br><small>See cards</small>
                    </button>
                </div>
            </div>

            <!-- Blind Bidding Section -->
            <div class="blind-bidding-section" id="discardBlindBiddingSection" style="display: none;">
                <div class="blind-header">
                    <h3>Choose Your Blind Bid</h3>
                    <p>You chose to go blind! Pick your bid amount for <strong>DOUBLE</strong> points/penalties!</p>
                    <div class="blind-warning">
                        Must bid at least 5 tricks, get double rewards or double punishment!
                    </div>
                </div>
                <div class="bid-buttons blind-buttons">
                    <button onclick="makeBlindBid(5)" class="blind-bid-btn">BLIND 5</button>
                    <button onclick="makeBlindBid(6)" class="blind-bid-btn">BLIND 6</button>
                    <button onclick="makeBlindBid(7)" class="blind-bid-btn">BLIND 7</button>
                    <button onclick="makeBlindBid(8)" class="blind-bid-btn">BLIND 8</button>
                    <button onclick="makeBlindBid(9)" class="blind-bid-btn">BLIND 9</button>
                    <button onclick="makeBlindBid(10)" class="blind-bid-btn">BLIND 10</button>
                </div>
            </div>

            <!-- Regular Bidding Section -->
            <div class="bidding-section" id="biddingSection" style="display: none;">
                <div class="bidding-title">Make Your Bid</div>
                <div class="bidding-prompt">How many tricks will you take?</div>

                <!-- 6x2 bidding buttons -->
                <div class="bid-buttons">
                    <button onclick="selectBid(0)" class="bid-btn" data-bid="0">0<br><small>NIL</small></button>
                    <button onclick="selectBid(1)" class="bid-btn" data-bid="1">1</button>
                    <button onclick="selectBid(2)" class="bid-btn" data-bid="2">2</button>
                    <button onclick="selectBid(3)" class="bid-btn" data-bid="3">3</button>
                    <button onclick="selectBid(4)" class="bid-btn" data-bid="4">4</button>
                    <button onclick="selectBid(5)" class="bid-btn" data-bid="5">5</button>
                    <button onclick="selectBid(6)" class="bid-btn" data-bid="6">6</button>
                    <button onclick="selectBid(7)" class="bid-btn" data-bid="7">7</button>
                    <button onclick="selectBid(8)" class="bid-btn" data-bid="8">8</button>
                    <button onclick="selectBid(9)" class="bid-btn" data-bid="9">9</button>
                    <button onclick="selectBid(10)" class="bid-btn" data-bid="10">10</button>
                </div>

                <!-- Confirmation buttons -->
                <div class="bid-confirmation-buttons" style="margin-top: 12px; text-align: center;">
                    <button id="confirmBidButton" onclick="confirmSelectedBid()" style="display: none;">
                        Confirm Bid
                    </button>
                    <button id="cancelBidButton" onclick="cancelBidSelection()" style="display: none;">
                        Cancel
                    </button>
                </div>
            </div>
        </div>

        <!-- Hands area -->
        <div class="hands-area">
            <!-- Player hand section -->
            <div class="hand-section" id="playerHandSection">
                <div class="hand-title">
                    Your Hand
                    <span style="font-size: 12px; color: #666; font-weight: normal;" id="playerHandCount"></span>
                </div>
                <div class="cards" id="playerHand"></div>
                <div class="controls">
                    <button id="actionButton" onclick="performAction()">Select Card</button>
                </div>
            </div>

            <!-- Computer hand section -->
            <div class="hand-section" id="computerHandSection">
                <div class="hand-title">
                    Marta's Hand (hidden)
                    <button id="toggleComputerHand" onclick="toggleComputerHand()" style="display: none;">Show
                        Cards</button>
                </div>
                <div class="cards" id="computerHand"></div>
            </div>
        </div>

        <!-- Bottom navigation -->
        <div class="bottom-section">
            <button class="bottom-new-game-btn" onclick="startNewGame()">New Game</button>
            <button class="bottom-rules-btn" onclick="window.open('/instructions', '_blank')">How to Play</button>
        </div>
    </div>

    <script src="{{ url_for('static', filename='game.js') }}"></script>
</body>

</html>

================================================================================

FILE: ./templates/instructions.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How to Play Two-Man Spades</title>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-F5VP0CXERK"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-F5VP0CXERK');
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #4a5568;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        h2 {
            color: #2d3748;
            margin-top: 30px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e2e8f0;
        }

        h3 {
            color: #4a5568;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .section {
            margin-bottom: 25px;
        }

        .highlight {
            background: #fff5f5;
            border-left: 4px solid #e53e3e;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .tip {
            background: #f0fff4;
            border-left: 4px solid #38a169;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .example {
            background: #ebf8ff;
            border: 1px solid #90cdf4;
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
        }

        .card-example {
            display: inline-block;
            background: white;
            border: 2px solid #333;
            border-radius: 6px;
            padding: 8px 12px;
            margin: 2px;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
        }

        .spade {
            color: #000;
        }

        .heart {
            color: #ff0000;
        }

        .diamond {
            color: #ff6200;
        }

        .club {
            color: #333;
        }

        .scoring-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }

        .scoring-table th,
        .scoring-table td {
            border: 1px solid #cbd5e0;
            padding: 12px;
            text-align: left;
        }

        .scoring-table th {
            background: #edf2f7;
            font-weight: bold;
        }

        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #4299e1;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(66, 153, 225, 0.3);
        }

        .back-button:hover {
            background: #3182ce;
            transform: translateY(-2px);
        }

        ol,
        ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
        }
    </style>
</head>

<body>
    <a href="/" class="back-button">â† Back to Game</a>

    <div class="container">
        <h1>How to Play Two-Man Spades</h1>

        <div class="section">
            <div class="highlight">
                <h3>About This Game</h3>
                <p><strong>This is a custom variant developed over years of play.</strong> While based on traditional
                    Spades, this "Two-Man Spades" includes unique rules like parity scoring, special bag-reduction
                    cards, and blind bidding that don't exist in standard Spades. The game mechanics have been tested
                    and refined to be balanced and enjoyable, but this is essentially a "house rules" version.</p>
                <p><strong>Original invented rules:</strong> <a
                        href="https://docs.google.com/spreadsheets/d/1uxxzX09zhGm0b8R48Fi4vHvOEyrlp1AmVN-sN41voj0/edit?usp=sharing"
                        target="_blank" style="color: #3182ce;">Chicken-scratched 2manSpades rules...</a></p>
            </div>
        </div>
        <div class="section">
            <h2>Install as Mobile App</h2>
            <p>You can install Two-Man Spades as an app on your phone for a better full-screen experience:</p>

            <div class="tip">
                <strong>iPhone (Safari):</strong>
                <ol>
                    <li>Open the game in Safari</li>
                    <li>Tap the Share button (square with arrow up)</li>
                    <li>Scroll down and tap "Add to Home Screen"</li>
                    <li>Tap "Add" - the game icon will appear on your home screen</li>
                </ol>
            </div>

            <div class="tip">
                <strong>Android (Chrome):</strong>
                <ol>
                    <li>Open the game in Chrome</li>
                    <li>Tap the three dots menu (â‹®)</li>
                    <li>Tap "Add to Home Screen" or "Install app"</li>
                    <li>Tap "Add" - the game icon will appear on your home screen</li>
                </ol>
            </div>

            <p>Once installed, the game will open in full-screen mode without browser bars, just like a native app!</p>
        </div>
        <div class="section">
            <h2>Overview</h2>
            <p>Two-Man Spades is a trick-taking card game where you compete against Marta (the computer) to reach 300
                points first. Each hand, you'll discard one card, bid on how many tricks you think you can win, then
                play cards strategically to meet your bid while preventing your opponent from meeting theirs.</p>
        </div>

        <div class="section">
            <h2>Game Setup</h2>
            <p>At the start of each game, players are randomly assigned <strong>parity</strong>:</p>
            <ul>
                <li><strong>Even Player:</strong> Gets bonus points when discard pile totals an even number</li>
                <li><strong>Odd Player:</strong> Gets bonus points when discard pile totals an odd number</li>
            </ul>
            <p>Each hand deals 11 cards to each player from a standard 52-card deck.</p>
        </div>

        <div class="section">
            <h2>Hand Flow</h2>

            <h3>1. Discard Phase</h3>
            <p>Each player selects one card to discard face-down. These cards are revealed simultaneously and:</p>
            <ul>
                <li>Their face values are added together (Ace=1, Jack=11, Queen=12, King=13)</li>
                <li>The player whose parity matches the total gets bonus points</li>
                <li>If both cards are the same suit OR same rank, points are doubled</li>
                <li>Base bonus is 10 points (20 for doubles)</li>
            </ul>

            <div class="example">
                <strong>Example:</strong> You discard 7â™£ (value 7), Marta discards 6â™¥ (value 6).
                Total = 13 (odd). If you're the odd player, you get 10 points.
                If both cards were hearts, you'd get 20 points instead.
            </div>

            <h3>2. Bidding Phase</h3>
            <p>Players bid how many tricks (out of 10) they expect to win with their remaining cards.</p>

            <div class="highlight">
                <strong>Special Bidding Rules:</strong>
                <ul>
                    <li><strong>NIL (0 bid):</strong> If you take exactly 0 tricks, get +200 points. If you take any
                        tricks, lose -200 points and gain that many bags.</li>
                    <li><strong>Blind Bidding:</strong> When down by 100+ points, you can bid "blind" (5-10 tricks) for
                        double points/penalties before seeing your cards!</li>
                </ul>
            </div>

            <h3>3. Playing Tricks</h3>
            <p>Players take turns playing cards. The person with the odd parity leads the first trick of each hand.</p>

            <h4>Playing Rules:</h4>
            <ul>
                <li><strong>Follow Suit:</strong> You must play the same suit as the lead card if you have it</li>
                <li><strong>Trump:</strong> Spades (â™ ) always beat other suits</li>
                <li><strong>Spades Broken:</strong> You can't lead spades until they've been "broken" by someone playing
                    a spade on a different suit</li>
                <li><strong>Highest Card Wins:</strong> Within the same suit, higher cards win (Ace is highest)</li>
            </ul>

            <div class="example">
                <strong>Trick Example:</strong> Marta leads <span class="card-example heart">Qâ™¥</span>.
                You have <span class="card-example heart">7â™¥</span> and <span class="card-example spade">3â™ </span>.
                You must play the 7â™¥ (follow suit). Marta wins with the higher heart.
            </div>
        </div>

        <div class="section">
            <h2>Scoring System</h2>

            <h3>Basic Scoring</h3>
            <table class="scoring-table">
                <tr>
                    <th>Situation</th>
                    <th>Points Earned</th>
                </tr>
                <tr>
                    <td>Made your bid exactly</td>
                    <td>Bid Ã— 10 points</td>
                </tr>
                <tr>
                    <td>Made more than your bid</td>
                    <td>Bid Ã— 10 points + 1 bag per extra trick</td>
                </tr>
                <tr>
                    <td>Failed to make your bid</td>
                    <td>Lose Bid Ã— 10 points</td>
                </tr>
                <tr>
                    <td>NIL success (0 bid, 0 tricks)</td>
                    <td>+200 points</td>
                </tr>
                <tr>
                    <td>NIL failure (0 bid, any tricks)</td>
                    <td>-200 points + tricks as bags</td>
                </tr>
                <tr>
                    <td>Blind bid success</td>
                    <td>Double normal points</td>
                </tr>
                <tr>
                    <td>Blind bid failure</td>
                    <td>Double normal penalty</td>
                </tr>
            </table>

            <h3>Bags System</h3>
            <p>Bags are penalties for taking more tricks than you bid:</p>
            <ul>
                <li>Every 7 bags = -100 points penalty</li>
                <li>Negative bags give bonuses: every 5 negative bags = +100 points</li>
                <li>Your score display shows base score + bags in the ones digit</li>
            </ul>

            <div class="tip">
                <strong>Bag Strategy:</strong> Sometimes it's better to let your opponent win a trick rather than
                accumulate bags, especially when you're close to a 7-bag penalty!
            </div>
        </div>

        <div class="section">
            <h2>Special Cards</h2>
            <p>Two cards provide bag reduction when won in tricks or discard piles:</p>
            <ul>
                <li><span class="card-example diamond">7â™¦</span> Seven of Diamonds: -2 bags</li>
                <li><span class="card-example club">10â™£</span> Ten of Clubs: -1 bag</li>
            </ul>
            <p>The player who wins the trick or discard pile containing these cards gets the bag reduction.</p>
        </div>

        <div class="section">
            <h2>Winning the Game</h2>
            <p>The game ends when:</p>
            <ul>
                <li><strong>Target Reached:</strong> Someone reaches 300 points (winner has highest score)</li>
                <li><strong>Mercy Rule:</strong> Someone leads by 300+ points (automatic win)</li>
            </ul>

            <h3>Tie-Breaking</h3>
            <p>If display scores are tied at 300+:</p>
            <ol>
                <li>Player with higher base score wins</li>
                <li>If base scores tied, player with fewer bags wins</li>
                <li>If one player has negative bags, they win</li>
            </ol>
        </div>

        <div class="section">
            <h2>Advanced Features</h2>

            <h3>Auto-Resolution</h3>
            <p>When the outcome of remaining tricks is mathematically certain (like when one player has only spades and
                the other has none), the game automatically plays out the remaining cards to save time while showing you
                exactly what happened.</p>


        </div>

        <div class="section">
            <h2>Strategy Tips</h2>

            <div class="tip">
                <strong>Bidding Strategy:</strong>
                <ul>
                    <li>Count your high spades - they're usually reliable tricks</li>
                    <li>Look for aces in other suits, but remember they can be trumped</li>
                    <li>Consider void suits (suits you have no cards in) - you can trump them</li>
                    <li>Be conservative when you have many bags</li>
                </ul>
            </div>

            <div class="tip">
                <strong>Playing Strategy:</strong>
                <ul>
                    <li>Try to force out high cards early when you're leading</li>
                    <li>Count cards to know what's still in play</li>
                    <li>Use your spades wisely - they're powerful but limited</li>
                    <li>Sometimes let your opponent win tricks if you've already made your bid</li>
                </ul>
            </div>

            <div class="tip">
                <strong>Discard Strategy:</strong>
                <ul>
                    <li>Discard singleton special cards (7â™¦ or 10â™£) to create voids</li>
                    <li>Create voids in suits where you have spades to trump</li>
                    <li>Consider the parity game - sometimes a strategic discard can win you bonus points</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>Interface Guide</h2>
            <ul>
                <li><strong>Top Headers:</strong> Show game scores, hand number, and current hand status</li>
                <li><strong>Play Area:</strong> Shows current trick being played</li>
                <li><strong>Your Cards:</strong> Click to select, then use the action button</li>
                <li><strong>Results Summary:</strong> After each hand, review detailed scoring and trick history</li>
                <li><strong>Auto-Resolution Message:</strong> When remaining tricks are predetermined, you'll see
                    exactly what happened</li>
            </ul>
        </div>

        <div class="section">
            <p style="text-align: center; margin-top: 40px; font-style: italic; color: #666;">
                Two-Man Spades combines strategy, memory, and calculated risk-taking. Each hand is a puzzle to solve,
                and each game tells a story. Good luck, and may your bids be true!
            </p>
        </div>
    </div>
</body>

</html>

================================================================================

